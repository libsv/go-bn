// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/libsv/go-bn"
	"github.com/libsv/go-bn/models"
	"sync"
	"time"
)

// Ensure, that ControlClientMock does implement bn.ControlClient.
// If this is not the case, regenerate this file with moq.
var _ bn.ControlClient = &ControlClientMock{}

// ControlClientMock is a mock implementation of bn.ControlClient.
//
// 	func TestSomethingThatUsesControlClient(t *testing.T) {
//
// 		// make and configure a mocked bn.ControlClient
// 		mockedControlClient := &ControlClientMock{
// 			ActiveZMQNotificationsFunc: func(ctx context.Context) ([]*models.ZMQNotification, error) {
// 				panic("mock out the ActiveZMQNotifications method")
// 			},
// 			DumpParamsFunc: func(ctx context.Context) ([]string, error) {
// 				panic("mock out the DumpParams method")
// 			},
// 			InfoFunc: func(ctx context.Context) (*models.Info, error) {
// 				panic("mock out the Info method")
// 			},
// 			MemoryInfoFunc: func(ctx context.Context) (*models.MemoryInfo, error) {
// 				panic("mock out the MemoryInfo method")
// 			},
// 			SettingsFunc: func(ctx context.Context) (*models.Settings, error) {
// 				panic("mock out the Settings method")
// 			},
// 			StopFunc: func(ctx context.Context) error {
// 				panic("mock out the Stop method")
// 			},
// 			UptimeFunc: func(ctx context.Context) (time.Duration, error) {
// 				panic("mock out the Uptime method")
// 			},
// 		}
//
// 		// use mockedControlClient in code that requires bn.ControlClient
// 		// and then make assertions.
//
// 	}
type ControlClientMock struct {
	// ActiveZMQNotificationsFunc mocks the ActiveZMQNotifications method.
	ActiveZMQNotificationsFunc func(ctx context.Context) ([]*models.ZMQNotification, error)

	// DumpParamsFunc mocks the DumpParams method.
	DumpParamsFunc func(ctx context.Context) ([]string, error)

	// InfoFunc mocks the Info method.
	InfoFunc func(ctx context.Context) (*models.Info, error)

	// MemoryInfoFunc mocks the MemoryInfo method.
	MemoryInfoFunc func(ctx context.Context) (*models.MemoryInfo, error)

	// SettingsFunc mocks the Settings method.
	SettingsFunc func(ctx context.Context) (*models.Settings, error)

	// StopFunc mocks the Stop method.
	StopFunc func(ctx context.Context) error

	// UptimeFunc mocks the Uptime method.
	UptimeFunc func(ctx context.Context) (time.Duration, error)

	// calls tracks calls to the methods.
	calls struct {
		// ActiveZMQNotifications holds details about calls to the ActiveZMQNotifications method.
		ActiveZMQNotifications []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// DumpParams holds details about calls to the DumpParams method.
		DumpParams []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Info holds details about calls to the Info method.
		Info []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// MemoryInfo holds details about calls to the MemoryInfo method.
		MemoryInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Settings holds details about calls to the Settings method.
		Settings []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Stop holds details about calls to the Stop method.
		Stop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Uptime holds details about calls to the Uptime method.
		Uptime []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockActiveZMQNotifications sync.RWMutex
	lockDumpParams             sync.RWMutex
	lockInfo                   sync.RWMutex
	lockMemoryInfo             sync.RWMutex
	lockSettings               sync.RWMutex
	lockStop                   sync.RWMutex
	lockUptime                 sync.RWMutex
}

// ActiveZMQNotifications calls ActiveZMQNotificationsFunc.
func (mock *ControlClientMock) ActiveZMQNotifications(ctx context.Context) ([]*models.ZMQNotification, error) {
	if mock.ActiveZMQNotificationsFunc == nil {
		panic("ControlClientMock.ActiveZMQNotificationsFunc: method is nil but ControlClient.ActiveZMQNotifications was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockActiveZMQNotifications.Lock()
	mock.calls.ActiveZMQNotifications = append(mock.calls.ActiveZMQNotifications, callInfo)
	mock.lockActiveZMQNotifications.Unlock()
	return mock.ActiveZMQNotificationsFunc(ctx)
}

// ActiveZMQNotificationsCalls gets all the calls that were made to ActiveZMQNotifications.
// Check the length with:
//     len(mockedControlClient.ActiveZMQNotificationsCalls())
func (mock *ControlClientMock) ActiveZMQNotificationsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockActiveZMQNotifications.RLock()
	calls = mock.calls.ActiveZMQNotifications
	mock.lockActiveZMQNotifications.RUnlock()
	return calls
}

// DumpParams calls DumpParamsFunc.
func (mock *ControlClientMock) DumpParams(ctx context.Context) ([]string, error) {
	if mock.DumpParamsFunc == nil {
		panic("ControlClientMock.DumpParamsFunc: method is nil but ControlClient.DumpParams was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockDumpParams.Lock()
	mock.calls.DumpParams = append(mock.calls.DumpParams, callInfo)
	mock.lockDumpParams.Unlock()
	return mock.DumpParamsFunc(ctx)
}

// DumpParamsCalls gets all the calls that were made to DumpParams.
// Check the length with:
//     len(mockedControlClient.DumpParamsCalls())
func (mock *ControlClientMock) DumpParamsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockDumpParams.RLock()
	calls = mock.calls.DumpParams
	mock.lockDumpParams.RUnlock()
	return calls
}

// Info calls InfoFunc.
func (mock *ControlClientMock) Info(ctx context.Context) (*models.Info, error) {
	if mock.InfoFunc == nil {
		panic("ControlClientMock.InfoFunc: method is nil but ControlClient.Info was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	return mock.InfoFunc(ctx)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//     len(mockedControlClient.InfoCalls())
func (mock *ControlClientMock) InfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// MemoryInfo calls MemoryInfoFunc.
func (mock *ControlClientMock) MemoryInfo(ctx context.Context) (*models.MemoryInfo, error) {
	if mock.MemoryInfoFunc == nil {
		panic("ControlClientMock.MemoryInfoFunc: method is nil but ControlClient.MemoryInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockMemoryInfo.Lock()
	mock.calls.MemoryInfo = append(mock.calls.MemoryInfo, callInfo)
	mock.lockMemoryInfo.Unlock()
	return mock.MemoryInfoFunc(ctx)
}

// MemoryInfoCalls gets all the calls that were made to MemoryInfo.
// Check the length with:
//     len(mockedControlClient.MemoryInfoCalls())
func (mock *ControlClientMock) MemoryInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockMemoryInfo.RLock()
	calls = mock.calls.MemoryInfo
	mock.lockMemoryInfo.RUnlock()
	return calls
}

// Settings calls SettingsFunc.
func (mock *ControlClientMock) Settings(ctx context.Context) (*models.Settings, error) {
	if mock.SettingsFunc == nil {
		panic("ControlClientMock.SettingsFunc: method is nil but ControlClient.Settings was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSettings.Lock()
	mock.calls.Settings = append(mock.calls.Settings, callInfo)
	mock.lockSettings.Unlock()
	return mock.SettingsFunc(ctx)
}

// SettingsCalls gets all the calls that were made to Settings.
// Check the length with:
//     len(mockedControlClient.SettingsCalls())
func (mock *ControlClientMock) SettingsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSettings.RLock()
	calls = mock.calls.Settings
	mock.lockSettings.RUnlock()
	return calls
}

// Stop calls StopFunc.
func (mock *ControlClientMock) Stop(ctx context.Context) error {
	if mock.StopFunc == nil {
		panic("ControlClientMock.StopFunc: method is nil but ControlClient.Stop was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockStop.Lock()
	mock.calls.Stop = append(mock.calls.Stop, callInfo)
	mock.lockStop.Unlock()
	return mock.StopFunc(ctx)
}

// StopCalls gets all the calls that were made to Stop.
// Check the length with:
//     len(mockedControlClient.StopCalls())
func (mock *ControlClientMock) StopCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockStop.RLock()
	calls = mock.calls.Stop
	mock.lockStop.RUnlock()
	return calls
}

// Uptime calls UptimeFunc.
func (mock *ControlClientMock) Uptime(ctx context.Context) (time.Duration, error) {
	if mock.UptimeFunc == nil {
		panic("ControlClientMock.UptimeFunc: method is nil but ControlClient.Uptime was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockUptime.Lock()
	mock.calls.Uptime = append(mock.calls.Uptime, callInfo)
	mock.lockUptime.Unlock()
	return mock.UptimeFunc(ctx)
}

// UptimeCalls gets all the calls that were made to Uptime.
// Check the length with:
//     len(mockedControlClient.UptimeCalls())
func (mock *ControlClientMock) UptimeCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockUptime.RLock()
	calls = mock.calls.Uptime
	mock.lockUptime.RUnlock()
	return calls
}

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/libsv/go-bc"
	"github.com/libsv/go-bn"
	"github.com/libsv/go-bn/models"
	"sync"
)

// Ensure, that MiningClientMock does implement bn.MiningClient.
// If this is not the case, regenerate this file with moq.
var _ bn.MiningClient = &MiningClientMock{}

// MiningClientMock is a mock implementation of bn.MiningClient.
//
// 	func TestSomethingThatUsesMiningClient(t *testing.T) {
//
// 		// make and configure a mocked bn.MiningClient
// 		mockedMiningClient := &MiningClientMock{
// 			BlockTemplateFunc: func(ctx context.Context, opts *models.BlockTemplateRequest) (*models.BlockTemplate, error) {
// 				panic("mock out the BlockTemplate method")
// 			},
// 			MiningCandidateFunc: func(ctx context.Context, opts *models.OptsMiningCandidate) (*models.MiningCandidate, error) {
// 				panic("mock out the MiningCandidate method")
// 			},
// 			MiningInfoFunc: func(ctx context.Context) (*models.MiningInfo, error) {
// 				panic("mock out the MiningInfo method")
// 			},
// 			NetworkHashPSFunc: func(ctx context.Context, opts *models.OptsNetworkHashPS) (uint64, error) {
// 				panic("mock out the NetworkHashPS method")
// 			},
// 			PrioritiseTxFunc: func(ctx context.Context, txID string, feeDelta int64) (bool, error) {
// 				panic("mock out the PrioritiseTx method")
// 			},
// 			SubmitBlockFunc: func(ctx context.Context, block *bc.Block, params *models.OptsSubmitBlock) (string, error) {
// 				panic("mock out the SubmitBlock method")
// 			},
// 			SubmitMiningSolutionFunc: func(ctx context.Context, solution *models.MiningSolution) (string, error) {
// 				panic("mock out the SubmitMiningSolution method")
// 			},
// 			VerifyBlockCandidateFunc: func(ctx context.Context, block *bc.Block, params *models.OptsSubmitBlock) (string, error) {
// 				panic("mock out the VerifyBlockCandidate method")
// 			},
// 		}
//
// 		// use mockedMiningClient in code that requires bn.MiningClient
// 		// and then make assertions.
//
// 	}
type MiningClientMock struct {
	// BlockTemplateFunc mocks the BlockTemplate method.
	BlockTemplateFunc func(ctx context.Context, opts *models.BlockTemplateRequest) (*models.BlockTemplate, error)

	// MiningCandidateFunc mocks the MiningCandidate method.
	MiningCandidateFunc func(ctx context.Context, opts *models.OptsMiningCandidate) (*models.MiningCandidate, error)

	// MiningInfoFunc mocks the MiningInfo method.
	MiningInfoFunc func(ctx context.Context) (*models.MiningInfo, error)

	// NetworkHashPSFunc mocks the NetworkHashPS method.
	NetworkHashPSFunc func(ctx context.Context, opts *models.OptsNetworkHashPS) (uint64, error)

	// PrioritiseTxFunc mocks the PrioritiseTx method.
	PrioritiseTxFunc func(ctx context.Context, txID string, feeDelta int64) (bool, error)

	// SubmitBlockFunc mocks the SubmitBlock method.
	SubmitBlockFunc func(ctx context.Context, block *bc.Block, params *models.OptsSubmitBlock) (string, error)

	// SubmitMiningSolutionFunc mocks the SubmitMiningSolution method.
	SubmitMiningSolutionFunc func(ctx context.Context, solution *models.MiningSolution) (string, error)

	// VerifyBlockCandidateFunc mocks the VerifyBlockCandidate method.
	VerifyBlockCandidateFunc func(ctx context.Context, block *bc.Block, params *models.OptsSubmitBlock) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// BlockTemplate holds details about calls to the BlockTemplate method.
		BlockTemplate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.BlockTemplateRequest
		}
		// MiningCandidate holds details about calls to the MiningCandidate method.
		MiningCandidate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsMiningCandidate
		}
		// MiningInfo holds details about calls to the MiningInfo method.
		MiningInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// NetworkHashPS holds details about calls to the NetworkHashPS method.
		NetworkHashPS []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsNetworkHashPS
		}
		// PrioritiseTx holds details about calls to the PrioritiseTx method.
		PrioritiseTx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
			// FeeDelta is the feeDelta argument value.
			FeeDelta int64
		}
		// SubmitBlock holds details about calls to the SubmitBlock method.
		SubmitBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Block is the block argument value.
			Block *bc.Block
			// Params is the params argument value.
			Params *models.OptsSubmitBlock
		}
		// SubmitMiningSolution holds details about calls to the SubmitMiningSolution method.
		SubmitMiningSolution []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Solution is the solution argument value.
			Solution *models.MiningSolution
		}
		// VerifyBlockCandidate holds details about calls to the VerifyBlockCandidate method.
		VerifyBlockCandidate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Block is the block argument value.
			Block *bc.Block
			// Params is the params argument value.
			Params *models.OptsSubmitBlock
		}
	}
	lockBlockTemplate        sync.RWMutex
	lockMiningCandidate      sync.RWMutex
	lockMiningInfo           sync.RWMutex
	lockNetworkHashPS        sync.RWMutex
	lockPrioritiseTx         sync.RWMutex
	lockSubmitBlock          sync.RWMutex
	lockSubmitMiningSolution sync.RWMutex
	lockVerifyBlockCandidate sync.RWMutex
}

// BlockTemplate calls BlockTemplateFunc.
func (mock *MiningClientMock) BlockTemplate(ctx context.Context, opts *models.BlockTemplateRequest) (*models.BlockTemplate, error) {
	if mock.BlockTemplateFunc == nil {
		panic("MiningClientMock.BlockTemplateFunc: method is nil but MiningClient.BlockTemplate was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.BlockTemplateRequest
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockBlockTemplate.Lock()
	mock.calls.BlockTemplate = append(mock.calls.BlockTemplate, callInfo)
	mock.lockBlockTemplate.Unlock()
	return mock.BlockTemplateFunc(ctx, opts)
}

// BlockTemplateCalls gets all the calls that were made to BlockTemplate.
// Check the length with:
//     len(mockedMiningClient.BlockTemplateCalls())
func (mock *MiningClientMock) BlockTemplateCalls() []struct {
	Ctx  context.Context
	Opts *models.BlockTemplateRequest
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.BlockTemplateRequest
	}
	mock.lockBlockTemplate.RLock()
	calls = mock.calls.BlockTemplate
	mock.lockBlockTemplate.RUnlock()
	return calls
}

// MiningCandidate calls MiningCandidateFunc.
func (mock *MiningClientMock) MiningCandidate(ctx context.Context, opts *models.OptsMiningCandidate) (*models.MiningCandidate, error) {
	if mock.MiningCandidateFunc == nil {
		panic("MiningClientMock.MiningCandidateFunc: method is nil but MiningClient.MiningCandidate was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsMiningCandidate
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockMiningCandidate.Lock()
	mock.calls.MiningCandidate = append(mock.calls.MiningCandidate, callInfo)
	mock.lockMiningCandidate.Unlock()
	return mock.MiningCandidateFunc(ctx, opts)
}

// MiningCandidateCalls gets all the calls that were made to MiningCandidate.
// Check the length with:
//     len(mockedMiningClient.MiningCandidateCalls())
func (mock *MiningClientMock) MiningCandidateCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsMiningCandidate
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsMiningCandidate
	}
	mock.lockMiningCandidate.RLock()
	calls = mock.calls.MiningCandidate
	mock.lockMiningCandidate.RUnlock()
	return calls
}

// MiningInfo calls MiningInfoFunc.
func (mock *MiningClientMock) MiningInfo(ctx context.Context) (*models.MiningInfo, error) {
	if mock.MiningInfoFunc == nil {
		panic("MiningClientMock.MiningInfoFunc: method is nil but MiningClient.MiningInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockMiningInfo.Lock()
	mock.calls.MiningInfo = append(mock.calls.MiningInfo, callInfo)
	mock.lockMiningInfo.Unlock()
	return mock.MiningInfoFunc(ctx)
}

// MiningInfoCalls gets all the calls that were made to MiningInfo.
// Check the length with:
//     len(mockedMiningClient.MiningInfoCalls())
func (mock *MiningClientMock) MiningInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockMiningInfo.RLock()
	calls = mock.calls.MiningInfo
	mock.lockMiningInfo.RUnlock()
	return calls
}

// NetworkHashPS calls NetworkHashPSFunc.
func (mock *MiningClientMock) NetworkHashPS(ctx context.Context, opts *models.OptsNetworkHashPS) (uint64, error) {
	if mock.NetworkHashPSFunc == nil {
		panic("MiningClientMock.NetworkHashPSFunc: method is nil but MiningClient.NetworkHashPS was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsNetworkHashPS
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockNetworkHashPS.Lock()
	mock.calls.NetworkHashPS = append(mock.calls.NetworkHashPS, callInfo)
	mock.lockNetworkHashPS.Unlock()
	return mock.NetworkHashPSFunc(ctx, opts)
}

// NetworkHashPSCalls gets all the calls that were made to NetworkHashPS.
// Check the length with:
//     len(mockedMiningClient.NetworkHashPSCalls())
func (mock *MiningClientMock) NetworkHashPSCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsNetworkHashPS
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsNetworkHashPS
	}
	mock.lockNetworkHashPS.RLock()
	calls = mock.calls.NetworkHashPS
	mock.lockNetworkHashPS.RUnlock()
	return calls
}

// PrioritiseTx calls PrioritiseTxFunc.
func (mock *MiningClientMock) PrioritiseTx(ctx context.Context, txID string, feeDelta int64) (bool, error) {
	if mock.PrioritiseTxFunc == nil {
		panic("MiningClientMock.PrioritiseTxFunc: method is nil but MiningClient.PrioritiseTx was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		TxID     string
		FeeDelta int64
	}{
		Ctx:      ctx,
		TxID:     txID,
		FeeDelta: feeDelta,
	}
	mock.lockPrioritiseTx.Lock()
	mock.calls.PrioritiseTx = append(mock.calls.PrioritiseTx, callInfo)
	mock.lockPrioritiseTx.Unlock()
	return mock.PrioritiseTxFunc(ctx, txID, feeDelta)
}

// PrioritiseTxCalls gets all the calls that were made to PrioritiseTx.
// Check the length with:
//     len(mockedMiningClient.PrioritiseTxCalls())
func (mock *MiningClientMock) PrioritiseTxCalls() []struct {
	Ctx      context.Context
	TxID     string
	FeeDelta int64
} {
	var calls []struct {
		Ctx      context.Context
		TxID     string
		FeeDelta int64
	}
	mock.lockPrioritiseTx.RLock()
	calls = mock.calls.PrioritiseTx
	mock.lockPrioritiseTx.RUnlock()
	return calls
}

// SubmitBlock calls SubmitBlockFunc.
func (mock *MiningClientMock) SubmitBlock(ctx context.Context, block *bc.Block, params *models.OptsSubmitBlock) (string, error) {
	if mock.SubmitBlockFunc == nil {
		panic("MiningClientMock.SubmitBlockFunc: method is nil but MiningClient.SubmitBlock was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Block  *bc.Block
		Params *models.OptsSubmitBlock
	}{
		Ctx:    ctx,
		Block:  block,
		Params: params,
	}
	mock.lockSubmitBlock.Lock()
	mock.calls.SubmitBlock = append(mock.calls.SubmitBlock, callInfo)
	mock.lockSubmitBlock.Unlock()
	return mock.SubmitBlockFunc(ctx, block, params)
}

// SubmitBlockCalls gets all the calls that were made to SubmitBlock.
// Check the length with:
//     len(mockedMiningClient.SubmitBlockCalls())
func (mock *MiningClientMock) SubmitBlockCalls() []struct {
	Ctx    context.Context
	Block  *bc.Block
	Params *models.OptsSubmitBlock
} {
	var calls []struct {
		Ctx    context.Context
		Block  *bc.Block
		Params *models.OptsSubmitBlock
	}
	mock.lockSubmitBlock.RLock()
	calls = mock.calls.SubmitBlock
	mock.lockSubmitBlock.RUnlock()
	return calls
}

// SubmitMiningSolution calls SubmitMiningSolutionFunc.
func (mock *MiningClientMock) SubmitMiningSolution(ctx context.Context, solution *models.MiningSolution) (string, error) {
	if mock.SubmitMiningSolutionFunc == nil {
		panic("MiningClientMock.SubmitMiningSolutionFunc: method is nil but MiningClient.SubmitMiningSolution was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Solution *models.MiningSolution
	}{
		Ctx:      ctx,
		Solution: solution,
	}
	mock.lockSubmitMiningSolution.Lock()
	mock.calls.SubmitMiningSolution = append(mock.calls.SubmitMiningSolution, callInfo)
	mock.lockSubmitMiningSolution.Unlock()
	return mock.SubmitMiningSolutionFunc(ctx, solution)
}

// SubmitMiningSolutionCalls gets all the calls that were made to SubmitMiningSolution.
// Check the length with:
//     len(mockedMiningClient.SubmitMiningSolutionCalls())
func (mock *MiningClientMock) SubmitMiningSolutionCalls() []struct {
	Ctx      context.Context
	Solution *models.MiningSolution
} {
	var calls []struct {
		Ctx      context.Context
		Solution *models.MiningSolution
	}
	mock.lockSubmitMiningSolution.RLock()
	calls = mock.calls.SubmitMiningSolution
	mock.lockSubmitMiningSolution.RUnlock()
	return calls
}

// VerifyBlockCandidate calls VerifyBlockCandidateFunc.
func (mock *MiningClientMock) VerifyBlockCandidate(ctx context.Context, block *bc.Block, params *models.OptsSubmitBlock) (string, error) {
	if mock.VerifyBlockCandidateFunc == nil {
		panic("MiningClientMock.VerifyBlockCandidateFunc: method is nil but MiningClient.VerifyBlockCandidate was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Block  *bc.Block
		Params *models.OptsSubmitBlock
	}{
		Ctx:    ctx,
		Block:  block,
		Params: params,
	}
	mock.lockVerifyBlockCandidate.Lock()
	mock.calls.VerifyBlockCandidate = append(mock.calls.VerifyBlockCandidate, callInfo)
	mock.lockVerifyBlockCandidate.Unlock()
	return mock.VerifyBlockCandidateFunc(ctx, block, params)
}

// VerifyBlockCandidateCalls gets all the calls that were made to VerifyBlockCandidate.
// Check the length with:
//     len(mockedMiningClient.VerifyBlockCandidateCalls())
func (mock *MiningClientMock) VerifyBlockCandidateCalls() []struct {
	Ctx    context.Context
	Block  *bc.Block
	Params *models.OptsSubmitBlock
} {
	var calls []struct {
		Ctx    context.Context
		Block  *bc.Block
		Params *models.OptsSubmitBlock
	}
	mock.lockVerifyBlockCandidate.RLock()
	calls = mock.calls.VerifyBlockCandidate
	mock.lockVerifyBlockCandidate.RUnlock()
	return calls
}

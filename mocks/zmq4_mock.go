// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/go-zeromq/zmq4"
	"net"
	"sync"
)

// Ensure, that SocketMock does implement zmq4.Socket.
// If this is not the case, regenerate this file with moq.
var _ zmq4.Socket = &SocketMock{}

// SocketMock is a mock implementation of zmq4.Socket.
//
// 	func TestSomethingThatUsesSocket(t *testing.T) {
//
// 		// make and configure a mocked zmq4.Socket
// 		mockedSocket := &SocketMock{
// 			AddrFunc: func() net.Addr {
// 				panic("mock out the Addr method")
// 			},
// 			CloseFunc: func() error {
// 				panic("mock out the Close method")
// 			},
// 			DialFunc: func(ep string) error {
// 				panic("mock out the Dial method")
// 			},
// 			GetOptionFunc: func(name string) (interface{}, error) {
// 				panic("mock out the GetOption method")
// 			},
// 			ListenFunc: func(ep string) error {
// 				panic("mock out the Listen method")
// 			},
// 			RecvFunc: func() (zmq4.Msg, error) {
// 				panic("mock out the Recv method")
// 			},
// 			SendFunc: func(msg zmq4.Msg) error {
// 				panic("mock out the Send method")
// 			},
// 			SendMultiFunc: func(msg zmq4.Msg) error {
// 				panic("mock out the SendMulti method")
// 			},
// 			SetOptionFunc: func(name string, value interface{}) error {
// 				panic("mock out the SetOption method")
// 			},
// 			TypeFunc: func() zmq4.SocketType {
// 				panic("mock out the Type method")
// 			},
// 		}
//
// 		// use mockedSocket in code that requires zmq4.Socket
// 		// and then make assertions.
//
// 	}
type SocketMock struct {
	// AddrFunc mocks the Addr method.
	AddrFunc func() net.Addr

	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// DialFunc mocks the Dial method.
	DialFunc func(ep string) error

	// GetOptionFunc mocks the GetOption method.
	GetOptionFunc func(name string) (interface{}, error)

	// ListenFunc mocks the Listen method.
	ListenFunc func(ep string) error

	// RecvFunc mocks the Recv method.
	RecvFunc func() (zmq4.Msg, error)

	// SendFunc mocks the Send method.
	SendFunc func(msg zmq4.Msg) error

	// SendMultiFunc mocks the SendMulti method.
	SendMultiFunc func(msg zmq4.Msg) error

	// SetOptionFunc mocks the SetOption method.
	SetOptionFunc func(name string, value interface{}) error

	// TypeFunc mocks the Type method.
	TypeFunc func() zmq4.SocketType

	// calls tracks calls to the methods.
	calls struct {
		// Addr holds details about calls to the Addr method.
		Addr []struct {
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Dial holds details about calls to the Dial method.
		Dial []struct {
			// Ep is the ep argument value.
			Ep string
		}
		// GetOption holds details about calls to the GetOption method.
		GetOption []struct {
			// Name is the name argument value.
			Name string
		}
		// Listen holds details about calls to the Listen method.
		Listen []struct {
			// Ep is the ep argument value.
			Ep string
		}
		// Recv holds details about calls to the Recv method.
		Recv []struct {
		}
		// Send holds details about calls to the Send method.
		Send []struct {
			// Msg is the msg argument value.
			Msg zmq4.Msg
		}
		// SendMulti holds details about calls to the SendMulti method.
		SendMulti []struct {
			// Msg is the msg argument value.
			Msg zmq4.Msg
		}
		// SetOption holds details about calls to the SetOption method.
		SetOption []struct {
			// Name is the name argument value.
			Name string
			// Value is the value argument value.
			Value interface{}
		}
		// Type holds details about calls to the Type method.
		Type []struct {
		}
	}
	lockAddr      sync.RWMutex
	lockClose     sync.RWMutex
	lockDial      sync.RWMutex
	lockGetOption sync.RWMutex
	lockListen    sync.RWMutex
	lockRecv      sync.RWMutex
	lockSend      sync.RWMutex
	lockSendMulti sync.RWMutex
	lockSetOption sync.RWMutex
	lockType      sync.RWMutex
}

// Addr calls AddrFunc.
func (mock *SocketMock) Addr() net.Addr {
	if mock.AddrFunc == nil {
		panic("SocketMock.AddrFunc: method is nil but Socket.Addr was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAddr.Lock()
	mock.calls.Addr = append(mock.calls.Addr, callInfo)
	mock.lockAddr.Unlock()
	return mock.AddrFunc()
}

// AddrCalls gets all the calls that were made to Addr.
// Check the length with:
//     len(mockedSocket.AddrCalls())
func (mock *SocketMock) AddrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAddr.RLock()
	calls = mock.calls.Addr
	mock.lockAddr.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *SocketMock) Close() error {
	if mock.CloseFunc == nil {
		panic("SocketMock.CloseFunc: method is nil but Socket.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedSocket.CloseCalls())
func (mock *SocketMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Dial calls DialFunc.
func (mock *SocketMock) Dial(ep string) error {
	if mock.DialFunc == nil {
		panic("SocketMock.DialFunc: method is nil but Socket.Dial was just called")
	}
	callInfo := struct {
		Ep string
	}{
		Ep: ep,
	}
	mock.lockDial.Lock()
	mock.calls.Dial = append(mock.calls.Dial, callInfo)
	mock.lockDial.Unlock()
	return mock.DialFunc(ep)
}

// DialCalls gets all the calls that were made to Dial.
// Check the length with:
//     len(mockedSocket.DialCalls())
func (mock *SocketMock) DialCalls() []struct {
	Ep string
} {
	var calls []struct {
		Ep string
	}
	mock.lockDial.RLock()
	calls = mock.calls.Dial
	mock.lockDial.RUnlock()
	return calls
}

// GetOption calls GetOptionFunc.
func (mock *SocketMock) GetOption(name string) (interface{}, error) {
	if mock.GetOptionFunc == nil {
		panic("SocketMock.GetOptionFunc: method is nil but Socket.GetOption was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockGetOption.Lock()
	mock.calls.GetOption = append(mock.calls.GetOption, callInfo)
	mock.lockGetOption.Unlock()
	return mock.GetOptionFunc(name)
}

// GetOptionCalls gets all the calls that were made to GetOption.
// Check the length with:
//     len(mockedSocket.GetOptionCalls())
func (mock *SocketMock) GetOptionCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockGetOption.RLock()
	calls = mock.calls.GetOption
	mock.lockGetOption.RUnlock()
	return calls
}

// Listen calls ListenFunc.
func (mock *SocketMock) Listen(ep string) error {
	if mock.ListenFunc == nil {
		panic("SocketMock.ListenFunc: method is nil but Socket.Listen was just called")
	}
	callInfo := struct {
		Ep string
	}{
		Ep: ep,
	}
	mock.lockListen.Lock()
	mock.calls.Listen = append(mock.calls.Listen, callInfo)
	mock.lockListen.Unlock()
	return mock.ListenFunc(ep)
}

// ListenCalls gets all the calls that were made to Listen.
// Check the length with:
//     len(mockedSocket.ListenCalls())
func (mock *SocketMock) ListenCalls() []struct {
	Ep string
} {
	var calls []struct {
		Ep string
	}
	mock.lockListen.RLock()
	calls = mock.calls.Listen
	mock.lockListen.RUnlock()
	return calls
}

// Recv calls RecvFunc.
func (mock *SocketMock) Recv() (zmq4.Msg, error) {
	if mock.RecvFunc == nil {
		panic("SocketMock.RecvFunc: method is nil but Socket.Recv was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRecv.Lock()
	mock.calls.Recv = append(mock.calls.Recv, callInfo)
	mock.lockRecv.Unlock()
	return mock.RecvFunc()
}

// RecvCalls gets all the calls that were made to Recv.
// Check the length with:
//     len(mockedSocket.RecvCalls())
func (mock *SocketMock) RecvCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRecv.RLock()
	calls = mock.calls.Recv
	mock.lockRecv.RUnlock()
	return calls
}

// Send calls SendFunc.
func (mock *SocketMock) Send(msg zmq4.Msg) error {
	if mock.SendFunc == nil {
		panic("SocketMock.SendFunc: method is nil but Socket.Send was just called")
	}
	callInfo := struct {
		Msg zmq4.Msg
	}{
		Msg: msg,
	}
	mock.lockSend.Lock()
	mock.calls.Send = append(mock.calls.Send, callInfo)
	mock.lockSend.Unlock()
	return mock.SendFunc(msg)
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//     len(mockedSocket.SendCalls())
func (mock *SocketMock) SendCalls() []struct {
	Msg zmq4.Msg
} {
	var calls []struct {
		Msg zmq4.Msg
	}
	mock.lockSend.RLock()
	calls = mock.calls.Send
	mock.lockSend.RUnlock()
	return calls
}

// SendMulti calls SendMultiFunc.
func (mock *SocketMock) SendMulti(msg zmq4.Msg) error {
	if mock.SendMultiFunc == nil {
		panic("SocketMock.SendMultiFunc: method is nil but Socket.SendMulti was just called")
	}
	callInfo := struct {
		Msg zmq4.Msg
	}{
		Msg: msg,
	}
	mock.lockSendMulti.Lock()
	mock.calls.SendMulti = append(mock.calls.SendMulti, callInfo)
	mock.lockSendMulti.Unlock()
	return mock.SendMultiFunc(msg)
}

// SendMultiCalls gets all the calls that were made to SendMulti.
// Check the length with:
//     len(mockedSocket.SendMultiCalls())
func (mock *SocketMock) SendMultiCalls() []struct {
	Msg zmq4.Msg
} {
	var calls []struct {
		Msg zmq4.Msg
	}
	mock.lockSendMulti.RLock()
	calls = mock.calls.SendMulti
	mock.lockSendMulti.RUnlock()
	return calls
}

// SetOption calls SetOptionFunc.
func (mock *SocketMock) SetOption(name string, value interface{}) error {
	if mock.SetOptionFunc == nil {
		panic("SocketMock.SetOptionFunc: method is nil but Socket.SetOption was just called")
	}
	callInfo := struct {
		Name  string
		Value interface{}
	}{
		Name:  name,
		Value: value,
	}
	mock.lockSetOption.Lock()
	mock.calls.SetOption = append(mock.calls.SetOption, callInfo)
	mock.lockSetOption.Unlock()
	return mock.SetOptionFunc(name, value)
}

// SetOptionCalls gets all the calls that were made to SetOption.
// Check the length with:
//     len(mockedSocket.SetOptionCalls())
func (mock *SocketMock) SetOptionCalls() []struct {
	Name  string
	Value interface{}
} {
	var calls []struct {
		Name  string
		Value interface{}
	}
	mock.lockSetOption.RLock()
	calls = mock.calls.SetOption
	mock.lockSetOption.RUnlock()
	return calls
}

// Type calls TypeFunc.
func (mock *SocketMock) Type() zmq4.SocketType {
	if mock.TypeFunc == nil {
		panic("SocketMock.TypeFunc: method is nil but Socket.Type was just called")
	}
	callInfo := struct {
	}{}
	mock.lockType.Lock()
	mock.calls.Type = append(mock.calls.Type, callInfo)
	mock.lockType.Unlock()
	return mock.TypeFunc()
}

// TypeCalls gets all the calls that were made to Type.
// Check the length with:
//     len(mockedSocket.TypeCalls())
func (mock *SocketMock) TypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockType.RLock()
	calls = mock.calls.Type
	mock.lockType.RUnlock()
	return calls
}

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/libsv/go-bk/wif"
	"github.com/libsv/go-bn"
	"github.com/libsv/go-bn/models"
	"sync"
)

// Ensure, that UtilClientMock does implement bn.UtilClient.
// If this is not the case, regenerate this file with moq.
var _ bn.UtilClient = &UtilClientMock{}

// UtilClientMock is a mock implementation of bn.UtilClient.
//
// 	func TestSomethingThatUsesUtilClient(t *testing.T) {
//
// 		// make and configure a mocked bn.UtilClient
// 		mockedUtilClient := &UtilClientMock{
// 			ClearInvalidTransactionsFunc: func(ctx context.Context) (uint64, error) {
// 				panic("mock out the ClearInvalidTransactions method")
// 			},
// 			CreateMultiSigFunc: func(ctx context.Context, n int, keys ...string) (*models.MultiSig, error) {
// 				panic("mock out the CreateMultiSig method")
// 			},
// 			SignMessageWithPrivKeyFunc: func(ctx context.Context, w *wif.WIF, msg string) (string, error) {
// 				panic("mock out the SignMessageWithPrivKey method")
// 			},
// 			ValidateAddressFunc: func(ctx context.Context, address string) (*models.ValidateAddress, error) {
// 				panic("mock out the ValidateAddress method")
// 			},
// 			VerifySignedMessageFunc: func(ctx context.Context, w *wif.WIF, signature string, message string) (bool, error) {
// 				panic("mock out the VerifySignedMessage method")
// 			},
// 		}
//
// 		// use mockedUtilClient in code that requires bn.UtilClient
// 		// and then make assertions.
//
// 	}
type UtilClientMock struct {
	// ClearInvalidTransactionsFunc mocks the ClearInvalidTransactions method.
	ClearInvalidTransactionsFunc func(ctx context.Context) (uint64, error)

	// CreateMultiSigFunc mocks the CreateMultiSig method.
	CreateMultiSigFunc func(ctx context.Context, n int, keys ...string) (*models.MultiSig, error)

	// SignMessageWithPrivKeyFunc mocks the SignMessageWithPrivKey method.
	SignMessageWithPrivKeyFunc func(ctx context.Context, w *wif.WIF, msg string) (string, error)

	// ValidateAddressFunc mocks the ValidateAddress method.
	ValidateAddressFunc func(ctx context.Context, address string) (*models.ValidateAddress, error)

	// VerifySignedMessageFunc mocks the VerifySignedMessage method.
	VerifySignedMessageFunc func(ctx context.Context, w *wif.WIF, signature string, message string) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// ClearInvalidTransactions holds details about calls to the ClearInvalidTransactions method.
		ClearInvalidTransactions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CreateMultiSig holds details about calls to the CreateMultiSig method.
		CreateMultiSig []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// N is the n argument value.
			N int
			// Keys is the keys argument value.
			Keys []string
		}
		// SignMessageWithPrivKey holds details about calls to the SignMessageWithPrivKey method.
		SignMessageWithPrivKey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// W is the w argument value.
			W *wif.WIF
			// Msg is the msg argument value.
			Msg string
		}
		// ValidateAddress holds details about calls to the ValidateAddress method.
		ValidateAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
		}
		// VerifySignedMessage holds details about calls to the VerifySignedMessage method.
		VerifySignedMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// W is the w argument value.
			W *wif.WIF
			// Signature is the signature argument value.
			Signature string
			// Message is the message argument value.
			Message string
		}
	}
	lockClearInvalidTransactions sync.RWMutex
	lockCreateMultiSig           sync.RWMutex
	lockSignMessageWithPrivKey   sync.RWMutex
	lockValidateAddress          sync.RWMutex
	lockVerifySignedMessage      sync.RWMutex
}

// ClearInvalidTransactions calls ClearInvalidTransactionsFunc.
func (mock *UtilClientMock) ClearInvalidTransactions(ctx context.Context) (uint64, error) {
	if mock.ClearInvalidTransactionsFunc == nil {
		panic("UtilClientMock.ClearInvalidTransactionsFunc: method is nil but UtilClient.ClearInvalidTransactions was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClearInvalidTransactions.Lock()
	mock.calls.ClearInvalidTransactions = append(mock.calls.ClearInvalidTransactions, callInfo)
	mock.lockClearInvalidTransactions.Unlock()
	return mock.ClearInvalidTransactionsFunc(ctx)
}

// ClearInvalidTransactionsCalls gets all the calls that were made to ClearInvalidTransactions.
// Check the length with:
//     len(mockedUtilClient.ClearInvalidTransactionsCalls())
func (mock *UtilClientMock) ClearInvalidTransactionsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClearInvalidTransactions.RLock()
	calls = mock.calls.ClearInvalidTransactions
	mock.lockClearInvalidTransactions.RUnlock()
	return calls
}

// CreateMultiSig calls CreateMultiSigFunc.
func (mock *UtilClientMock) CreateMultiSig(ctx context.Context, n int, keys ...string) (*models.MultiSig, error) {
	if mock.CreateMultiSigFunc == nil {
		panic("UtilClientMock.CreateMultiSigFunc: method is nil but UtilClient.CreateMultiSig was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		N    int
		Keys []string
	}{
		Ctx:  ctx,
		N:    n,
		Keys: keys,
	}
	mock.lockCreateMultiSig.Lock()
	mock.calls.CreateMultiSig = append(mock.calls.CreateMultiSig, callInfo)
	mock.lockCreateMultiSig.Unlock()
	return mock.CreateMultiSigFunc(ctx, n, keys...)
}

// CreateMultiSigCalls gets all the calls that were made to CreateMultiSig.
// Check the length with:
//     len(mockedUtilClient.CreateMultiSigCalls())
func (mock *UtilClientMock) CreateMultiSigCalls() []struct {
	Ctx  context.Context
	N    int
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		N    int
		Keys []string
	}
	mock.lockCreateMultiSig.RLock()
	calls = mock.calls.CreateMultiSig
	mock.lockCreateMultiSig.RUnlock()
	return calls
}

// SignMessageWithPrivKey calls SignMessageWithPrivKeyFunc.
func (mock *UtilClientMock) SignMessageWithPrivKey(ctx context.Context, w *wif.WIF, msg string) (string, error) {
	if mock.SignMessageWithPrivKeyFunc == nil {
		panic("UtilClientMock.SignMessageWithPrivKeyFunc: method is nil but UtilClient.SignMessageWithPrivKey was just called")
	}
	callInfo := struct {
		Ctx context.Context
		W   *wif.WIF
		Msg string
	}{
		Ctx: ctx,
		W:   w,
		Msg: msg,
	}
	mock.lockSignMessageWithPrivKey.Lock()
	mock.calls.SignMessageWithPrivKey = append(mock.calls.SignMessageWithPrivKey, callInfo)
	mock.lockSignMessageWithPrivKey.Unlock()
	return mock.SignMessageWithPrivKeyFunc(ctx, w, msg)
}

// SignMessageWithPrivKeyCalls gets all the calls that were made to SignMessageWithPrivKey.
// Check the length with:
//     len(mockedUtilClient.SignMessageWithPrivKeyCalls())
func (mock *UtilClientMock) SignMessageWithPrivKeyCalls() []struct {
	Ctx context.Context
	W   *wif.WIF
	Msg string
} {
	var calls []struct {
		Ctx context.Context
		W   *wif.WIF
		Msg string
	}
	mock.lockSignMessageWithPrivKey.RLock()
	calls = mock.calls.SignMessageWithPrivKey
	mock.lockSignMessageWithPrivKey.RUnlock()
	return calls
}

// ValidateAddress calls ValidateAddressFunc.
func (mock *UtilClientMock) ValidateAddress(ctx context.Context, address string) (*models.ValidateAddress, error) {
	if mock.ValidateAddressFunc == nil {
		panic("UtilClientMock.ValidateAddressFunc: method is nil but UtilClient.ValidateAddress was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockValidateAddress.Lock()
	mock.calls.ValidateAddress = append(mock.calls.ValidateAddress, callInfo)
	mock.lockValidateAddress.Unlock()
	return mock.ValidateAddressFunc(ctx, address)
}

// ValidateAddressCalls gets all the calls that were made to ValidateAddress.
// Check the length with:
//     len(mockedUtilClient.ValidateAddressCalls())
func (mock *UtilClientMock) ValidateAddressCalls() []struct {
	Ctx     context.Context
	Address string
} {
	var calls []struct {
		Ctx     context.Context
		Address string
	}
	mock.lockValidateAddress.RLock()
	calls = mock.calls.ValidateAddress
	mock.lockValidateAddress.RUnlock()
	return calls
}

// VerifySignedMessage calls VerifySignedMessageFunc.
func (mock *UtilClientMock) VerifySignedMessage(ctx context.Context, w *wif.WIF, signature string, message string) (bool, error) {
	if mock.VerifySignedMessageFunc == nil {
		panic("UtilClientMock.VerifySignedMessageFunc: method is nil but UtilClient.VerifySignedMessage was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		W         *wif.WIF
		Signature string
		Message   string
	}{
		Ctx:       ctx,
		W:         w,
		Signature: signature,
		Message:   message,
	}
	mock.lockVerifySignedMessage.Lock()
	mock.calls.VerifySignedMessage = append(mock.calls.VerifySignedMessage, callInfo)
	mock.lockVerifySignedMessage.Unlock()
	return mock.VerifySignedMessageFunc(ctx, w, signature, message)
}

// VerifySignedMessageCalls gets all the calls that were made to VerifySignedMessage.
// Check the length with:
//     len(mockedUtilClient.VerifySignedMessageCalls())
func (mock *UtilClientMock) VerifySignedMessageCalls() []struct {
	Ctx       context.Context
	W         *wif.WIF
	Signature string
	Message   string
} {
	var calls []struct {
		Ctx       context.Context
		W         *wif.WIF
		Signature string
		Message   string
	}
	mock.lockVerifySignedMessage.RLock()
	calls = mock.calls.VerifySignedMessage
	mock.lockVerifySignedMessage.RUnlock()
	return calls
}

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/libsv/go-bc"
	"github.com/libsv/go-bn"
	"github.com/libsv/go-bn/models"
	"sync"
)

// Ensure, that BlockChainClientMock does implement bn.BlockChainClient.
// If this is not the case, regenerate this file with moq.
var _ bn.BlockChainClient = &BlockChainClientMock{}

// BlockChainClientMock is a mock implementation of bn.BlockChainClient.
//
// 	func TestSomethingThatUsesBlockChainClient(t *testing.T) {
//
// 		// make and configure a mocked bn.BlockChainClient
// 		mockedBlockChainClient := &BlockChainClientMock{
// 			BestBlockHashFunc: func(ctx context.Context) (string, error) {
// 				panic("mock out the BestBlockHash method")
// 			},
// 			BlockFunc: func(ctx context.Context, hash string) (*models.Block, error) {
// 				panic("mock out the Block method")
// 			},
// 			BlockByHeightFunc: func(ctx context.Context, height int) (*models.Block, error) {
// 				panic("mock out the BlockByHeight method")
// 			},
// 			BlockCountFunc: func(ctx context.Context) (uint32, error) {
// 				panic("mock out the BlockCount method")
// 			},
// 			BlockDecodeHeaderFunc: func(ctx context.Context, hash string) (*models.BlockDecodeHeader, error) {
// 				panic("mock out the BlockDecodeHeader method")
// 			},
// 			BlockDecodeHeaderByHeightFunc: func(ctx context.Context, height int) (*models.BlockDecodeHeader, error) {
// 				panic("mock out the BlockDecodeHeaderByHeight method")
// 			},
// 			BlockHashFunc: func(ctx context.Context, height int) (string, error) {
// 				panic("mock out the BlockHash method")
// 			},
// 			BlockHeaderFunc: func(ctx context.Context, hash string) (*models.BlockHeader, error) {
// 				panic("mock out the BlockHeader method")
// 			},
// 			BlockHeaderHexFunc: func(ctx context.Context, hash string) (string, error) {
// 				panic("mock out the BlockHeaderHex method")
// 			},
// 			BlockHexFunc: func(ctx context.Context, hash string) (string, error) {
// 				panic("mock out the BlockHex method")
// 			},
// 			BlockHexByHeightFunc: func(ctx context.Context, height int) (string, error) {
// 				panic("mock out the BlockHexByHeight method")
// 			},
// 			BlockStatsFunc: func(ctx context.Context, hash string, fields ...string) (*models.BlockStats, error) {
// 				panic("mock out the BlockStats method")
// 			},
// 			BlockStatsByHeightFunc: func(ctx context.Context, height int, fields ...string) (*models.BlockStats, error) {
// 				panic("mock out the BlockStatsByHeight method")
// 			},
// 			ChainInfoFunc: func(ctx context.Context) (*models.ChainInfo, error) {
// 				panic("mock out the ChainInfo method")
// 			},
// 			ChainTipsFunc: func(ctx context.Context) ([]*models.ChainTip, error) {
// 				panic("mock out the ChainTips method")
// 			},
// 			ChainTxStatsFunc: func(ctx context.Context, opts *models.OptsChainTxStats) (*models.ChainTxStats, error) {
// 				panic("mock out the ChainTxStats method")
// 			},
// 			CheckJournalFunc: func(ctx context.Context) (*models.JournalStatus, error) {
// 				panic("mock out the CheckJournal method")
// 			},
// 			DifficultyFunc: func(ctx context.Context) (float64, error) {
// 				panic("mock out the Difficulty method")
// 			},
// 			GenerateFunc: func(ctx context.Context, n int, opts *models.OptsGenerate) ([]string, error) {
// 				panic("mock out the Generate method")
// 			},
// 			GenerateToAddressFunc: func(ctx context.Context, n int, addr string, opts *models.OptsGenerate) ([]string, error) {
// 				panic("mock out the GenerateToAddress method")
// 			},
// 			LegacyMerkleProofFunc: func(ctx context.Context, txID string, opts *models.OptsLegacyMerkleProof) (*models.LegacyMerkleProof, error) {
// 				panic("mock out the LegacyMerkleProof method")
// 			},
// 			MempoolAncestorIDsFunc: func(ctx context.Context, txID string) ([]string, error) {
// 				panic("mock out the MempoolAncestorIDs method")
// 			},
// 			MempoolAncestorsFunc: func(ctx context.Context, txID string) (models.MempoolTxs, error) {
// 				panic("mock out the MempoolAncestors method")
// 			},
// 			MempoolDescendantIDsFunc: func(ctx context.Context, txID string) ([]string, error) {
// 				panic("mock out the MempoolDescendantIDs method")
// 			},
// 			MempoolDescendantsFunc: func(ctx context.Context, txID string) (models.MempoolTxs, error) {
// 				panic("mock out the MempoolDescendants method")
// 			},
// 			MempoolEntryFunc: func(ctx context.Context, txID string) (*models.MempoolEntry, error) {
// 				panic("mock out the MempoolEntry method")
// 			},
// 			MerkleProofFunc: func(ctx context.Context, blockHash string, txID string, opts *models.OptsMerkleProof) (*bc.MerkleProof, error) {
// 				panic("mock out the MerkleProof method")
// 			},
// 			OutputFunc: func(ctx context.Context, txID string, n int, opts *models.OptsOutput) (*models.Output, error) {
// 				panic("mock out the Output method")
// 			},
// 			OutputSetInfoFunc: func(ctx context.Context) (*models.OutputSetInfo, error) {
// 				panic("mock out the OutputSetInfo method")
// 			},
// 			PreciousBlockFunc: func(ctx context.Context, blockHash string) error {
// 				panic("mock out the PreciousBlock method")
// 			},
// 			PruneChainFunc: func(ctx context.Context, height int) (uint32, error) {
// 				panic("mock out the PruneChain method")
// 			},
// 			RawMempoolFunc: func(ctx context.Context) (models.MempoolTxs, error) {
// 				panic("mock out the RawMempool method")
// 			},
// 			RawMempoolIDsFunc: func(ctx context.Context) ([]string, error) {
// 				panic("mock out the RawMempoolIDs method")
// 			},
// 			RawNonFinalMempoolFunc: func(ctx context.Context) ([]string, error) {
// 				panic("mock out the RawNonFinalMempool method")
// 			},
// 			RebuildJournalFunc: func(ctx context.Context) error {
// 				panic("mock out the RebuildJournal method")
// 			},
// 			VerifyChainFunc: func(ctx context.Context) (bool, error) {
// 				panic("mock out the VerifyChain method")
// 			},
// 		}
//
// 		// use mockedBlockChainClient in code that requires bn.BlockChainClient
// 		// and then make assertions.
//
// 	}
type BlockChainClientMock struct {
	// BestBlockHashFunc mocks the BestBlockHash method.
	BestBlockHashFunc func(ctx context.Context) (string, error)

	// BlockFunc mocks the Block method.
	BlockFunc func(ctx context.Context, hash string) (*models.Block, error)

	// BlockByHeightFunc mocks the BlockByHeight method.
	BlockByHeightFunc func(ctx context.Context, height int) (*models.Block, error)

	// BlockCountFunc mocks the BlockCount method.
	BlockCountFunc func(ctx context.Context) (uint32, error)

	// BlockDecodeHeaderFunc mocks the BlockDecodeHeader method.
	BlockDecodeHeaderFunc func(ctx context.Context, hash string) (*models.BlockDecodeHeader, error)

	// BlockDecodeHeaderByHeightFunc mocks the BlockDecodeHeaderByHeight method.
	BlockDecodeHeaderByHeightFunc func(ctx context.Context, height int) (*models.BlockDecodeHeader, error)

	// BlockHashFunc mocks the BlockHash method.
	BlockHashFunc func(ctx context.Context, height int) (string, error)

	// BlockHeaderFunc mocks the BlockHeader method.
	BlockHeaderFunc func(ctx context.Context, hash string) (*models.BlockHeader, error)

	// BlockHeaderHexFunc mocks the BlockHeaderHex method.
	BlockHeaderHexFunc func(ctx context.Context, hash string) (string, error)

	// BlockHexFunc mocks the BlockHex method.
	BlockHexFunc func(ctx context.Context, hash string) (string, error)

	// BlockHexByHeightFunc mocks the BlockHexByHeight method.
	BlockHexByHeightFunc func(ctx context.Context, height int) (string, error)

	// BlockStatsFunc mocks the BlockStats method.
	BlockStatsFunc func(ctx context.Context, hash string, fields ...string) (*models.BlockStats, error)

	// BlockStatsByHeightFunc mocks the BlockStatsByHeight method.
	BlockStatsByHeightFunc func(ctx context.Context, height int, fields ...string) (*models.BlockStats, error)

	// ChainInfoFunc mocks the ChainInfo method.
	ChainInfoFunc func(ctx context.Context) (*models.ChainInfo, error)

	// ChainTipsFunc mocks the ChainTips method.
	ChainTipsFunc func(ctx context.Context) ([]*models.ChainTip, error)

	// ChainTxStatsFunc mocks the ChainTxStats method.
	ChainTxStatsFunc func(ctx context.Context, opts *models.OptsChainTxStats) (*models.ChainTxStats, error)

	// CheckJournalFunc mocks the CheckJournal method.
	CheckJournalFunc func(ctx context.Context) (*models.JournalStatus, error)

	// DifficultyFunc mocks the Difficulty method.
	DifficultyFunc func(ctx context.Context) (float64, error)

	// GenerateFunc mocks the Generate method.
	GenerateFunc func(ctx context.Context, n int, opts *models.OptsGenerate) ([]string, error)

	// GenerateToAddressFunc mocks the GenerateToAddress method.
	GenerateToAddressFunc func(ctx context.Context, n int, addr string, opts *models.OptsGenerate) ([]string, error)

	// LegacyMerkleProofFunc mocks the LegacyMerkleProof method.
	LegacyMerkleProofFunc func(ctx context.Context, txID string, opts *models.OptsLegacyMerkleProof) (*models.LegacyMerkleProof, error)

	// MempoolAncestorIDsFunc mocks the MempoolAncestorIDs method.
	MempoolAncestorIDsFunc func(ctx context.Context, txID string) ([]string, error)

	// MempoolAncestorsFunc mocks the MempoolAncestors method.
	MempoolAncestorsFunc func(ctx context.Context, txID string) (models.MempoolTxs, error)

	// MempoolDescendantIDsFunc mocks the MempoolDescendantIDs method.
	MempoolDescendantIDsFunc func(ctx context.Context, txID string) ([]string, error)

	// MempoolDescendantsFunc mocks the MempoolDescendants method.
	MempoolDescendantsFunc func(ctx context.Context, txID string) (models.MempoolTxs, error)

	// MempoolEntryFunc mocks the MempoolEntry method.
	MempoolEntryFunc func(ctx context.Context, txID string) (*models.MempoolEntry, error)

	// MerkleProofFunc mocks the MerkleProof method.
	MerkleProofFunc func(ctx context.Context, blockHash string, txID string, opts *models.OptsMerkleProof) (*bc.MerkleProof, error)

	// OutputFunc mocks the Output method.
	OutputFunc func(ctx context.Context, txID string, n int, opts *models.OptsOutput) (*models.Output, error)

	// OutputSetInfoFunc mocks the OutputSetInfo method.
	OutputSetInfoFunc func(ctx context.Context) (*models.OutputSetInfo, error)

	// PreciousBlockFunc mocks the PreciousBlock method.
	PreciousBlockFunc func(ctx context.Context, blockHash string) error

	// PruneChainFunc mocks the PruneChain method.
	PruneChainFunc func(ctx context.Context, height int) (uint32, error)

	// RawMempoolFunc mocks the RawMempool method.
	RawMempoolFunc func(ctx context.Context) (models.MempoolTxs, error)

	// RawMempoolIDsFunc mocks the RawMempoolIDs method.
	RawMempoolIDsFunc func(ctx context.Context) ([]string, error)

	// RawNonFinalMempoolFunc mocks the RawNonFinalMempool method.
	RawNonFinalMempoolFunc func(ctx context.Context) ([]string, error)

	// RebuildJournalFunc mocks the RebuildJournal method.
	RebuildJournalFunc func(ctx context.Context) error

	// VerifyChainFunc mocks the VerifyChain method.
	VerifyChainFunc func(ctx context.Context) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// BestBlockHash holds details about calls to the BestBlockHash method.
		BestBlockHash []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Block holds details about calls to the Block method.
		Block []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash string
		}
		// BlockByHeight holds details about calls to the BlockByHeight method.
		BlockByHeight []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height int
		}
		// BlockCount holds details about calls to the BlockCount method.
		BlockCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// BlockDecodeHeader holds details about calls to the BlockDecodeHeader method.
		BlockDecodeHeader []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash string
		}
		// BlockDecodeHeaderByHeight holds details about calls to the BlockDecodeHeaderByHeight method.
		BlockDecodeHeaderByHeight []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height int
		}
		// BlockHash holds details about calls to the BlockHash method.
		BlockHash []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height int
		}
		// BlockHeader holds details about calls to the BlockHeader method.
		BlockHeader []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash string
		}
		// BlockHeaderHex holds details about calls to the BlockHeaderHex method.
		BlockHeaderHex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash string
		}
		// BlockHex holds details about calls to the BlockHex method.
		BlockHex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash string
		}
		// BlockHexByHeight holds details about calls to the BlockHexByHeight method.
		BlockHexByHeight []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height int
		}
		// BlockStats holds details about calls to the BlockStats method.
		BlockStats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash string
			// Fields is the fields argument value.
			Fields []string
		}
		// BlockStatsByHeight holds details about calls to the BlockStatsByHeight method.
		BlockStatsByHeight []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height int
			// Fields is the fields argument value.
			Fields []string
		}
		// ChainInfo holds details about calls to the ChainInfo method.
		ChainInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ChainTips holds details about calls to the ChainTips method.
		ChainTips []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ChainTxStats holds details about calls to the ChainTxStats method.
		ChainTxStats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsChainTxStats
		}
		// CheckJournal holds details about calls to the CheckJournal method.
		CheckJournal []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Difficulty holds details about calls to the Difficulty method.
		Difficulty []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Generate holds details about calls to the Generate method.
		Generate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// N is the n argument value.
			N int
			// Opts is the opts argument value.
			Opts *models.OptsGenerate
		}
		// GenerateToAddress holds details about calls to the GenerateToAddress method.
		GenerateToAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// N is the n argument value.
			N int
			// Addr is the addr argument value.
			Addr string
			// Opts is the opts argument value.
			Opts *models.OptsGenerate
		}
		// LegacyMerkleProof holds details about calls to the LegacyMerkleProof method.
		LegacyMerkleProof []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
			// Opts is the opts argument value.
			Opts *models.OptsLegacyMerkleProof
		}
		// MempoolAncestorIDs holds details about calls to the MempoolAncestorIDs method.
		MempoolAncestorIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// MempoolAncestors holds details about calls to the MempoolAncestors method.
		MempoolAncestors []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// MempoolDescendantIDs holds details about calls to the MempoolDescendantIDs method.
		MempoolDescendantIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// MempoolDescendants holds details about calls to the MempoolDescendants method.
		MempoolDescendants []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// MempoolEntry holds details about calls to the MempoolEntry method.
		MempoolEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// MerkleProof holds details about calls to the MerkleProof method.
		MerkleProof []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BlockHash is the blockHash argument value.
			BlockHash string
			// TxID is the txID argument value.
			TxID string
			// Opts is the opts argument value.
			Opts *models.OptsMerkleProof
		}
		// Output holds details about calls to the Output method.
		Output []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
			// N is the n argument value.
			N int
			// Opts is the opts argument value.
			Opts *models.OptsOutput
		}
		// OutputSetInfo holds details about calls to the OutputSetInfo method.
		OutputSetInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// PreciousBlock holds details about calls to the PreciousBlock method.
		PreciousBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BlockHash is the blockHash argument value.
			BlockHash string
		}
		// PruneChain holds details about calls to the PruneChain method.
		PruneChain []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height int
		}
		// RawMempool holds details about calls to the RawMempool method.
		RawMempool []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// RawMempoolIDs holds details about calls to the RawMempoolIDs method.
		RawMempoolIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// RawNonFinalMempool holds details about calls to the RawNonFinalMempool method.
		RawNonFinalMempool []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// RebuildJournal holds details about calls to the RebuildJournal method.
		RebuildJournal []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// VerifyChain holds details about calls to the VerifyChain method.
		VerifyChain []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockBestBlockHash             sync.RWMutex
	lockBlock                     sync.RWMutex
	lockBlockByHeight             sync.RWMutex
	lockBlockCount                sync.RWMutex
	lockBlockDecodeHeader         sync.RWMutex
	lockBlockDecodeHeaderByHeight sync.RWMutex
	lockBlockHash                 sync.RWMutex
	lockBlockHeader               sync.RWMutex
	lockBlockHeaderHex            sync.RWMutex
	lockBlockHex                  sync.RWMutex
	lockBlockHexByHeight          sync.RWMutex
	lockBlockStats                sync.RWMutex
	lockBlockStatsByHeight        sync.RWMutex
	lockChainInfo                 sync.RWMutex
	lockChainTips                 sync.RWMutex
	lockChainTxStats              sync.RWMutex
	lockCheckJournal              sync.RWMutex
	lockDifficulty                sync.RWMutex
	lockGenerate                  sync.RWMutex
	lockGenerateToAddress         sync.RWMutex
	lockLegacyMerkleProof         sync.RWMutex
	lockMempoolAncestorIDs        sync.RWMutex
	lockMempoolAncestors          sync.RWMutex
	lockMempoolDescendantIDs      sync.RWMutex
	lockMempoolDescendants        sync.RWMutex
	lockMempoolEntry              sync.RWMutex
	lockMerkleProof               sync.RWMutex
	lockOutput                    sync.RWMutex
	lockOutputSetInfo             sync.RWMutex
	lockPreciousBlock             sync.RWMutex
	lockPruneChain                sync.RWMutex
	lockRawMempool                sync.RWMutex
	lockRawMempoolIDs             sync.RWMutex
	lockRawNonFinalMempool        sync.RWMutex
	lockRebuildJournal            sync.RWMutex
	lockVerifyChain               sync.RWMutex
}

// BestBlockHash calls BestBlockHashFunc.
func (mock *BlockChainClientMock) BestBlockHash(ctx context.Context) (string, error) {
	if mock.BestBlockHashFunc == nil {
		panic("BlockChainClientMock.BestBlockHashFunc: method is nil but BlockChainClient.BestBlockHash was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockBestBlockHash.Lock()
	mock.calls.BestBlockHash = append(mock.calls.BestBlockHash, callInfo)
	mock.lockBestBlockHash.Unlock()
	return mock.BestBlockHashFunc(ctx)
}

// BestBlockHashCalls gets all the calls that were made to BestBlockHash.
// Check the length with:
//     len(mockedBlockChainClient.BestBlockHashCalls())
func (mock *BlockChainClientMock) BestBlockHashCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockBestBlockHash.RLock()
	calls = mock.calls.BestBlockHash
	mock.lockBestBlockHash.RUnlock()
	return calls
}

// Block calls BlockFunc.
func (mock *BlockChainClientMock) Block(ctx context.Context, hash string) (*models.Block, error) {
	if mock.BlockFunc == nil {
		panic("BlockChainClientMock.BlockFunc: method is nil but BlockChainClient.Block was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash string
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockBlock.Lock()
	mock.calls.Block = append(mock.calls.Block, callInfo)
	mock.lockBlock.Unlock()
	return mock.BlockFunc(ctx, hash)
}

// BlockCalls gets all the calls that were made to Block.
// Check the length with:
//     len(mockedBlockChainClient.BlockCalls())
func (mock *BlockChainClientMock) BlockCalls() []struct {
	Ctx  context.Context
	Hash string
} {
	var calls []struct {
		Ctx  context.Context
		Hash string
	}
	mock.lockBlock.RLock()
	calls = mock.calls.Block
	mock.lockBlock.RUnlock()
	return calls
}

// BlockByHeight calls BlockByHeightFunc.
func (mock *BlockChainClientMock) BlockByHeight(ctx context.Context, height int) (*models.Block, error) {
	if mock.BlockByHeightFunc == nil {
		panic("BlockChainClientMock.BlockByHeightFunc: method is nil but BlockChainClient.BlockByHeight was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height int
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockBlockByHeight.Lock()
	mock.calls.BlockByHeight = append(mock.calls.BlockByHeight, callInfo)
	mock.lockBlockByHeight.Unlock()
	return mock.BlockByHeightFunc(ctx, height)
}

// BlockByHeightCalls gets all the calls that were made to BlockByHeight.
// Check the length with:
//     len(mockedBlockChainClient.BlockByHeightCalls())
func (mock *BlockChainClientMock) BlockByHeightCalls() []struct {
	Ctx    context.Context
	Height int
} {
	var calls []struct {
		Ctx    context.Context
		Height int
	}
	mock.lockBlockByHeight.RLock()
	calls = mock.calls.BlockByHeight
	mock.lockBlockByHeight.RUnlock()
	return calls
}

// BlockCount calls BlockCountFunc.
func (mock *BlockChainClientMock) BlockCount(ctx context.Context) (uint32, error) {
	if mock.BlockCountFunc == nil {
		panic("BlockChainClientMock.BlockCountFunc: method is nil but BlockChainClient.BlockCount was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockBlockCount.Lock()
	mock.calls.BlockCount = append(mock.calls.BlockCount, callInfo)
	mock.lockBlockCount.Unlock()
	return mock.BlockCountFunc(ctx)
}

// BlockCountCalls gets all the calls that were made to BlockCount.
// Check the length with:
//     len(mockedBlockChainClient.BlockCountCalls())
func (mock *BlockChainClientMock) BlockCountCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockBlockCount.RLock()
	calls = mock.calls.BlockCount
	mock.lockBlockCount.RUnlock()
	return calls
}

// BlockDecodeHeader calls BlockDecodeHeaderFunc.
func (mock *BlockChainClientMock) BlockDecodeHeader(ctx context.Context, hash string) (*models.BlockDecodeHeader, error) {
	if mock.BlockDecodeHeaderFunc == nil {
		panic("BlockChainClientMock.BlockDecodeHeaderFunc: method is nil but BlockChainClient.BlockDecodeHeader was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash string
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockBlockDecodeHeader.Lock()
	mock.calls.BlockDecodeHeader = append(mock.calls.BlockDecodeHeader, callInfo)
	mock.lockBlockDecodeHeader.Unlock()
	return mock.BlockDecodeHeaderFunc(ctx, hash)
}

// BlockDecodeHeaderCalls gets all the calls that were made to BlockDecodeHeader.
// Check the length with:
//     len(mockedBlockChainClient.BlockDecodeHeaderCalls())
func (mock *BlockChainClientMock) BlockDecodeHeaderCalls() []struct {
	Ctx  context.Context
	Hash string
} {
	var calls []struct {
		Ctx  context.Context
		Hash string
	}
	mock.lockBlockDecodeHeader.RLock()
	calls = mock.calls.BlockDecodeHeader
	mock.lockBlockDecodeHeader.RUnlock()
	return calls
}

// BlockDecodeHeaderByHeight calls BlockDecodeHeaderByHeightFunc.
func (mock *BlockChainClientMock) BlockDecodeHeaderByHeight(ctx context.Context, height int) (*models.BlockDecodeHeader, error) {
	if mock.BlockDecodeHeaderByHeightFunc == nil {
		panic("BlockChainClientMock.BlockDecodeHeaderByHeightFunc: method is nil but BlockChainClient.BlockDecodeHeaderByHeight was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height int
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockBlockDecodeHeaderByHeight.Lock()
	mock.calls.BlockDecodeHeaderByHeight = append(mock.calls.BlockDecodeHeaderByHeight, callInfo)
	mock.lockBlockDecodeHeaderByHeight.Unlock()
	return mock.BlockDecodeHeaderByHeightFunc(ctx, height)
}

// BlockDecodeHeaderByHeightCalls gets all the calls that were made to BlockDecodeHeaderByHeight.
// Check the length with:
//     len(mockedBlockChainClient.BlockDecodeHeaderByHeightCalls())
func (mock *BlockChainClientMock) BlockDecodeHeaderByHeightCalls() []struct {
	Ctx    context.Context
	Height int
} {
	var calls []struct {
		Ctx    context.Context
		Height int
	}
	mock.lockBlockDecodeHeaderByHeight.RLock()
	calls = mock.calls.BlockDecodeHeaderByHeight
	mock.lockBlockDecodeHeaderByHeight.RUnlock()
	return calls
}

// BlockHash calls BlockHashFunc.
func (mock *BlockChainClientMock) BlockHash(ctx context.Context, height int) (string, error) {
	if mock.BlockHashFunc == nil {
		panic("BlockChainClientMock.BlockHashFunc: method is nil but BlockChainClient.BlockHash was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height int
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockBlockHash.Lock()
	mock.calls.BlockHash = append(mock.calls.BlockHash, callInfo)
	mock.lockBlockHash.Unlock()
	return mock.BlockHashFunc(ctx, height)
}

// BlockHashCalls gets all the calls that were made to BlockHash.
// Check the length with:
//     len(mockedBlockChainClient.BlockHashCalls())
func (mock *BlockChainClientMock) BlockHashCalls() []struct {
	Ctx    context.Context
	Height int
} {
	var calls []struct {
		Ctx    context.Context
		Height int
	}
	mock.lockBlockHash.RLock()
	calls = mock.calls.BlockHash
	mock.lockBlockHash.RUnlock()
	return calls
}

// BlockHeader calls BlockHeaderFunc.
func (mock *BlockChainClientMock) BlockHeader(ctx context.Context, hash string) (*models.BlockHeader, error) {
	if mock.BlockHeaderFunc == nil {
		panic("BlockChainClientMock.BlockHeaderFunc: method is nil but BlockChainClient.BlockHeader was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash string
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockBlockHeader.Lock()
	mock.calls.BlockHeader = append(mock.calls.BlockHeader, callInfo)
	mock.lockBlockHeader.Unlock()
	return mock.BlockHeaderFunc(ctx, hash)
}

// BlockHeaderCalls gets all the calls that were made to BlockHeader.
// Check the length with:
//     len(mockedBlockChainClient.BlockHeaderCalls())
func (mock *BlockChainClientMock) BlockHeaderCalls() []struct {
	Ctx  context.Context
	Hash string
} {
	var calls []struct {
		Ctx  context.Context
		Hash string
	}
	mock.lockBlockHeader.RLock()
	calls = mock.calls.BlockHeader
	mock.lockBlockHeader.RUnlock()
	return calls
}

// BlockHeaderHex calls BlockHeaderHexFunc.
func (mock *BlockChainClientMock) BlockHeaderHex(ctx context.Context, hash string) (string, error) {
	if mock.BlockHeaderHexFunc == nil {
		panic("BlockChainClientMock.BlockHeaderHexFunc: method is nil but BlockChainClient.BlockHeaderHex was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash string
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockBlockHeaderHex.Lock()
	mock.calls.BlockHeaderHex = append(mock.calls.BlockHeaderHex, callInfo)
	mock.lockBlockHeaderHex.Unlock()
	return mock.BlockHeaderHexFunc(ctx, hash)
}

// BlockHeaderHexCalls gets all the calls that were made to BlockHeaderHex.
// Check the length with:
//     len(mockedBlockChainClient.BlockHeaderHexCalls())
func (mock *BlockChainClientMock) BlockHeaderHexCalls() []struct {
	Ctx  context.Context
	Hash string
} {
	var calls []struct {
		Ctx  context.Context
		Hash string
	}
	mock.lockBlockHeaderHex.RLock()
	calls = mock.calls.BlockHeaderHex
	mock.lockBlockHeaderHex.RUnlock()
	return calls
}

// BlockHex calls BlockHexFunc.
func (mock *BlockChainClientMock) BlockHex(ctx context.Context, hash string) (string, error) {
	if mock.BlockHexFunc == nil {
		panic("BlockChainClientMock.BlockHexFunc: method is nil but BlockChainClient.BlockHex was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash string
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockBlockHex.Lock()
	mock.calls.BlockHex = append(mock.calls.BlockHex, callInfo)
	mock.lockBlockHex.Unlock()
	return mock.BlockHexFunc(ctx, hash)
}

// BlockHexCalls gets all the calls that were made to BlockHex.
// Check the length with:
//     len(mockedBlockChainClient.BlockHexCalls())
func (mock *BlockChainClientMock) BlockHexCalls() []struct {
	Ctx  context.Context
	Hash string
} {
	var calls []struct {
		Ctx  context.Context
		Hash string
	}
	mock.lockBlockHex.RLock()
	calls = mock.calls.BlockHex
	mock.lockBlockHex.RUnlock()
	return calls
}

// BlockHexByHeight calls BlockHexByHeightFunc.
func (mock *BlockChainClientMock) BlockHexByHeight(ctx context.Context, height int) (string, error) {
	if mock.BlockHexByHeightFunc == nil {
		panic("BlockChainClientMock.BlockHexByHeightFunc: method is nil but BlockChainClient.BlockHexByHeight was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height int
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockBlockHexByHeight.Lock()
	mock.calls.BlockHexByHeight = append(mock.calls.BlockHexByHeight, callInfo)
	mock.lockBlockHexByHeight.Unlock()
	return mock.BlockHexByHeightFunc(ctx, height)
}

// BlockHexByHeightCalls gets all the calls that were made to BlockHexByHeight.
// Check the length with:
//     len(mockedBlockChainClient.BlockHexByHeightCalls())
func (mock *BlockChainClientMock) BlockHexByHeightCalls() []struct {
	Ctx    context.Context
	Height int
} {
	var calls []struct {
		Ctx    context.Context
		Height int
	}
	mock.lockBlockHexByHeight.RLock()
	calls = mock.calls.BlockHexByHeight
	mock.lockBlockHexByHeight.RUnlock()
	return calls
}

// BlockStats calls BlockStatsFunc.
func (mock *BlockChainClientMock) BlockStats(ctx context.Context, hash string, fields ...string) (*models.BlockStats, error) {
	if mock.BlockStatsFunc == nil {
		panic("BlockChainClientMock.BlockStatsFunc: method is nil but BlockChainClient.BlockStats was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Hash   string
		Fields []string
	}{
		Ctx:    ctx,
		Hash:   hash,
		Fields: fields,
	}
	mock.lockBlockStats.Lock()
	mock.calls.BlockStats = append(mock.calls.BlockStats, callInfo)
	mock.lockBlockStats.Unlock()
	return mock.BlockStatsFunc(ctx, hash, fields...)
}

// BlockStatsCalls gets all the calls that were made to BlockStats.
// Check the length with:
//     len(mockedBlockChainClient.BlockStatsCalls())
func (mock *BlockChainClientMock) BlockStatsCalls() []struct {
	Ctx    context.Context
	Hash   string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Hash   string
		Fields []string
	}
	mock.lockBlockStats.RLock()
	calls = mock.calls.BlockStats
	mock.lockBlockStats.RUnlock()
	return calls
}

// BlockStatsByHeight calls BlockStatsByHeightFunc.
func (mock *BlockChainClientMock) BlockStatsByHeight(ctx context.Context, height int, fields ...string) (*models.BlockStats, error) {
	if mock.BlockStatsByHeightFunc == nil {
		panic("BlockChainClientMock.BlockStatsByHeightFunc: method is nil but BlockChainClient.BlockStatsByHeight was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height int
		Fields []string
	}{
		Ctx:    ctx,
		Height: height,
		Fields: fields,
	}
	mock.lockBlockStatsByHeight.Lock()
	mock.calls.BlockStatsByHeight = append(mock.calls.BlockStatsByHeight, callInfo)
	mock.lockBlockStatsByHeight.Unlock()
	return mock.BlockStatsByHeightFunc(ctx, height, fields...)
}

// BlockStatsByHeightCalls gets all the calls that were made to BlockStatsByHeight.
// Check the length with:
//     len(mockedBlockChainClient.BlockStatsByHeightCalls())
func (mock *BlockChainClientMock) BlockStatsByHeightCalls() []struct {
	Ctx    context.Context
	Height int
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Height int
		Fields []string
	}
	mock.lockBlockStatsByHeight.RLock()
	calls = mock.calls.BlockStatsByHeight
	mock.lockBlockStatsByHeight.RUnlock()
	return calls
}

// ChainInfo calls ChainInfoFunc.
func (mock *BlockChainClientMock) ChainInfo(ctx context.Context) (*models.ChainInfo, error) {
	if mock.ChainInfoFunc == nil {
		panic("BlockChainClientMock.ChainInfoFunc: method is nil but BlockChainClient.ChainInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockChainInfo.Lock()
	mock.calls.ChainInfo = append(mock.calls.ChainInfo, callInfo)
	mock.lockChainInfo.Unlock()
	return mock.ChainInfoFunc(ctx)
}

// ChainInfoCalls gets all the calls that were made to ChainInfo.
// Check the length with:
//     len(mockedBlockChainClient.ChainInfoCalls())
func (mock *BlockChainClientMock) ChainInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockChainInfo.RLock()
	calls = mock.calls.ChainInfo
	mock.lockChainInfo.RUnlock()
	return calls
}

// ChainTips calls ChainTipsFunc.
func (mock *BlockChainClientMock) ChainTips(ctx context.Context) ([]*models.ChainTip, error) {
	if mock.ChainTipsFunc == nil {
		panic("BlockChainClientMock.ChainTipsFunc: method is nil but BlockChainClient.ChainTips was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockChainTips.Lock()
	mock.calls.ChainTips = append(mock.calls.ChainTips, callInfo)
	mock.lockChainTips.Unlock()
	return mock.ChainTipsFunc(ctx)
}

// ChainTipsCalls gets all the calls that were made to ChainTips.
// Check the length with:
//     len(mockedBlockChainClient.ChainTipsCalls())
func (mock *BlockChainClientMock) ChainTipsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockChainTips.RLock()
	calls = mock.calls.ChainTips
	mock.lockChainTips.RUnlock()
	return calls
}

// ChainTxStats calls ChainTxStatsFunc.
func (mock *BlockChainClientMock) ChainTxStats(ctx context.Context, opts *models.OptsChainTxStats) (*models.ChainTxStats, error) {
	if mock.ChainTxStatsFunc == nil {
		panic("BlockChainClientMock.ChainTxStatsFunc: method is nil but BlockChainClient.ChainTxStats was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsChainTxStats
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockChainTxStats.Lock()
	mock.calls.ChainTxStats = append(mock.calls.ChainTxStats, callInfo)
	mock.lockChainTxStats.Unlock()
	return mock.ChainTxStatsFunc(ctx, opts)
}

// ChainTxStatsCalls gets all the calls that were made to ChainTxStats.
// Check the length with:
//     len(mockedBlockChainClient.ChainTxStatsCalls())
func (mock *BlockChainClientMock) ChainTxStatsCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsChainTxStats
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsChainTxStats
	}
	mock.lockChainTxStats.RLock()
	calls = mock.calls.ChainTxStats
	mock.lockChainTxStats.RUnlock()
	return calls
}

// CheckJournal calls CheckJournalFunc.
func (mock *BlockChainClientMock) CheckJournal(ctx context.Context) (*models.JournalStatus, error) {
	if mock.CheckJournalFunc == nil {
		panic("BlockChainClientMock.CheckJournalFunc: method is nil but BlockChainClient.CheckJournal was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCheckJournal.Lock()
	mock.calls.CheckJournal = append(mock.calls.CheckJournal, callInfo)
	mock.lockCheckJournal.Unlock()
	return mock.CheckJournalFunc(ctx)
}

// CheckJournalCalls gets all the calls that were made to CheckJournal.
// Check the length with:
//     len(mockedBlockChainClient.CheckJournalCalls())
func (mock *BlockChainClientMock) CheckJournalCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCheckJournal.RLock()
	calls = mock.calls.CheckJournal
	mock.lockCheckJournal.RUnlock()
	return calls
}

// Difficulty calls DifficultyFunc.
func (mock *BlockChainClientMock) Difficulty(ctx context.Context) (float64, error) {
	if mock.DifficultyFunc == nil {
		panic("BlockChainClientMock.DifficultyFunc: method is nil but BlockChainClient.Difficulty was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockDifficulty.Lock()
	mock.calls.Difficulty = append(mock.calls.Difficulty, callInfo)
	mock.lockDifficulty.Unlock()
	return mock.DifficultyFunc(ctx)
}

// DifficultyCalls gets all the calls that were made to Difficulty.
// Check the length with:
//     len(mockedBlockChainClient.DifficultyCalls())
func (mock *BlockChainClientMock) DifficultyCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockDifficulty.RLock()
	calls = mock.calls.Difficulty
	mock.lockDifficulty.RUnlock()
	return calls
}

// Generate calls GenerateFunc.
func (mock *BlockChainClientMock) Generate(ctx context.Context, n int, opts *models.OptsGenerate) ([]string, error) {
	if mock.GenerateFunc == nil {
		panic("BlockChainClientMock.GenerateFunc: method is nil but BlockChainClient.Generate was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		N    int
		Opts *models.OptsGenerate
	}{
		Ctx:  ctx,
		N:    n,
		Opts: opts,
	}
	mock.lockGenerate.Lock()
	mock.calls.Generate = append(mock.calls.Generate, callInfo)
	mock.lockGenerate.Unlock()
	return mock.GenerateFunc(ctx, n, opts)
}

// GenerateCalls gets all the calls that were made to Generate.
// Check the length with:
//     len(mockedBlockChainClient.GenerateCalls())
func (mock *BlockChainClientMock) GenerateCalls() []struct {
	Ctx  context.Context
	N    int
	Opts *models.OptsGenerate
} {
	var calls []struct {
		Ctx  context.Context
		N    int
		Opts *models.OptsGenerate
	}
	mock.lockGenerate.RLock()
	calls = mock.calls.Generate
	mock.lockGenerate.RUnlock()
	return calls
}

// GenerateToAddress calls GenerateToAddressFunc.
func (mock *BlockChainClientMock) GenerateToAddress(ctx context.Context, n int, addr string, opts *models.OptsGenerate) ([]string, error) {
	if mock.GenerateToAddressFunc == nil {
		panic("BlockChainClientMock.GenerateToAddressFunc: method is nil but BlockChainClient.GenerateToAddress was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		N    int
		Addr string
		Opts *models.OptsGenerate
	}{
		Ctx:  ctx,
		N:    n,
		Addr: addr,
		Opts: opts,
	}
	mock.lockGenerateToAddress.Lock()
	mock.calls.GenerateToAddress = append(mock.calls.GenerateToAddress, callInfo)
	mock.lockGenerateToAddress.Unlock()
	return mock.GenerateToAddressFunc(ctx, n, addr, opts)
}

// GenerateToAddressCalls gets all the calls that were made to GenerateToAddress.
// Check the length with:
//     len(mockedBlockChainClient.GenerateToAddressCalls())
func (mock *BlockChainClientMock) GenerateToAddressCalls() []struct {
	Ctx  context.Context
	N    int
	Addr string
	Opts *models.OptsGenerate
} {
	var calls []struct {
		Ctx  context.Context
		N    int
		Addr string
		Opts *models.OptsGenerate
	}
	mock.lockGenerateToAddress.RLock()
	calls = mock.calls.GenerateToAddress
	mock.lockGenerateToAddress.RUnlock()
	return calls
}

// LegacyMerkleProof calls LegacyMerkleProofFunc.
func (mock *BlockChainClientMock) LegacyMerkleProof(ctx context.Context, txID string, opts *models.OptsLegacyMerkleProof) (*models.LegacyMerkleProof, error) {
	if mock.LegacyMerkleProofFunc == nil {
		panic("BlockChainClientMock.LegacyMerkleProofFunc: method is nil but BlockChainClient.LegacyMerkleProof was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
		Opts *models.OptsLegacyMerkleProof
	}{
		Ctx:  ctx,
		TxID: txID,
		Opts: opts,
	}
	mock.lockLegacyMerkleProof.Lock()
	mock.calls.LegacyMerkleProof = append(mock.calls.LegacyMerkleProof, callInfo)
	mock.lockLegacyMerkleProof.Unlock()
	return mock.LegacyMerkleProofFunc(ctx, txID, opts)
}

// LegacyMerkleProofCalls gets all the calls that were made to LegacyMerkleProof.
// Check the length with:
//     len(mockedBlockChainClient.LegacyMerkleProofCalls())
func (mock *BlockChainClientMock) LegacyMerkleProofCalls() []struct {
	Ctx  context.Context
	TxID string
	Opts *models.OptsLegacyMerkleProof
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
		Opts *models.OptsLegacyMerkleProof
	}
	mock.lockLegacyMerkleProof.RLock()
	calls = mock.calls.LegacyMerkleProof
	mock.lockLegacyMerkleProof.RUnlock()
	return calls
}

// MempoolAncestorIDs calls MempoolAncestorIDsFunc.
func (mock *BlockChainClientMock) MempoolAncestorIDs(ctx context.Context, txID string) ([]string, error) {
	if mock.MempoolAncestorIDsFunc == nil {
		panic("BlockChainClientMock.MempoolAncestorIDsFunc: method is nil but BlockChainClient.MempoolAncestorIDs was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockMempoolAncestorIDs.Lock()
	mock.calls.MempoolAncestorIDs = append(mock.calls.MempoolAncestorIDs, callInfo)
	mock.lockMempoolAncestorIDs.Unlock()
	return mock.MempoolAncestorIDsFunc(ctx, txID)
}

// MempoolAncestorIDsCalls gets all the calls that were made to MempoolAncestorIDs.
// Check the length with:
//     len(mockedBlockChainClient.MempoolAncestorIDsCalls())
func (mock *BlockChainClientMock) MempoolAncestorIDsCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockMempoolAncestorIDs.RLock()
	calls = mock.calls.MempoolAncestorIDs
	mock.lockMempoolAncestorIDs.RUnlock()
	return calls
}

// MempoolAncestors calls MempoolAncestorsFunc.
func (mock *BlockChainClientMock) MempoolAncestors(ctx context.Context, txID string) (models.MempoolTxs, error) {
	if mock.MempoolAncestorsFunc == nil {
		panic("BlockChainClientMock.MempoolAncestorsFunc: method is nil but BlockChainClient.MempoolAncestors was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockMempoolAncestors.Lock()
	mock.calls.MempoolAncestors = append(mock.calls.MempoolAncestors, callInfo)
	mock.lockMempoolAncestors.Unlock()
	return mock.MempoolAncestorsFunc(ctx, txID)
}

// MempoolAncestorsCalls gets all the calls that were made to MempoolAncestors.
// Check the length with:
//     len(mockedBlockChainClient.MempoolAncestorsCalls())
func (mock *BlockChainClientMock) MempoolAncestorsCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockMempoolAncestors.RLock()
	calls = mock.calls.MempoolAncestors
	mock.lockMempoolAncestors.RUnlock()
	return calls
}

// MempoolDescendantIDs calls MempoolDescendantIDsFunc.
func (mock *BlockChainClientMock) MempoolDescendantIDs(ctx context.Context, txID string) ([]string, error) {
	if mock.MempoolDescendantIDsFunc == nil {
		panic("BlockChainClientMock.MempoolDescendantIDsFunc: method is nil but BlockChainClient.MempoolDescendantIDs was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockMempoolDescendantIDs.Lock()
	mock.calls.MempoolDescendantIDs = append(mock.calls.MempoolDescendantIDs, callInfo)
	mock.lockMempoolDescendantIDs.Unlock()
	return mock.MempoolDescendantIDsFunc(ctx, txID)
}

// MempoolDescendantIDsCalls gets all the calls that were made to MempoolDescendantIDs.
// Check the length with:
//     len(mockedBlockChainClient.MempoolDescendantIDsCalls())
func (mock *BlockChainClientMock) MempoolDescendantIDsCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockMempoolDescendantIDs.RLock()
	calls = mock.calls.MempoolDescendantIDs
	mock.lockMempoolDescendantIDs.RUnlock()
	return calls
}

// MempoolDescendants calls MempoolDescendantsFunc.
func (mock *BlockChainClientMock) MempoolDescendants(ctx context.Context, txID string) (models.MempoolTxs, error) {
	if mock.MempoolDescendantsFunc == nil {
		panic("BlockChainClientMock.MempoolDescendantsFunc: method is nil but BlockChainClient.MempoolDescendants was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockMempoolDescendants.Lock()
	mock.calls.MempoolDescendants = append(mock.calls.MempoolDescendants, callInfo)
	mock.lockMempoolDescendants.Unlock()
	return mock.MempoolDescendantsFunc(ctx, txID)
}

// MempoolDescendantsCalls gets all the calls that were made to MempoolDescendants.
// Check the length with:
//     len(mockedBlockChainClient.MempoolDescendantsCalls())
func (mock *BlockChainClientMock) MempoolDescendantsCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockMempoolDescendants.RLock()
	calls = mock.calls.MempoolDescendants
	mock.lockMempoolDescendants.RUnlock()
	return calls
}

// MempoolEntry calls MempoolEntryFunc.
func (mock *BlockChainClientMock) MempoolEntry(ctx context.Context, txID string) (*models.MempoolEntry, error) {
	if mock.MempoolEntryFunc == nil {
		panic("BlockChainClientMock.MempoolEntryFunc: method is nil but BlockChainClient.MempoolEntry was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockMempoolEntry.Lock()
	mock.calls.MempoolEntry = append(mock.calls.MempoolEntry, callInfo)
	mock.lockMempoolEntry.Unlock()
	return mock.MempoolEntryFunc(ctx, txID)
}

// MempoolEntryCalls gets all the calls that were made to MempoolEntry.
// Check the length with:
//     len(mockedBlockChainClient.MempoolEntryCalls())
func (mock *BlockChainClientMock) MempoolEntryCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockMempoolEntry.RLock()
	calls = mock.calls.MempoolEntry
	mock.lockMempoolEntry.RUnlock()
	return calls
}

// MerkleProof calls MerkleProofFunc.
func (mock *BlockChainClientMock) MerkleProof(ctx context.Context, blockHash string, txID string, opts *models.OptsMerkleProof) (*bc.MerkleProof, error) {
	if mock.MerkleProofFunc == nil {
		panic("BlockChainClientMock.MerkleProofFunc: method is nil but BlockChainClient.MerkleProof was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		BlockHash string
		TxID      string
		Opts      *models.OptsMerkleProof
	}{
		Ctx:       ctx,
		BlockHash: blockHash,
		TxID:      txID,
		Opts:      opts,
	}
	mock.lockMerkleProof.Lock()
	mock.calls.MerkleProof = append(mock.calls.MerkleProof, callInfo)
	mock.lockMerkleProof.Unlock()
	return mock.MerkleProofFunc(ctx, blockHash, txID, opts)
}

// MerkleProofCalls gets all the calls that were made to MerkleProof.
// Check the length with:
//     len(mockedBlockChainClient.MerkleProofCalls())
func (mock *BlockChainClientMock) MerkleProofCalls() []struct {
	Ctx       context.Context
	BlockHash string
	TxID      string
	Opts      *models.OptsMerkleProof
} {
	var calls []struct {
		Ctx       context.Context
		BlockHash string
		TxID      string
		Opts      *models.OptsMerkleProof
	}
	mock.lockMerkleProof.RLock()
	calls = mock.calls.MerkleProof
	mock.lockMerkleProof.RUnlock()
	return calls
}

// Output calls OutputFunc.
func (mock *BlockChainClientMock) Output(ctx context.Context, txID string, n int, opts *models.OptsOutput) (*models.Output, error) {
	if mock.OutputFunc == nil {
		panic("BlockChainClientMock.OutputFunc: method is nil but BlockChainClient.Output was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
		N    int
		Opts *models.OptsOutput
	}{
		Ctx:  ctx,
		TxID: txID,
		N:    n,
		Opts: opts,
	}
	mock.lockOutput.Lock()
	mock.calls.Output = append(mock.calls.Output, callInfo)
	mock.lockOutput.Unlock()
	return mock.OutputFunc(ctx, txID, n, opts)
}

// OutputCalls gets all the calls that were made to Output.
// Check the length with:
//     len(mockedBlockChainClient.OutputCalls())
func (mock *BlockChainClientMock) OutputCalls() []struct {
	Ctx  context.Context
	TxID string
	N    int
	Opts *models.OptsOutput
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
		N    int
		Opts *models.OptsOutput
	}
	mock.lockOutput.RLock()
	calls = mock.calls.Output
	mock.lockOutput.RUnlock()
	return calls
}

// OutputSetInfo calls OutputSetInfoFunc.
func (mock *BlockChainClientMock) OutputSetInfo(ctx context.Context) (*models.OutputSetInfo, error) {
	if mock.OutputSetInfoFunc == nil {
		panic("BlockChainClientMock.OutputSetInfoFunc: method is nil but BlockChainClient.OutputSetInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockOutputSetInfo.Lock()
	mock.calls.OutputSetInfo = append(mock.calls.OutputSetInfo, callInfo)
	mock.lockOutputSetInfo.Unlock()
	return mock.OutputSetInfoFunc(ctx)
}

// OutputSetInfoCalls gets all the calls that were made to OutputSetInfo.
// Check the length with:
//     len(mockedBlockChainClient.OutputSetInfoCalls())
func (mock *BlockChainClientMock) OutputSetInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockOutputSetInfo.RLock()
	calls = mock.calls.OutputSetInfo
	mock.lockOutputSetInfo.RUnlock()
	return calls
}

// PreciousBlock calls PreciousBlockFunc.
func (mock *BlockChainClientMock) PreciousBlock(ctx context.Context, blockHash string) error {
	if mock.PreciousBlockFunc == nil {
		panic("BlockChainClientMock.PreciousBlockFunc: method is nil but BlockChainClient.PreciousBlock was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		BlockHash string
	}{
		Ctx:       ctx,
		BlockHash: blockHash,
	}
	mock.lockPreciousBlock.Lock()
	mock.calls.PreciousBlock = append(mock.calls.PreciousBlock, callInfo)
	mock.lockPreciousBlock.Unlock()
	return mock.PreciousBlockFunc(ctx, blockHash)
}

// PreciousBlockCalls gets all the calls that were made to PreciousBlock.
// Check the length with:
//     len(mockedBlockChainClient.PreciousBlockCalls())
func (mock *BlockChainClientMock) PreciousBlockCalls() []struct {
	Ctx       context.Context
	BlockHash string
} {
	var calls []struct {
		Ctx       context.Context
		BlockHash string
	}
	mock.lockPreciousBlock.RLock()
	calls = mock.calls.PreciousBlock
	mock.lockPreciousBlock.RUnlock()
	return calls
}

// PruneChain calls PruneChainFunc.
func (mock *BlockChainClientMock) PruneChain(ctx context.Context, height int) (uint32, error) {
	if mock.PruneChainFunc == nil {
		panic("BlockChainClientMock.PruneChainFunc: method is nil but BlockChainClient.PruneChain was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height int
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockPruneChain.Lock()
	mock.calls.PruneChain = append(mock.calls.PruneChain, callInfo)
	mock.lockPruneChain.Unlock()
	return mock.PruneChainFunc(ctx, height)
}

// PruneChainCalls gets all the calls that were made to PruneChain.
// Check the length with:
//     len(mockedBlockChainClient.PruneChainCalls())
func (mock *BlockChainClientMock) PruneChainCalls() []struct {
	Ctx    context.Context
	Height int
} {
	var calls []struct {
		Ctx    context.Context
		Height int
	}
	mock.lockPruneChain.RLock()
	calls = mock.calls.PruneChain
	mock.lockPruneChain.RUnlock()
	return calls
}

// RawMempool calls RawMempoolFunc.
func (mock *BlockChainClientMock) RawMempool(ctx context.Context) (models.MempoolTxs, error) {
	if mock.RawMempoolFunc == nil {
		panic("BlockChainClientMock.RawMempoolFunc: method is nil but BlockChainClient.RawMempool was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRawMempool.Lock()
	mock.calls.RawMempool = append(mock.calls.RawMempool, callInfo)
	mock.lockRawMempool.Unlock()
	return mock.RawMempoolFunc(ctx)
}

// RawMempoolCalls gets all the calls that were made to RawMempool.
// Check the length with:
//     len(mockedBlockChainClient.RawMempoolCalls())
func (mock *BlockChainClientMock) RawMempoolCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRawMempool.RLock()
	calls = mock.calls.RawMempool
	mock.lockRawMempool.RUnlock()
	return calls
}

// RawMempoolIDs calls RawMempoolIDsFunc.
func (mock *BlockChainClientMock) RawMempoolIDs(ctx context.Context) ([]string, error) {
	if mock.RawMempoolIDsFunc == nil {
		panic("BlockChainClientMock.RawMempoolIDsFunc: method is nil but BlockChainClient.RawMempoolIDs was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRawMempoolIDs.Lock()
	mock.calls.RawMempoolIDs = append(mock.calls.RawMempoolIDs, callInfo)
	mock.lockRawMempoolIDs.Unlock()
	return mock.RawMempoolIDsFunc(ctx)
}

// RawMempoolIDsCalls gets all the calls that were made to RawMempoolIDs.
// Check the length with:
//     len(mockedBlockChainClient.RawMempoolIDsCalls())
func (mock *BlockChainClientMock) RawMempoolIDsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRawMempoolIDs.RLock()
	calls = mock.calls.RawMempoolIDs
	mock.lockRawMempoolIDs.RUnlock()
	return calls
}

// RawNonFinalMempool calls RawNonFinalMempoolFunc.
func (mock *BlockChainClientMock) RawNonFinalMempool(ctx context.Context) ([]string, error) {
	if mock.RawNonFinalMempoolFunc == nil {
		panic("BlockChainClientMock.RawNonFinalMempoolFunc: method is nil but BlockChainClient.RawNonFinalMempool was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRawNonFinalMempool.Lock()
	mock.calls.RawNonFinalMempool = append(mock.calls.RawNonFinalMempool, callInfo)
	mock.lockRawNonFinalMempool.Unlock()
	return mock.RawNonFinalMempoolFunc(ctx)
}

// RawNonFinalMempoolCalls gets all the calls that were made to RawNonFinalMempool.
// Check the length with:
//     len(mockedBlockChainClient.RawNonFinalMempoolCalls())
func (mock *BlockChainClientMock) RawNonFinalMempoolCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRawNonFinalMempool.RLock()
	calls = mock.calls.RawNonFinalMempool
	mock.lockRawNonFinalMempool.RUnlock()
	return calls
}

// RebuildJournal calls RebuildJournalFunc.
func (mock *BlockChainClientMock) RebuildJournal(ctx context.Context) error {
	if mock.RebuildJournalFunc == nil {
		panic("BlockChainClientMock.RebuildJournalFunc: method is nil but BlockChainClient.RebuildJournal was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRebuildJournal.Lock()
	mock.calls.RebuildJournal = append(mock.calls.RebuildJournal, callInfo)
	mock.lockRebuildJournal.Unlock()
	return mock.RebuildJournalFunc(ctx)
}

// RebuildJournalCalls gets all the calls that were made to RebuildJournal.
// Check the length with:
//     len(mockedBlockChainClient.RebuildJournalCalls())
func (mock *BlockChainClientMock) RebuildJournalCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRebuildJournal.RLock()
	calls = mock.calls.RebuildJournal
	mock.lockRebuildJournal.RUnlock()
	return calls
}

// VerifyChain calls VerifyChainFunc.
func (mock *BlockChainClientMock) VerifyChain(ctx context.Context) (bool, error) {
	if mock.VerifyChainFunc == nil {
		panic("BlockChainClientMock.VerifyChainFunc: method is nil but BlockChainClient.VerifyChain was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockVerifyChain.Lock()
	mock.calls.VerifyChain = append(mock.calls.VerifyChain, callInfo)
	mock.lockVerifyChain.Unlock()
	return mock.VerifyChainFunc(ctx)
}

// VerifyChainCalls gets all the calls that were made to VerifyChain.
// Check the length with:
//     len(mockedBlockChainClient.VerifyChainCalls())
func (mock *BlockChainClientMock) VerifyChainCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockVerifyChain.RLock()
	calls = mock.calls.VerifyChain
	mock.lockVerifyChain.RUnlock()
	return calls
}

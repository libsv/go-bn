// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/libsv/go-bk/wif"
	"github.com/libsv/go-bn"
	"github.com/libsv/go-bn/models"
	"github.com/libsv/go-bt/v2"
	"sync"
)

// Ensure, that WalletClientMock does implement bn.WalletClient.
// If this is not the case, regenerate this file with moq.
var _ bn.WalletClient = &WalletClientMock{}

// WalletClientMock is a mock implementation of bn.WalletClient.
//
// 	func TestSomethingThatUsesWalletClient(t *testing.T) {
//
// 		// make and configure a mocked bn.WalletClient
// 		mockedWalletClient := &WalletClientMock{
// 			AbandonTransactionFunc: func(ctx context.Context, txID string) error {
// 				panic("mock out the AbandonTransaction method")
// 			},
// 			AccountFunc: func(ctx context.Context, address string) (string, error) {
// 				panic("mock out the Account method")
// 			},
// 			AccountAddressFunc: func(ctx context.Context, account string) (string, error) {
// 				panic("mock out the AccountAddress method")
// 			},
// 			AccountAddressesFunc: func(ctx context.Context, account string) ([]string, error) {
// 				panic("mock out the AccountAddresses method")
// 			},
// 			AddMultiSigAddressFunc: func(ctx context.Context, n int, keys ...string) (string, error) {
// 				panic("mock out the AddMultiSigAddress method")
// 			},
// 			BackupWalletFunc: func(ctx context.Context, dest string) error {
// 				panic("mock out the BackupWallet method")
// 			},
// 			BalanceFunc: func(ctx context.Context, opts *models.OptsBalance) (float64, error) {
// 				panic("mock out the Balance method")
// 			},
// 			DumpPrivateKeyFunc: func(ctx context.Context, address string) (*wif.WIF, error) {
// 				panic("mock out the DumpPrivateKey method")
// 			},
// 			DumpWalletFunc: func(ctx context.Context, dest string) (*models.DumpWallet, error) {
// 				panic("mock out the DumpWallet method")
// 			},
// 			EncryptWalletFunc: func(ctx context.Context, passphrase string) error {
// 				panic("mock out the EncryptWallet method")
// 			},
// 			ImportAddressFunc: func(ctx context.Context, address string, opts *models.OptsImportAddress) error {
// 				panic("mock out the ImportAddress method")
// 			},
// 			ImportMultiFunc: func(ctx context.Context, reqs []models.ImportMultiRequest, opts *models.OptsImportMulti) ([]*models.ImportMulti, error) {
// 				panic("mock out the ImportMulti method")
// 			},
// 			ImportPrivateKeyFunc: func(ctx context.Context, w *wif.WIF, opts *models.OptsImportPrivateKey) error {
// 				panic("mock out the ImportPrivateKey method")
// 			},
// 			ImportPrunedFundsFunc: func(ctx context.Context, tx *bt.Tx, txOutProof string) error {
// 				panic("mock out the ImportPrunedFunds method")
// 			},
// 			ImportPublicKeyFunc: func(ctx context.Context, publicKey string, opts *models.OptsImportPublicKey) error {
// 				panic("mock out the ImportPublicKey method")
// 			},
// 			ImportWalletFunc: func(ctx context.Context, filename string) error {
// 				panic("mock out the ImportWallet method")
// 			},
// 			KeypoolRefillFunc: func(ctx context.Context, opts *models.OptsKeypoolRefill) error {
// 				panic("mock out the KeypoolRefill method")
// 			},
// 			ListAccountsFunc: func(ctx context.Context, opts *models.OptsListAccounts) (map[string]float64, error) {
// 				panic("mock out the ListAccounts method")
// 			},
// 			ListLockUnspentFunc: func(ctx context.Context) ([]*models.LockUnspent, error) {
// 				panic("mock out the ListLockUnspent method")
// 			},
// 			ListReceivedByAccountFunc: func(ctx context.Context, opts *models.OptsListReceivedBy) ([]*models.ReceivedByAccount, error) {
// 				panic("mock out the ListReceivedByAccount method")
// 			},
// 			ListReceivedByAddressFunc: func(ctx context.Context, opts *models.OptsListReceivedBy) ([]*models.ReceivedByAddress, error) {
// 				panic("mock out the ListReceivedByAddress method")
// 			},
// 			ListSinceBlockFunc: func(ctx context.Context, opts *models.OptsListSinceBlock) (*models.SinceBlock, error) {
// 				panic("mock out the ListSinceBlock method")
// 			},
// 			ListTransactionsFunc: func(ctx context.Context, opts *models.OptsListTransactions) ([]*models.Transaction, error) {
// 				panic("mock out the ListTransactions method")
// 			},
// 			ListUnspentFunc: func(ctx context.Context, opts *models.OptsListUnspent) (bt.UTXOs, error) {
// 				panic("mock out the ListUnspent method")
// 			},
// 			ListWalletsFunc: func(ctx context.Context) ([]string, error) {
// 				panic("mock out the ListWallets method")
// 			},
// 			LockUnspentFunc: func(ctx context.Context, lock bool, opts *models.OptsLockUnspent) (bool, error) {
// 				panic("mock out the LockUnspent method")
// 			},
// 			MoveFunc: func(ctx context.Context, from string, to string, amount float64, opts *models.OptsMove) (bool, error) {
// 				panic("mock out the Move method")
// 			},
// 			NewAddressFunc: func(ctx context.Context, opts *models.OptsNewAddress) (string, error) {
// 				panic("mock out the NewAddress method")
// 			},
// 			RawChangeAddressFunc: func(ctx context.Context) (string, error) {
// 				panic("mock out the RawChangeAddress method")
// 			},
// 			ReceivedByAddressFunc: func(ctx context.Context, address string) (float64, error) {
// 				panic("mock out the ReceivedByAddress method")
// 			},
// 			RemovePrunedFundsFunc: func(ctx context.Context, txID string) error {
// 				panic("mock out the RemovePrunedFunds method")
// 			},
// 			SendFromFunc: func(ctx context.Context, from string, to string, amount float64, opts *models.OptsSendFrom) (string, error) {
// 				panic("mock out the SendFrom method")
// 			},
// 			SendManyFunc: func(ctx context.Context, from string, amounts map[string]float64, opts *models.OptsSendMany) (string, error) {
// 				panic("mock out the SendMany method")
// 			},
// 			SendToAddressFunc: func(ctx context.Context, address string, amount float64, opts *models.OptsSendToAddress) (string, error) {
// 				panic("mock out the SendToAddress method")
// 			},
// 			SetAccountFunc: func(ctx context.Context, address string, account string) error {
// 				panic("mock out the SetAccount method")
// 			},
// 			SetTxFeeFunc: func(ctx context.Context, amount float64) (bool, error) {
// 				panic("mock out the SetTxFee method")
// 			},
// 			SignMessageFunc: func(ctx context.Context, address string, message string) (string, error) {
// 				panic("mock out the SignMessage method")
// 			},
// 			TransactionFunc: func(ctx context.Context, txID string) (*models.Transaction, error) {
// 				panic("mock out the Transaction method")
// 			},
// 			UnconfirmedBalanceFunc: func(ctx context.Context) (float64, error) {
// 				panic("mock out the UnconfirmedBalance method")
// 			},
// 			WalletInfoFunc: func(ctx context.Context) (*models.WalletInfo, error) {
// 				panic("mock out the WalletInfo method")
// 			},
// 			WalletLockFunc: func(ctx context.Context) error {
// 				panic("mock out the WalletLock method")
// 			},
// 			WalletPhassphraseFunc: func(ctx context.Context, passphrase string, timeout int) error {
// 				panic("mock out the WalletPhassphrase method")
// 			},
// 			WalletPhassphraseChangeFunc: func(ctx context.Context, oldPassphrase string, newPassphrase string) error {
// 				panic("mock out the WalletPhassphraseChange method")
// 			},
// 		}
//
// 		// use mockedWalletClient in code that requires bn.WalletClient
// 		// and then make assertions.
//
// 	}
type WalletClientMock struct {
	// AbandonTransactionFunc mocks the AbandonTransaction method.
	AbandonTransactionFunc func(ctx context.Context, txID string) error

	// AccountFunc mocks the Account method.
	AccountFunc func(ctx context.Context, address string) (string, error)

	// AccountAddressFunc mocks the AccountAddress method.
	AccountAddressFunc func(ctx context.Context, account string) (string, error)

	// AccountAddressesFunc mocks the AccountAddresses method.
	AccountAddressesFunc func(ctx context.Context, account string) ([]string, error)

	// AddMultiSigAddressFunc mocks the AddMultiSigAddress method.
	AddMultiSigAddressFunc func(ctx context.Context, n int, keys ...string) (string, error)

	// BackupWalletFunc mocks the BackupWallet method.
	BackupWalletFunc func(ctx context.Context, dest string) error

	// BalanceFunc mocks the Balance method.
	BalanceFunc func(ctx context.Context, opts *models.OptsBalance) (float64, error)

	// DumpPrivateKeyFunc mocks the DumpPrivateKey method.
	DumpPrivateKeyFunc func(ctx context.Context, address string) (*wif.WIF, error)

	// DumpWalletFunc mocks the DumpWallet method.
	DumpWalletFunc func(ctx context.Context, dest string) (*models.DumpWallet, error)

	// EncryptWalletFunc mocks the EncryptWallet method.
	EncryptWalletFunc func(ctx context.Context, passphrase string) error

	// ImportAddressFunc mocks the ImportAddress method.
	ImportAddressFunc func(ctx context.Context, address string, opts *models.OptsImportAddress) error

	// ImportMultiFunc mocks the ImportMulti method.
	ImportMultiFunc func(ctx context.Context, reqs []models.ImportMultiRequest, opts *models.OptsImportMulti) ([]*models.ImportMulti, error)

	// ImportPrivateKeyFunc mocks the ImportPrivateKey method.
	ImportPrivateKeyFunc func(ctx context.Context, w *wif.WIF, opts *models.OptsImportPrivateKey) error

	// ImportPrunedFundsFunc mocks the ImportPrunedFunds method.
	ImportPrunedFundsFunc func(ctx context.Context, tx *bt.Tx, txOutProof string) error

	// ImportPublicKeyFunc mocks the ImportPublicKey method.
	ImportPublicKeyFunc func(ctx context.Context, publicKey string, opts *models.OptsImportPublicKey) error

	// ImportWalletFunc mocks the ImportWallet method.
	ImportWalletFunc func(ctx context.Context, filename string) error

	// KeypoolRefillFunc mocks the KeypoolRefill method.
	KeypoolRefillFunc func(ctx context.Context, opts *models.OptsKeypoolRefill) error

	// ListAccountsFunc mocks the ListAccounts method.
	ListAccountsFunc func(ctx context.Context, opts *models.OptsListAccounts) (map[string]float64, error)

	// ListLockUnspentFunc mocks the ListLockUnspent method.
	ListLockUnspentFunc func(ctx context.Context) ([]*models.LockUnspent, error)

	// ListReceivedByAccountFunc mocks the ListReceivedByAccount method.
	ListReceivedByAccountFunc func(ctx context.Context, opts *models.OptsListReceivedBy) ([]*models.ReceivedByAccount, error)

	// ListReceivedByAddressFunc mocks the ListReceivedByAddress method.
	ListReceivedByAddressFunc func(ctx context.Context, opts *models.OptsListReceivedBy) ([]*models.ReceivedByAddress, error)

	// ListSinceBlockFunc mocks the ListSinceBlock method.
	ListSinceBlockFunc func(ctx context.Context, opts *models.OptsListSinceBlock) (*models.SinceBlock, error)

	// ListTransactionsFunc mocks the ListTransactions method.
	ListTransactionsFunc func(ctx context.Context, opts *models.OptsListTransactions) ([]*models.Transaction, error)

	// ListUnspentFunc mocks the ListUnspent method.
	ListUnspentFunc func(ctx context.Context, opts *models.OptsListUnspent) (bt.UTXOs, error)

	// ListWalletsFunc mocks the ListWallets method.
	ListWalletsFunc func(ctx context.Context) ([]string, error)

	// LockUnspentFunc mocks the LockUnspent method.
	LockUnspentFunc func(ctx context.Context, lock bool, opts *models.OptsLockUnspent) (bool, error)

	// MoveFunc mocks the Move method.
	MoveFunc func(ctx context.Context, from string, to string, amount float64, opts *models.OptsMove) (bool, error)

	// NewAddressFunc mocks the NewAddress method.
	NewAddressFunc func(ctx context.Context, opts *models.OptsNewAddress) (string, error)

	// RawChangeAddressFunc mocks the RawChangeAddress method.
	RawChangeAddressFunc func(ctx context.Context) (string, error)

	// ReceivedByAddressFunc mocks the ReceivedByAddress method.
	ReceivedByAddressFunc func(ctx context.Context, address string) (float64, error)

	// RemovePrunedFundsFunc mocks the RemovePrunedFunds method.
	RemovePrunedFundsFunc func(ctx context.Context, txID string) error

	// SendFromFunc mocks the SendFrom method.
	SendFromFunc func(ctx context.Context, from string, to string, amount float64, opts *models.OptsSendFrom) (string, error)

	// SendManyFunc mocks the SendMany method.
	SendManyFunc func(ctx context.Context, from string, amounts map[string]float64, opts *models.OptsSendMany) (string, error)

	// SendToAddressFunc mocks the SendToAddress method.
	SendToAddressFunc func(ctx context.Context, address string, amount float64, opts *models.OptsSendToAddress) (string, error)

	// SetAccountFunc mocks the SetAccount method.
	SetAccountFunc func(ctx context.Context, address string, account string) error

	// SetTxFeeFunc mocks the SetTxFee method.
	SetTxFeeFunc func(ctx context.Context, amount float64) (bool, error)

	// SignMessageFunc mocks the SignMessage method.
	SignMessageFunc func(ctx context.Context, address string, message string) (string, error)

	// TransactionFunc mocks the Transaction method.
	TransactionFunc func(ctx context.Context, txID string) (*models.Transaction, error)

	// UnconfirmedBalanceFunc mocks the UnconfirmedBalance method.
	UnconfirmedBalanceFunc func(ctx context.Context) (float64, error)

	// WalletInfoFunc mocks the WalletInfo method.
	WalletInfoFunc func(ctx context.Context) (*models.WalletInfo, error)

	// WalletLockFunc mocks the WalletLock method.
	WalletLockFunc func(ctx context.Context) error

	// WalletPhassphraseFunc mocks the WalletPhassphrase method.
	WalletPhassphraseFunc func(ctx context.Context, passphrase string, timeout int) error

	// WalletPhassphraseChangeFunc mocks the WalletPhassphraseChange method.
	WalletPhassphraseChangeFunc func(ctx context.Context, oldPassphrase string, newPassphrase string) error

	// calls tracks calls to the methods.
	calls struct {
		// AbandonTransaction holds details about calls to the AbandonTransaction method.
		AbandonTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// Account holds details about calls to the Account method.
		Account []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
		}
		// AccountAddress holds details about calls to the AccountAddress method.
		AccountAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account string
		}
		// AccountAddresses holds details about calls to the AccountAddresses method.
		AccountAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account string
		}
		// AddMultiSigAddress holds details about calls to the AddMultiSigAddress method.
		AddMultiSigAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// N is the n argument value.
			N int
			// Keys is the keys argument value.
			Keys []string
		}
		// BackupWallet holds details about calls to the BackupWallet method.
		BackupWallet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dest is the dest argument value.
			Dest string
		}
		// Balance holds details about calls to the Balance method.
		Balance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsBalance
		}
		// DumpPrivateKey holds details about calls to the DumpPrivateKey method.
		DumpPrivateKey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
		}
		// DumpWallet holds details about calls to the DumpWallet method.
		DumpWallet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dest is the dest argument value.
			Dest string
		}
		// EncryptWallet holds details about calls to the EncryptWallet method.
		EncryptWallet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Passphrase is the passphrase argument value.
			Passphrase string
		}
		// ImportAddress holds details about calls to the ImportAddress method.
		ImportAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
			// Opts is the opts argument value.
			Opts *models.OptsImportAddress
		}
		// ImportMulti holds details about calls to the ImportMulti method.
		ImportMulti []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Reqs is the reqs argument value.
			Reqs []models.ImportMultiRequest
			// Opts is the opts argument value.
			Opts *models.OptsImportMulti
		}
		// ImportPrivateKey holds details about calls to the ImportPrivateKey method.
		ImportPrivateKey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// W is the w argument value.
			W *wif.WIF
			// Opts is the opts argument value.
			Opts *models.OptsImportPrivateKey
		}
		// ImportPrunedFunds holds details about calls to the ImportPrunedFunds method.
		ImportPrunedFunds []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx *bt.Tx
			// TxOutProof is the txOutProof argument value.
			TxOutProof string
		}
		// ImportPublicKey holds details about calls to the ImportPublicKey method.
		ImportPublicKey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PublicKey is the publicKey argument value.
			PublicKey string
			// Opts is the opts argument value.
			Opts *models.OptsImportPublicKey
		}
		// ImportWallet holds details about calls to the ImportWallet method.
		ImportWallet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filename is the filename argument value.
			Filename string
		}
		// KeypoolRefill holds details about calls to the KeypoolRefill method.
		KeypoolRefill []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsKeypoolRefill
		}
		// ListAccounts holds details about calls to the ListAccounts method.
		ListAccounts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsListAccounts
		}
		// ListLockUnspent holds details about calls to the ListLockUnspent method.
		ListLockUnspent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListReceivedByAccount holds details about calls to the ListReceivedByAccount method.
		ListReceivedByAccount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsListReceivedBy
		}
		// ListReceivedByAddress holds details about calls to the ListReceivedByAddress method.
		ListReceivedByAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsListReceivedBy
		}
		// ListSinceBlock holds details about calls to the ListSinceBlock method.
		ListSinceBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsListSinceBlock
		}
		// ListTransactions holds details about calls to the ListTransactions method.
		ListTransactions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsListTransactions
		}
		// ListUnspent holds details about calls to the ListUnspent method.
		ListUnspent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsListUnspent
		}
		// ListWallets holds details about calls to the ListWallets method.
		ListWallets []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// LockUnspent holds details about calls to the LockUnspent method.
		LockUnspent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Lock is the lock argument value.
			Lock bool
			// Opts is the opts argument value.
			Opts *models.OptsLockUnspent
		}
		// Move holds details about calls to the Move method.
		Move []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// From is the from argument value.
			From string
			// To is the to argument value.
			To string
			// Amount is the amount argument value.
			Amount float64
			// Opts is the opts argument value.
			Opts *models.OptsMove
		}
		// NewAddress holds details about calls to the NewAddress method.
		NewAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsNewAddress
		}
		// RawChangeAddress holds details about calls to the RawChangeAddress method.
		RawChangeAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ReceivedByAddress holds details about calls to the ReceivedByAddress method.
		ReceivedByAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
		}
		// RemovePrunedFunds holds details about calls to the RemovePrunedFunds method.
		RemovePrunedFunds []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// SendFrom holds details about calls to the SendFrom method.
		SendFrom []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// From is the from argument value.
			From string
			// To is the to argument value.
			To string
			// Amount is the amount argument value.
			Amount float64
			// Opts is the opts argument value.
			Opts *models.OptsSendFrom
		}
		// SendMany holds details about calls to the SendMany method.
		SendMany []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// From is the from argument value.
			From string
			// Amounts is the amounts argument value.
			Amounts map[string]float64
			// Opts is the opts argument value.
			Opts *models.OptsSendMany
		}
		// SendToAddress holds details about calls to the SendToAddress method.
		SendToAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
			// Amount is the amount argument value.
			Amount float64
			// Opts is the opts argument value.
			Opts *models.OptsSendToAddress
		}
		// SetAccount holds details about calls to the SetAccount method.
		SetAccount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
			// Account is the account argument value.
			Account string
		}
		// SetTxFee holds details about calls to the SetTxFee method.
		SetTxFee []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Amount is the amount argument value.
			Amount float64
		}
		// SignMessage holds details about calls to the SignMessage method.
		SignMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
			// Message is the message argument value.
			Message string
		}
		// Transaction holds details about calls to the Transaction method.
		Transaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// UnconfirmedBalance holds details about calls to the UnconfirmedBalance method.
		UnconfirmedBalance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// WalletInfo holds details about calls to the WalletInfo method.
		WalletInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// WalletLock holds details about calls to the WalletLock method.
		WalletLock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// WalletPhassphrase holds details about calls to the WalletPhassphrase method.
		WalletPhassphrase []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Passphrase is the passphrase argument value.
			Passphrase string
			// Timeout is the timeout argument value.
			Timeout int
		}
		// WalletPhassphraseChange holds details about calls to the WalletPhassphraseChange method.
		WalletPhassphraseChange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OldPassphrase is the oldPassphrase argument value.
			OldPassphrase string
			// NewPassphrase is the newPassphrase argument value.
			NewPassphrase string
		}
	}
	lockAbandonTransaction      sync.RWMutex
	lockAccount                 sync.RWMutex
	lockAccountAddress          sync.RWMutex
	lockAccountAddresses        sync.RWMutex
	lockAddMultiSigAddress      sync.RWMutex
	lockBackupWallet            sync.RWMutex
	lockBalance                 sync.RWMutex
	lockDumpPrivateKey          sync.RWMutex
	lockDumpWallet              sync.RWMutex
	lockEncryptWallet           sync.RWMutex
	lockImportAddress           sync.RWMutex
	lockImportMulti             sync.RWMutex
	lockImportPrivateKey        sync.RWMutex
	lockImportPrunedFunds       sync.RWMutex
	lockImportPublicKey         sync.RWMutex
	lockImportWallet            sync.RWMutex
	lockKeypoolRefill           sync.RWMutex
	lockListAccounts            sync.RWMutex
	lockListLockUnspent         sync.RWMutex
	lockListReceivedByAccount   sync.RWMutex
	lockListReceivedByAddress   sync.RWMutex
	lockListSinceBlock          sync.RWMutex
	lockListTransactions        sync.RWMutex
	lockListUnspent             sync.RWMutex
	lockListWallets             sync.RWMutex
	lockLockUnspent             sync.RWMutex
	lockMove                    sync.RWMutex
	lockNewAddress              sync.RWMutex
	lockRawChangeAddress        sync.RWMutex
	lockReceivedByAddress       sync.RWMutex
	lockRemovePrunedFunds       sync.RWMutex
	lockSendFrom                sync.RWMutex
	lockSendMany                sync.RWMutex
	lockSendToAddress           sync.RWMutex
	lockSetAccount              sync.RWMutex
	lockSetTxFee                sync.RWMutex
	lockSignMessage             sync.RWMutex
	lockTransaction             sync.RWMutex
	lockUnconfirmedBalance      sync.RWMutex
	lockWalletInfo              sync.RWMutex
	lockWalletLock              sync.RWMutex
	lockWalletPhassphrase       sync.RWMutex
	lockWalletPhassphraseChange sync.RWMutex
}

// AbandonTransaction calls AbandonTransactionFunc.
func (mock *WalletClientMock) AbandonTransaction(ctx context.Context, txID string) error {
	if mock.AbandonTransactionFunc == nil {
		panic("WalletClientMock.AbandonTransactionFunc: method is nil but WalletClient.AbandonTransaction was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockAbandonTransaction.Lock()
	mock.calls.AbandonTransaction = append(mock.calls.AbandonTransaction, callInfo)
	mock.lockAbandonTransaction.Unlock()
	return mock.AbandonTransactionFunc(ctx, txID)
}

// AbandonTransactionCalls gets all the calls that were made to AbandonTransaction.
// Check the length with:
//     len(mockedWalletClient.AbandonTransactionCalls())
func (mock *WalletClientMock) AbandonTransactionCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockAbandonTransaction.RLock()
	calls = mock.calls.AbandonTransaction
	mock.lockAbandonTransaction.RUnlock()
	return calls
}

// Account calls AccountFunc.
func (mock *WalletClientMock) Account(ctx context.Context, address string) (string, error) {
	if mock.AccountFunc == nil {
		panic("WalletClientMock.AccountFunc: method is nil but WalletClient.Account was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockAccount.Lock()
	mock.calls.Account = append(mock.calls.Account, callInfo)
	mock.lockAccount.Unlock()
	return mock.AccountFunc(ctx, address)
}

// AccountCalls gets all the calls that were made to Account.
// Check the length with:
//     len(mockedWalletClient.AccountCalls())
func (mock *WalletClientMock) AccountCalls() []struct {
	Ctx     context.Context
	Address string
} {
	var calls []struct {
		Ctx     context.Context
		Address string
	}
	mock.lockAccount.RLock()
	calls = mock.calls.Account
	mock.lockAccount.RUnlock()
	return calls
}

// AccountAddress calls AccountAddressFunc.
func (mock *WalletClientMock) AccountAddress(ctx context.Context, account string) (string, error) {
	if mock.AccountAddressFunc == nil {
		panic("WalletClientMock.AccountAddressFunc: method is nil but WalletClient.AccountAddress was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Account string
	}{
		Ctx:     ctx,
		Account: account,
	}
	mock.lockAccountAddress.Lock()
	mock.calls.AccountAddress = append(mock.calls.AccountAddress, callInfo)
	mock.lockAccountAddress.Unlock()
	return mock.AccountAddressFunc(ctx, account)
}

// AccountAddressCalls gets all the calls that were made to AccountAddress.
// Check the length with:
//     len(mockedWalletClient.AccountAddressCalls())
func (mock *WalletClientMock) AccountAddressCalls() []struct {
	Ctx     context.Context
	Account string
} {
	var calls []struct {
		Ctx     context.Context
		Account string
	}
	mock.lockAccountAddress.RLock()
	calls = mock.calls.AccountAddress
	mock.lockAccountAddress.RUnlock()
	return calls
}

// AccountAddresses calls AccountAddressesFunc.
func (mock *WalletClientMock) AccountAddresses(ctx context.Context, account string) ([]string, error) {
	if mock.AccountAddressesFunc == nil {
		panic("WalletClientMock.AccountAddressesFunc: method is nil but WalletClient.AccountAddresses was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Account string
	}{
		Ctx:     ctx,
		Account: account,
	}
	mock.lockAccountAddresses.Lock()
	mock.calls.AccountAddresses = append(mock.calls.AccountAddresses, callInfo)
	mock.lockAccountAddresses.Unlock()
	return mock.AccountAddressesFunc(ctx, account)
}

// AccountAddressesCalls gets all the calls that were made to AccountAddresses.
// Check the length with:
//     len(mockedWalletClient.AccountAddressesCalls())
func (mock *WalletClientMock) AccountAddressesCalls() []struct {
	Ctx     context.Context
	Account string
} {
	var calls []struct {
		Ctx     context.Context
		Account string
	}
	mock.lockAccountAddresses.RLock()
	calls = mock.calls.AccountAddresses
	mock.lockAccountAddresses.RUnlock()
	return calls
}

// AddMultiSigAddress calls AddMultiSigAddressFunc.
func (mock *WalletClientMock) AddMultiSigAddress(ctx context.Context, n int, keys ...string) (string, error) {
	if mock.AddMultiSigAddressFunc == nil {
		panic("WalletClientMock.AddMultiSigAddressFunc: method is nil but WalletClient.AddMultiSigAddress was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		N    int
		Keys []string
	}{
		Ctx:  ctx,
		N:    n,
		Keys: keys,
	}
	mock.lockAddMultiSigAddress.Lock()
	mock.calls.AddMultiSigAddress = append(mock.calls.AddMultiSigAddress, callInfo)
	mock.lockAddMultiSigAddress.Unlock()
	return mock.AddMultiSigAddressFunc(ctx, n, keys...)
}

// AddMultiSigAddressCalls gets all the calls that were made to AddMultiSigAddress.
// Check the length with:
//     len(mockedWalletClient.AddMultiSigAddressCalls())
func (mock *WalletClientMock) AddMultiSigAddressCalls() []struct {
	Ctx  context.Context
	N    int
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		N    int
		Keys []string
	}
	mock.lockAddMultiSigAddress.RLock()
	calls = mock.calls.AddMultiSigAddress
	mock.lockAddMultiSigAddress.RUnlock()
	return calls
}

// BackupWallet calls BackupWalletFunc.
func (mock *WalletClientMock) BackupWallet(ctx context.Context, dest string) error {
	if mock.BackupWalletFunc == nil {
		panic("WalletClientMock.BackupWalletFunc: method is nil but WalletClient.BackupWallet was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Dest string
	}{
		Ctx:  ctx,
		Dest: dest,
	}
	mock.lockBackupWallet.Lock()
	mock.calls.BackupWallet = append(mock.calls.BackupWallet, callInfo)
	mock.lockBackupWallet.Unlock()
	return mock.BackupWalletFunc(ctx, dest)
}

// BackupWalletCalls gets all the calls that were made to BackupWallet.
// Check the length with:
//     len(mockedWalletClient.BackupWalletCalls())
func (mock *WalletClientMock) BackupWalletCalls() []struct {
	Ctx  context.Context
	Dest string
} {
	var calls []struct {
		Ctx  context.Context
		Dest string
	}
	mock.lockBackupWallet.RLock()
	calls = mock.calls.BackupWallet
	mock.lockBackupWallet.RUnlock()
	return calls
}

// Balance calls BalanceFunc.
func (mock *WalletClientMock) Balance(ctx context.Context, opts *models.OptsBalance) (float64, error) {
	if mock.BalanceFunc == nil {
		panic("WalletClientMock.BalanceFunc: method is nil but WalletClient.Balance was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsBalance
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockBalance.Lock()
	mock.calls.Balance = append(mock.calls.Balance, callInfo)
	mock.lockBalance.Unlock()
	return mock.BalanceFunc(ctx, opts)
}

// BalanceCalls gets all the calls that were made to Balance.
// Check the length with:
//     len(mockedWalletClient.BalanceCalls())
func (mock *WalletClientMock) BalanceCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsBalance
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsBalance
	}
	mock.lockBalance.RLock()
	calls = mock.calls.Balance
	mock.lockBalance.RUnlock()
	return calls
}

// DumpPrivateKey calls DumpPrivateKeyFunc.
func (mock *WalletClientMock) DumpPrivateKey(ctx context.Context, address string) (*wif.WIF, error) {
	if mock.DumpPrivateKeyFunc == nil {
		panic("WalletClientMock.DumpPrivateKeyFunc: method is nil but WalletClient.DumpPrivateKey was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockDumpPrivateKey.Lock()
	mock.calls.DumpPrivateKey = append(mock.calls.DumpPrivateKey, callInfo)
	mock.lockDumpPrivateKey.Unlock()
	return mock.DumpPrivateKeyFunc(ctx, address)
}

// DumpPrivateKeyCalls gets all the calls that were made to DumpPrivateKey.
// Check the length with:
//     len(mockedWalletClient.DumpPrivateKeyCalls())
func (mock *WalletClientMock) DumpPrivateKeyCalls() []struct {
	Ctx     context.Context
	Address string
} {
	var calls []struct {
		Ctx     context.Context
		Address string
	}
	mock.lockDumpPrivateKey.RLock()
	calls = mock.calls.DumpPrivateKey
	mock.lockDumpPrivateKey.RUnlock()
	return calls
}

// DumpWallet calls DumpWalletFunc.
func (mock *WalletClientMock) DumpWallet(ctx context.Context, dest string) (*models.DumpWallet, error) {
	if mock.DumpWalletFunc == nil {
		panic("WalletClientMock.DumpWalletFunc: method is nil but WalletClient.DumpWallet was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Dest string
	}{
		Ctx:  ctx,
		Dest: dest,
	}
	mock.lockDumpWallet.Lock()
	mock.calls.DumpWallet = append(mock.calls.DumpWallet, callInfo)
	mock.lockDumpWallet.Unlock()
	return mock.DumpWalletFunc(ctx, dest)
}

// DumpWalletCalls gets all the calls that were made to DumpWallet.
// Check the length with:
//     len(mockedWalletClient.DumpWalletCalls())
func (mock *WalletClientMock) DumpWalletCalls() []struct {
	Ctx  context.Context
	Dest string
} {
	var calls []struct {
		Ctx  context.Context
		Dest string
	}
	mock.lockDumpWallet.RLock()
	calls = mock.calls.DumpWallet
	mock.lockDumpWallet.RUnlock()
	return calls
}

// EncryptWallet calls EncryptWalletFunc.
func (mock *WalletClientMock) EncryptWallet(ctx context.Context, passphrase string) error {
	if mock.EncryptWalletFunc == nil {
		panic("WalletClientMock.EncryptWalletFunc: method is nil but WalletClient.EncryptWallet was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Passphrase string
	}{
		Ctx:        ctx,
		Passphrase: passphrase,
	}
	mock.lockEncryptWallet.Lock()
	mock.calls.EncryptWallet = append(mock.calls.EncryptWallet, callInfo)
	mock.lockEncryptWallet.Unlock()
	return mock.EncryptWalletFunc(ctx, passphrase)
}

// EncryptWalletCalls gets all the calls that were made to EncryptWallet.
// Check the length with:
//     len(mockedWalletClient.EncryptWalletCalls())
func (mock *WalletClientMock) EncryptWalletCalls() []struct {
	Ctx        context.Context
	Passphrase string
} {
	var calls []struct {
		Ctx        context.Context
		Passphrase string
	}
	mock.lockEncryptWallet.RLock()
	calls = mock.calls.EncryptWallet
	mock.lockEncryptWallet.RUnlock()
	return calls
}

// ImportAddress calls ImportAddressFunc.
func (mock *WalletClientMock) ImportAddress(ctx context.Context, address string, opts *models.OptsImportAddress) error {
	if mock.ImportAddressFunc == nil {
		panic("WalletClientMock.ImportAddressFunc: method is nil but WalletClient.ImportAddress was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
		Opts    *models.OptsImportAddress
	}{
		Ctx:     ctx,
		Address: address,
		Opts:    opts,
	}
	mock.lockImportAddress.Lock()
	mock.calls.ImportAddress = append(mock.calls.ImportAddress, callInfo)
	mock.lockImportAddress.Unlock()
	return mock.ImportAddressFunc(ctx, address, opts)
}

// ImportAddressCalls gets all the calls that were made to ImportAddress.
// Check the length with:
//     len(mockedWalletClient.ImportAddressCalls())
func (mock *WalletClientMock) ImportAddressCalls() []struct {
	Ctx     context.Context
	Address string
	Opts    *models.OptsImportAddress
} {
	var calls []struct {
		Ctx     context.Context
		Address string
		Opts    *models.OptsImportAddress
	}
	mock.lockImportAddress.RLock()
	calls = mock.calls.ImportAddress
	mock.lockImportAddress.RUnlock()
	return calls
}

// ImportMulti calls ImportMultiFunc.
func (mock *WalletClientMock) ImportMulti(ctx context.Context, reqs []models.ImportMultiRequest, opts *models.OptsImportMulti) ([]*models.ImportMulti, error) {
	if mock.ImportMultiFunc == nil {
		panic("WalletClientMock.ImportMultiFunc: method is nil but WalletClient.ImportMulti was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Reqs []models.ImportMultiRequest
		Opts *models.OptsImportMulti
	}{
		Ctx:  ctx,
		Reqs: reqs,
		Opts: opts,
	}
	mock.lockImportMulti.Lock()
	mock.calls.ImportMulti = append(mock.calls.ImportMulti, callInfo)
	mock.lockImportMulti.Unlock()
	return mock.ImportMultiFunc(ctx, reqs, opts)
}

// ImportMultiCalls gets all the calls that were made to ImportMulti.
// Check the length with:
//     len(mockedWalletClient.ImportMultiCalls())
func (mock *WalletClientMock) ImportMultiCalls() []struct {
	Ctx  context.Context
	Reqs []models.ImportMultiRequest
	Opts *models.OptsImportMulti
} {
	var calls []struct {
		Ctx  context.Context
		Reqs []models.ImportMultiRequest
		Opts *models.OptsImportMulti
	}
	mock.lockImportMulti.RLock()
	calls = mock.calls.ImportMulti
	mock.lockImportMulti.RUnlock()
	return calls
}

// ImportPrivateKey calls ImportPrivateKeyFunc.
func (mock *WalletClientMock) ImportPrivateKey(ctx context.Context, w *wif.WIF, opts *models.OptsImportPrivateKey) error {
	if mock.ImportPrivateKeyFunc == nil {
		panic("WalletClientMock.ImportPrivateKeyFunc: method is nil but WalletClient.ImportPrivateKey was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		W    *wif.WIF
		Opts *models.OptsImportPrivateKey
	}{
		Ctx:  ctx,
		W:    w,
		Opts: opts,
	}
	mock.lockImportPrivateKey.Lock()
	mock.calls.ImportPrivateKey = append(mock.calls.ImportPrivateKey, callInfo)
	mock.lockImportPrivateKey.Unlock()
	return mock.ImportPrivateKeyFunc(ctx, w, opts)
}

// ImportPrivateKeyCalls gets all the calls that were made to ImportPrivateKey.
// Check the length with:
//     len(mockedWalletClient.ImportPrivateKeyCalls())
func (mock *WalletClientMock) ImportPrivateKeyCalls() []struct {
	Ctx  context.Context
	W    *wif.WIF
	Opts *models.OptsImportPrivateKey
} {
	var calls []struct {
		Ctx  context.Context
		W    *wif.WIF
		Opts *models.OptsImportPrivateKey
	}
	mock.lockImportPrivateKey.RLock()
	calls = mock.calls.ImportPrivateKey
	mock.lockImportPrivateKey.RUnlock()
	return calls
}

// ImportPrunedFunds calls ImportPrunedFundsFunc.
func (mock *WalletClientMock) ImportPrunedFunds(ctx context.Context, tx *bt.Tx, txOutProof string) error {
	if mock.ImportPrunedFundsFunc == nil {
		panic("WalletClientMock.ImportPrunedFundsFunc: method is nil but WalletClient.ImportPrunedFunds was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Tx         *bt.Tx
		TxOutProof string
	}{
		Ctx:        ctx,
		Tx:         tx,
		TxOutProof: txOutProof,
	}
	mock.lockImportPrunedFunds.Lock()
	mock.calls.ImportPrunedFunds = append(mock.calls.ImportPrunedFunds, callInfo)
	mock.lockImportPrunedFunds.Unlock()
	return mock.ImportPrunedFundsFunc(ctx, tx, txOutProof)
}

// ImportPrunedFundsCalls gets all the calls that were made to ImportPrunedFunds.
// Check the length with:
//     len(mockedWalletClient.ImportPrunedFundsCalls())
func (mock *WalletClientMock) ImportPrunedFundsCalls() []struct {
	Ctx        context.Context
	Tx         *bt.Tx
	TxOutProof string
} {
	var calls []struct {
		Ctx        context.Context
		Tx         *bt.Tx
		TxOutProof string
	}
	mock.lockImportPrunedFunds.RLock()
	calls = mock.calls.ImportPrunedFunds
	mock.lockImportPrunedFunds.RUnlock()
	return calls
}

// ImportPublicKey calls ImportPublicKeyFunc.
func (mock *WalletClientMock) ImportPublicKey(ctx context.Context, publicKey string, opts *models.OptsImportPublicKey) error {
	if mock.ImportPublicKeyFunc == nil {
		panic("WalletClientMock.ImportPublicKeyFunc: method is nil but WalletClient.ImportPublicKey was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		PublicKey string
		Opts      *models.OptsImportPublicKey
	}{
		Ctx:       ctx,
		PublicKey: publicKey,
		Opts:      opts,
	}
	mock.lockImportPublicKey.Lock()
	mock.calls.ImportPublicKey = append(mock.calls.ImportPublicKey, callInfo)
	mock.lockImportPublicKey.Unlock()
	return mock.ImportPublicKeyFunc(ctx, publicKey, opts)
}

// ImportPublicKeyCalls gets all the calls that were made to ImportPublicKey.
// Check the length with:
//     len(mockedWalletClient.ImportPublicKeyCalls())
func (mock *WalletClientMock) ImportPublicKeyCalls() []struct {
	Ctx       context.Context
	PublicKey string
	Opts      *models.OptsImportPublicKey
} {
	var calls []struct {
		Ctx       context.Context
		PublicKey string
		Opts      *models.OptsImportPublicKey
	}
	mock.lockImportPublicKey.RLock()
	calls = mock.calls.ImportPublicKey
	mock.lockImportPublicKey.RUnlock()
	return calls
}

// ImportWallet calls ImportWalletFunc.
func (mock *WalletClientMock) ImportWallet(ctx context.Context, filename string) error {
	if mock.ImportWalletFunc == nil {
		panic("WalletClientMock.ImportWalletFunc: method is nil but WalletClient.ImportWallet was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Filename string
	}{
		Ctx:      ctx,
		Filename: filename,
	}
	mock.lockImportWallet.Lock()
	mock.calls.ImportWallet = append(mock.calls.ImportWallet, callInfo)
	mock.lockImportWallet.Unlock()
	return mock.ImportWalletFunc(ctx, filename)
}

// ImportWalletCalls gets all the calls that were made to ImportWallet.
// Check the length with:
//     len(mockedWalletClient.ImportWalletCalls())
func (mock *WalletClientMock) ImportWalletCalls() []struct {
	Ctx      context.Context
	Filename string
} {
	var calls []struct {
		Ctx      context.Context
		Filename string
	}
	mock.lockImportWallet.RLock()
	calls = mock.calls.ImportWallet
	mock.lockImportWallet.RUnlock()
	return calls
}

// KeypoolRefill calls KeypoolRefillFunc.
func (mock *WalletClientMock) KeypoolRefill(ctx context.Context, opts *models.OptsKeypoolRefill) error {
	if mock.KeypoolRefillFunc == nil {
		panic("WalletClientMock.KeypoolRefillFunc: method is nil but WalletClient.KeypoolRefill was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsKeypoolRefill
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockKeypoolRefill.Lock()
	mock.calls.KeypoolRefill = append(mock.calls.KeypoolRefill, callInfo)
	mock.lockKeypoolRefill.Unlock()
	return mock.KeypoolRefillFunc(ctx, opts)
}

// KeypoolRefillCalls gets all the calls that were made to KeypoolRefill.
// Check the length with:
//     len(mockedWalletClient.KeypoolRefillCalls())
func (mock *WalletClientMock) KeypoolRefillCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsKeypoolRefill
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsKeypoolRefill
	}
	mock.lockKeypoolRefill.RLock()
	calls = mock.calls.KeypoolRefill
	mock.lockKeypoolRefill.RUnlock()
	return calls
}

// ListAccounts calls ListAccountsFunc.
func (mock *WalletClientMock) ListAccounts(ctx context.Context, opts *models.OptsListAccounts) (map[string]float64, error) {
	if mock.ListAccountsFunc == nil {
		panic("WalletClientMock.ListAccountsFunc: method is nil but WalletClient.ListAccounts was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsListAccounts
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockListAccounts.Lock()
	mock.calls.ListAccounts = append(mock.calls.ListAccounts, callInfo)
	mock.lockListAccounts.Unlock()
	return mock.ListAccountsFunc(ctx, opts)
}

// ListAccountsCalls gets all the calls that were made to ListAccounts.
// Check the length with:
//     len(mockedWalletClient.ListAccountsCalls())
func (mock *WalletClientMock) ListAccountsCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsListAccounts
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsListAccounts
	}
	mock.lockListAccounts.RLock()
	calls = mock.calls.ListAccounts
	mock.lockListAccounts.RUnlock()
	return calls
}

// ListLockUnspent calls ListLockUnspentFunc.
func (mock *WalletClientMock) ListLockUnspent(ctx context.Context) ([]*models.LockUnspent, error) {
	if mock.ListLockUnspentFunc == nil {
		panic("WalletClientMock.ListLockUnspentFunc: method is nil but WalletClient.ListLockUnspent was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListLockUnspent.Lock()
	mock.calls.ListLockUnspent = append(mock.calls.ListLockUnspent, callInfo)
	mock.lockListLockUnspent.Unlock()
	return mock.ListLockUnspentFunc(ctx)
}

// ListLockUnspentCalls gets all the calls that were made to ListLockUnspent.
// Check the length with:
//     len(mockedWalletClient.ListLockUnspentCalls())
func (mock *WalletClientMock) ListLockUnspentCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListLockUnspent.RLock()
	calls = mock.calls.ListLockUnspent
	mock.lockListLockUnspent.RUnlock()
	return calls
}

// ListReceivedByAccount calls ListReceivedByAccountFunc.
func (mock *WalletClientMock) ListReceivedByAccount(ctx context.Context, opts *models.OptsListReceivedBy) ([]*models.ReceivedByAccount, error) {
	if mock.ListReceivedByAccountFunc == nil {
		panic("WalletClientMock.ListReceivedByAccountFunc: method is nil but WalletClient.ListReceivedByAccount was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsListReceivedBy
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockListReceivedByAccount.Lock()
	mock.calls.ListReceivedByAccount = append(mock.calls.ListReceivedByAccount, callInfo)
	mock.lockListReceivedByAccount.Unlock()
	return mock.ListReceivedByAccountFunc(ctx, opts)
}

// ListReceivedByAccountCalls gets all the calls that were made to ListReceivedByAccount.
// Check the length with:
//     len(mockedWalletClient.ListReceivedByAccountCalls())
func (mock *WalletClientMock) ListReceivedByAccountCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsListReceivedBy
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsListReceivedBy
	}
	mock.lockListReceivedByAccount.RLock()
	calls = mock.calls.ListReceivedByAccount
	mock.lockListReceivedByAccount.RUnlock()
	return calls
}

// ListReceivedByAddress calls ListReceivedByAddressFunc.
func (mock *WalletClientMock) ListReceivedByAddress(ctx context.Context, opts *models.OptsListReceivedBy) ([]*models.ReceivedByAddress, error) {
	if mock.ListReceivedByAddressFunc == nil {
		panic("WalletClientMock.ListReceivedByAddressFunc: method is nil but WalletClient.ListReceivedByAddress was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsListReceivedBy
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockListReceivedByAddress.Lock()
	mock.calls.ListReceivedByAddress = append(mock.calls.ListReceivedByAddress, callInfo)
	mock.lockListReceivedByAddress.Unlock()
	return mock.ListReceivedByAddressFunc(ctx, opts)
}

// ListReceivedByAddressCalls gets all the calls that were made to ListReceivedByAddress.
// Check the length with:
//     len(mockedWalletClient.ListReceivedByAddressCalls())
func (mock *WalletClientMock) ListReceivedByAddressCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsListReceivedBy
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsListReceivedBy
	}
	mock.lockListReceivedByAddress.RLock()
	calls = mock.calls.ListReceivedByAddress
	mock.lockListReceivedByAddress.RUnlock()
	return calls
}

// ListSinceBlock calls ListSinceBlockFunc.
func (mock *WalletClientMock) ListSinceBlock(ctx context.Context, opts *models.OptsListSinceBlock) (*models.SinceBlock, error) {
	if mock.ListSinceBlockFunc == nil {
		panic("WalletClientMock.ListSinceBlockFunc: method is nil but WalletClient.ListSinceBlock was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsListSinceBlock
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockListSinceBlock.Lock()
	mock.calls.ListSinceBlock = append(mock.calls.ListSinceBlock, callInfo)
	mock.lockListSinceBlock.Unlock()
	return mock.ListSinceBlockFunc(ctx, opts)
}

// ListSinceBlockCalls gets all the calls that were made to ListSinceBlock.
// Check the length with:
//     len(mockedWalletClient.ListSinceBlockCalls())
func (mock *WalletClientMock) ListSinceBlockCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsListSinceBlock
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsListSinceBlock
	}
	mock.lockListSinceBlock.RLock()
	calls = mock.calls.ListSinceBlock
	mock.lockListSinceBlock.RUnlock()
	return calls
}

// ListTransactions calls ListTransactionsFunc.
func (mock *WalletClientMock) ListTransactions(ctx context.Context, opts *models.OptsListTransactions) ([]*models.Transaction, error) {
	if mock.ListTransactionsFunc == nil {
		panic("WalletClientMock.ListTransactionsFunc: method is nil but WalletClient.ListTransactions was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsListTransactions
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockListTransactions.Lock()
	mock.calls.ListTransactions = append(mock.calls.ListTransactions, callInfo)
	mock.lockListTransactions.Unlock()
	return mock.ListTransactionsFunc(ctx, opts)
}

// ListTransactionsCalls gets all the calls that were made to ListTransactions.
// Check the length with:
//     len(mockedWalletClient.ListTransactionsCalls())
func (mock *WalletClientMock) ListTransactionsCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsListTransactions
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsListTransactions
	}
	mock.lockListTransactions.RLock()
	calls = mock.calls.ListTransactions
	mock.lockListTransactions.RUnlock()
	return calls
}

// ListUnspent calls ListUnspentFunc.
func (mock *WalletClientMock) ListUnspent(ctx context.Context, opts *models.OptsListUnspent) (bt.UTXOs, error) {
	if mock.ListUnspentFunc == nil {
		panic("WalletClientMock.ListUnspentFunc: method is nil but WalletClient.ListUnspent was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsListUnspent
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockListUnspent.Lock()
	mock.calls.ListUnspent = append(mock.calls.ListUnspent, callInfo)
	mock.lockListUnspent.Unlock()
	return mock.ListUnspentFunc(ctx, opts)
}

// ListUnspentCalls gets all the calls that were made to ListUnspent.
// Check the length with:
//     len(mockedWalletClient.ListUnspentCalls())
func (mock *WalletClientMock) ListUnspentCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsListUnspent
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsListUnspent
	}
	mock.lockListUnspent.RLock()
	calls = mock.calls.ListUnspent
	mock.lockListUnspent.RUnlock()
	return calls
}

// ListWallets calls ListWalletsFunc.
func (mock *WalletClientMock) ListWallets(ctx context.Context) ([]string, error) {
	if mock.ListWalletsFunc == nil {
		panic("WalletClientMock.ListWalletsFunc: method is nil but WalletClient.ListWallets was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListWallets.Lock()
	mock.calls.ListWallets = append(mock.calls.ListWallets, callInfo)
	mock.lockListWallets.Unlock()
	return mock.ListWalletsFunc(ctx)
}

// ListWalletsCalls gets all the calls that were made to ListWallets.
// Check the length with:
//     len(mockedWalletClient.ListWalletsCalls())
func (mock *WalletClientMock) ListWalletsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListWallets.RLock()
	calls = mock.calls.ListWallets
	mock.lockListWallets.RUnlock()
	return calls
}

// LockUnspent calls LockUnspentFunc.
func (mock *WalletClientMock) LockUnspent(ctx context.Context, lock bool, opts *models.OptsLockUnspent) (bool, error) {
	if mock.LockUnspentFunc == nil {
		panic("WalletClientMock.LockUnspentFunc: method is nil but WalletClient.LockUnspent was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Lock bool
		Opts *models.OptsLockUnspent
	}{
		Ctx:  ctx,
		Lock: lock,
		Opts: opts,
	}
	mock.lockLockUnspent.Lock()
	mock.calls.LockUnspent = append(mock.calls.LockUnspent, callInfo)
	mock.lockLockUnspent.Unlock()
	return mock.LockUnspentFunc(ctx, lock, opts)
}

// LockUnspentCalls gets all the calls that were made to LockUnspent.
// Check the length with:
//     len(mockedWalletClient.LockUnspentCalls())
func (mock *WalletClientMock) LockUnspentCalls() []struct {
	Ctx  context.Context
	Lock bool
	Opts *models.OptsLockUnspent
} {
	var calls []struct {
		Ctx  context.Context
		Lock bool
		Opts *models.OptsLockUnspent
	}
	mock.lockLockUnspent.RLock()
	calls = mock.calls.LockUnspent
	mock.lockLockUnspent.RUnlock()
	return calls
}

// Move calls MoveFunc.
func (mock *WalletClientMock) Move(ctx context.Context, from string, to string, amount float64, opts *models.OptsMove) (bool, error) {
	if mock.MoveFunc == nil {
		panic("WalletClientMock.MoveFunc: method is nil but WalletClient.Move was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		From   string
		To     string
		Amount float64
		Opts   *models.OptsMove
	}{
		Ctx:    ctx,
		From:   from,
		To:     to,
		Amount: amount,
		Opts:   opts,
	}
	mock.lockMove.Lock()
	mock.calls.Move = append(mock.calls.Move, callInfo)
	mock.lockMove.Unlock()
	return mock.MoveFunc(ctx, from, to, amount, opts)
}

// MoveCalls gets all the calls that were made to Move.
// Check the length with:
//     len(mockedWalletClient.MoveCalls())
func (mock *WalletClientMock) MoveCalls() []struct {
	Ctx    context.Context
	From   string
	To     string
	Amount float64
	Opts   *models.OptsMove
} {
	var calls []struct {
		Ctx    context.Context
		From   string
		To     string
		Amount float64
		Opts   *models.OptsMove
	}
	mock.lockMove.RLock()
	calls = mock.calls.Move
	mock.lockMove.RUnlock()
	return calls
}

// NewAddress calls NewAddressFunc.
func (mock *WalletClientMock) NewAddress(ctx context.Context, opts *models.OptsNewAddress) (string, error) {
	if mock.NewAddressFunc == nil {
		panic("WalletClientMock.NewAddressFunc: method is nil but WalletClient.NewAddress was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsNewAddress
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockNewAddress.Lock()
	mock.calls.NewAddress = append(mock.calls.NewAddress, callInfo)
	mock.lockNewAddress.Unlock()
	return mock.NewAddressFunc(ctx, opts)
}

// NewAddressCalls gets all the calls that were made to NewAddress.
// Check the length with:
//     len(mockedWalletClient.NewAddressCalls())
func (mock *WalletClientMock) NewAddressCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsNewAddress
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsNewAddress
	}
	mock.lockNewAddress.RLock()
	calls = mock.calls.NewAddress
	mock.lockNewAddress.RUnlock()
	return calls
}

// RawChangeAddress calls RawChangeAddressFunc.
func (mock *WalletClientMock) RawChangeAddress(ctx context.Context) (string, error) {
	if mock.RawChangeAddressFunc == nil {
		panic("WalletClientMock.RawChangeAddressFunc: method is nil but WalletClient.RawChangeAddress was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRawChangeAddress.Lock()
	mock.calls.RawChangeAddress = append(mock.calls.RawChangeAddress, callInfo)
	mock.lockRawChangeAddress.Unlock()
	return mock.RawChangeAddressFunc(ctx)
}

// RawChangeAddressCalls gets all the calls that were made to RawChangeAddress.
// Check the length with:
//     len(mockedWalletClient.RawChangeAddressCalls())
func (mock *WalletClientMock) RawChangeAddressCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRawChangeAddress.RLock()
	calls = mock.calls.RawChangeAddress
	mock.lockRawChangeAddress.RUnlock()
	return calls
}

// ReceivedByAddress calls ReceivedByAddressFunc.
func (mock *WalletClientMock) ReceivedByAddress(ctx context.Context, address string) (float64, error) {
	if mock.ReceivedByAddressFunc == nil {
		panic("WalletClientMock.ReceivedByAddressFunc: method is nil but WalletClient.ReceivedByAddress was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockReceivedByAddress.Lock()
	mock.calls.ReceivedByAddress = append(mock.calls.ReceivedByAddress, callInfo)
	mock.lockReceivedByAddress.Unlock()
	return mock.ReceivedByAddressFunc(ctx, address)
}

// ReceivedByAddressCalls gets all the calls that were made to ReceivedByAddress.
// Check the length with:
//     len(mockedWalletClient.ReceivedByAddressCalls())
func (mock *WalletClientMock) ReceivedByAddressCalls() []struct {
	Ctx     context.Context
	Address string
} {
	var calls []struct {
		Ctx     context.Context
		Address string
	}
	mock.lockReceivedByAddress.RLock()
	calls = mock.calls.ReceivedByAddress
	mock.lockReceivedByAddress.RUnlock()
	return calls
}

// RemovePrunedFunds calls RemovePrunedFundsFunc.
func (mock *WalletClientMock) RemovePrunedFunds(ctx context.Context, txID string) error {
	if mock.RemovePrunedFundsFunc == nil {
		panic("WalletClientMock.RemovePrunedFundsFunc: method is nil but WalletClient.RemovePrunedFunds was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockRemovePrunedFunds.Lock()
	mock.calls.RemovePrunedFunds = append(mock.calls.RemovePrunedFunds, callInfo)
	mock.lockRemovePrunedFunds.Unlock()
	return mock.RemovePrunedFundsFunc(ctx, txID)
}

// RemovePrunedFundsCalls gets all the calls that were made to RemovePrunedFunds.
// Check the length with:
//     len(mockedWalletClient.RemovePrunedFundsCalls())
func (mock *WalletClientMock) RemovePrunedFundsCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockRemovePrunedFunds.RLock()
	calls = mock.calls.RemovePrunedFunds
	mock.lockRemovePrunedFunds.RUnlock()
	return calls
}

// SendFrom calls SendFromFunc.
func (mock *WalletClientMock) SendFrom(ctx context.Context, from string, to string, amount float64, opts *models.OptsSendFrom) (string, error) {
	if mock.SendFromFunc == nil {
		panic("WalletClientMock.SendFromFunc: method is nil but WalletClient.SendFrom was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		From   string
		To     string
		Amount float64
		Opts   *models.OptsSendFrom
	}{
		Ctx:    ctx,
		From:   from,
		To:     to,
		Amount: amount,
		Opts:   opts,
	}
	mock.lockSendFrom.Lock()
	mock.calls.SendFrom = append(mock.calls.SendFrom, callInfo)
	mock.lockSendFrom.Unlock()
	return mock.SendFromFunc(ctx, from, to, amount, opts)
}

// SendFromCalls gets all the calls that were made to SendFrom.
// Check the length with:
//     len(mockedWalletClient.SendFromCalls())
func (mock *WalletClientMock) SendFromCalls() []struct {
	Ctx    context.Context
	From   string
	To     string
	Amount float64
	Opts   *models.OptsSendFrom
} {
	var calls []struct {
		Ctx    context.Context
		From   string
		To     string
		Amount float64
		Opts   *models.OptsSendFrom
	}
	mock.lockSendFrom.RLock()
	calls = mock.calls.SendFrom
	mock.lockSendFrom.RUnlock()
	return calls
}

// SendMany calls SendManyFunc.
func (mock *WalletClientMock) SendMany(ctx context.Context, from string, amounts map[string]float64, opts *models.OptsSendMany) (string, error) {
	if mock.SendManyFunc == nil {
		panic("WalletClientMock.SendManyFunc: method is nil but WalletClient.SendMany was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		From    string
		Amounts map[string]float64
		Opts    *models.OptsSendMany
	}{
		Ctx:     ctx,
		From:    from,
		Amounts: amounts,
		Opts:    opts,
	}
	mock.lockSendMany.Lock()
	mock.calls.SendMany = append(mock.calls.SendMany, callInfo)
	mock.lockSendMany.Unlock()
	return mock.SendManyFunc(ctx, from, amounts, opts)
}

// SendManyCalls gets all the calls that were made to SendMany.
// Check the length with:
//     len(mockedWalletClient.SendManyCalls())
func (mock *WalletClientMock) SendManyCalls() []struct {
	Ctx     context.Context
	From    string
	Amounts map[string]float64
	Opts    *models.OptsSendMany
} {
	var calls []struct {
		Ctx     context.Context
		From    string
		Amounts map[string]float64
		Opts    *models.OptsSendMany
	}
	mock.lockSendMany.RLock()
	calls = mock.calls.SendMany
	mock.lockSendMany.RUnlock()
	return calls
}

// SendToAddress calls SendToAddressFunc.
func (mock *WalletClientMock) SendToAddress(ctx context.Context, address string, amount float64, opts *models.OptsSendToAddress) (string, error) {
	if mock.SendToAddressFunc == nil {
		panic("WalletClientMock.SendToAddressFunc: method is nil but WalletClient.SendToAddress was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
		Amount  float64
		Opts    *models.OptsSendToAddress
	}{
		Ctx:     ctx,
		Address: address,
		Amount:  amount,
		Opts:    opts,
	}
	mock.lockSendToAddress.Lock()
	mock.calls.SendToAddress = append(mock.calls.SendToAddress, callInfo)
	mock.lockSendToAddress.Unlock()
	return mock.SendToAddressFunc(ctx, address, amount, opts)
}

// SendToAddressCalls gets all the calls that were made to SendToAddress.
// Check the length with:
//     len(mockedWalletClient.SendToAddressCalls())
func (mock *WalletClientMock) SendToAddressCalls() []struct {
	Ctx     context.Context
	Address string
	Amount  float64
	Opts    *models.OptsSendToAddress
} {
	var calls []struct {
		Ctx     context.Context
		Address string
		Amount  float64
		Opts    *models.OptsSendToAddress
	}
	mock.lockSendToAddress.RLock()
	calls = mock.calls.SendToAddress
	mock.lockSendToAddress.RUnlock()
	return calls
}

// SetAccount calls SetAccountFunc.
func (mock *WalletClientMock) SetAccount(ctx context.Context, address string, account string) error {
	if mock.SetAccountFunc == nil {
		panic("WalletClientMock.SetAccountFunc: method is nil but WalletClient.SetAccount was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
		Account string
	}{
		Ctx:     ctx,
		Address: address,
		Account: account,
	}
	mock.lockSetAccount.Lock()
	mock.calls.SetAccount = append(mock.calls.SetAccount, callInfo)
	mock.lockSetAccount.Unlock()
	return mock.SetAccountFunc(ctx, address, account)
}

// SetAccountCalls gets all the calls that were made to SetAccount.
// Check the length with:
//     len(mockedWalletClient.SetAccountCalls())
func (mock *WalletClientMock) SetAccountCalls() []struct {
	Ctx     context.Context
	Address string
	Account string
} {
	var calls []struct {
		Ctx     context.Context
		Address string
		Account string
	}
	mock.lockSetAccount.RLock()
	calls = mock.calls.SetAccount
	mock.lockSetAccount.RUnlock()
	return calls
}

// SetTxFee calls SetTxFeeFunc.
func (mock *WalletClientMock) SetTxFee(ctx context.Context, amount float64) (bool, error) {
	if mock.SetTxFeeFunc == nil {
		panic("WalletClientMock.SetTxFeeFunc: method is nil but WalletClient.SetTxFee was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Amount float64
	}{
		Ctx:    ctx,
		Amount: amount,
	}
	mock.lockSetTxFee.Lock()
	mock.calls.SetTxFee = append(mock.calls.SetTxFee, callInfo)
	mock.lockSetTxFee.Unlock()
	return mock.SetTxFeeFunc(ctx, amount)
}

// SetTxFeeCalls gets all the calls that were made to SetTxFee.
// Check the length with:
//     len(mockedWalletClient.SetTxFeeCalls())
func (mock *WalletClientMock) SetTxFeeCalls() []struct {
	Ctx    context.Context
	Amount float64
} {
	var calls []struct {
		Ctx    context.Context
		Amount float64
	}
	mock.lockSetTxFee.RLock()
	calls = mock.calls.SetTxFee
	mock.lockSetTxFee.RUnlock()
	return calls
}

// SignMessage calls SignMessageFunc.
func (mock *WalletClientMock) SignMessage(ctx context.Context, address string, message string) (string, error) {
	if mock.SignMessageFunc == nil {
		panic("WalletClientMock.SignMessageFunc: method is nil but WalletClient.SignMessage was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
		Message string
	}{
		Ctx:     ctx,
		Address: address,
		Message: message,
	}
	mock.lockSignMessage.Lock()
	mock.calls.SignMessage = append(mock.calls.SignMessage, callInfo)
	mock.lockSignMessage.Unlock()
	return mock.SignMessageFunc(ctx, address, message)
}

// SignMessageCalls gets all the calls that were made to SignMessage.
// Check the length with:
//     len(mockedWalletClient.SignMessageCalls())
func (mock *WalletClientMock) SignMessageCalls() []struct {
	Ctx     context.Context
	Address string
	Message string
} {
	var calls []struct {
		Ctx     context.Context
		Address string
		Message string
	}
	mock.lockSignMessage.RLock()
	calls = mock.calls.SignMessage
	mock.lockSignMessage.RUnlock()
	return calls
}

// Transaction calls TransactionFunc.
func (mock *WalletClientMock) Transaction(ctx context.Context, txID string) (*models.Transaction, error) {
	if mock.TransactionFunc == nil {
		panic("WalletClientMock.TransactionFunc: method is nil but WalletClient.Transaction was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockTransaction.Lock()
	mock.calls.Transaction = append(mock.calls.Transaction, callInfo)
	mock.lockTransaction.Unlock()
	return mock.TransactionFunc(ctx, txID)
}

// TransactionCalls gets all the calls that were made to Transaction.
// Check the length with:
//     len(mockedWalletClient.TransactionCalls())
func (mock *WalletClientMock) TransactionCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockTransaction.RLock()
	calls = mock.calls.Transaction
	mock.lockTransaction.RUnlock()
	return calls
}

// UnconfirmedBalance calls UnconfirmedBalanceFunc.
func (mock *WalletClientMock) UnconfirmedBalance(ctx context.Context) (float64, error) {
	if mock.UnconfirmedBalanceFunc == nil {
		panic("WalletClientMock.UnconfirmedBalanceFunc: method is nil but WalletClient.UnconfirmedBalance was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockUnconfirmedBalance.Lock()
	mock.calls.UnconfirmedBalance = append(mock.calls.UnconfirmedBalance, callInfo)
	mock.lockUnconfirmedBalance.Unlock()
	return mock.UnconfirmedBalanceFunc(ctx)
}

// UnconfirmedBalanceCalls gets all the calls that were made to UnconfirmedBalance.
// Check the length with:
//     len(mockedWalletClient.UnconfirmedBalanceCalls())
func (mock *WalletClientMock) UnconfirmedBalanceCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockUnconfirmedBalance.RLock()
	calls = mock.calls.UnconfirmedBalance
	mock.lockUnconfirmedBalance.RUnlock()
	return calls
}

// WalletInfo calls WalletInfoFunc.
func (mock *WalletClientMock) WalletInfo(ctx context.Context) (*models.WalletInfo, error) {
	if mock.WalletInfoFunc == nil {
		panic("WalletClientMock.WalletInfoFunc: method is nil but WalletClient.WalletInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockWalletInfo.Lock()
	mock.calls.WalletInfo = append(mock.calls.WalletInfo, callInfo)
	mock.lockWalletInfo.Unlock()
	return mock.WalletInfoFunc(ctx)
}

// WalletInfoCalls gets all the calls that were made to WalletInfo.
// Check the length with:
//     len(mockedWalletClient.WalletInfoCalls())
func (mock *WalletClientMock) WalletInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockWalletInfo.RLock()
	calls = mock.calls.WalletInfo
	mock.lockWalletInfo.RUnlock()
	return calls
}

// WalletLock calls WalletLockFunc.
func (mock *WalletClientMock) WalletLock(ctx context.Context) error {
	if mock.WalletLockFunc == nil {
		panic("WalletClientMock.WalletLockFunc: method is nil but WalletClient.WalletLock was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockWalletLock.Lock()
	mock.calls.WalletLock = append(mock.calls.WalletLock, callInfo)
	mock.lockWalletLock.Unlock()
	return mock.WalletLockFunc(ctx)
}

// WalletLockCalls gets all the calls that were made to WalletLock.
// Check the length with:
//     len(mockedWalletClient.WalletLockCalls())
func (mock *WalletClientMock) WalletLockCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockWalletLock.RLock()
	calls = mock.calls.WalletLock
	mock.lockWalletLock.RUnlock()
	return calls
}

// WalletPhassphrase calls WalletPhassphraseFunc.
func (mock *WalletClientMock) WalletPhassphrase(ctx context.Context, passphrase string, timeout int) error {
	if mock.WalletPhassphraseFunc == nil {
		panic("WalletClientMock.WalletPhassphraseFunc: method is nil but WalletClient.WalletPhassphrase was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Passphrase string
		Timeout    int
	}{
		Ctx:        ctx,
		Passphrase: passphrase,
		Timeout:    timeout,
	}
	mock.lockWalletPhassphrase.Lock()
	mock.calls.WalletPhassphrase = append(mock.calls.WalletPhassphrase, callInfo)
	mock.lockWalletPhassphrase.Unlock()
	return mock.WalletPhassphraseFunc(ctx, passphrase, timeout)
}

// WalletPhassphraseCalls gets all the calls that were made to WalletPhassphrase.
// Check the length with:
//     len(mockedWalletClient.WalletPhassphraseCalls())
func (mock *WalletClientMock) WalletPhassphraseCalls() []struct {
	Ctx        context.Context
	Passphrase string
	Timeout    int
} {
	var calls []struct {
		Ctx        context.Context
		Passphrase string
		Timeout    int
	}
	mock.lockWalletPhassphrase.RLock()
	calls = mock.calls.WalletPhassphrase
	mock.lockWalletPhassphrase.RUnlock()
	return calls
}

// WalletPhassphraseChange calls WalletPhassphraseChangeFunc.
func (mock *WalletClientMock) WalletPhassphraseChange(ctx context.Context, oldPassphrase string, newPassphrase string) error {
	if mock.WalletPhassphraseChangeFunc == nil {
		panic("WalletClientMock.WalletPhassphraseChangeFunc: method is nil but WalletClient.WalletPhassphraseChange was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		OldPassphrase string
		NewPassphrase string
	}{
		Ctx:           ctx,
		OldPassphrase: oldPassphrase,
		NewPassphrase: newPassphrase,
	}
	mock.lockWalletPhassphraseChange.Lock()
	mock.calls.WalletPhassphraseChange = append(mock.calls.WalletPhassphraseChange, callInfo)
	mock.lockWalletPhassphraseChange.Unlock()
	return mock.WalletPhassphraseChangeFunc(ctx, oldPassphrase, newPassphrase)
}

// WalletPhassphraseChangeCalls gets all the calls that were made to WalletPhassphraseChange.
// Check the length with:
//     len(mockedWalletClient.WalletPhassphraseChangeCalls())
func (mock *WalletClientMock) WalletPhassphraseChangeCalls() []struct {
	Ctx           context.Context
	OldPassphrase string
	NewPassphrase string
} {
	var calls []struct {
		Ctx           context.Context
		OldPassphrase string
		NewPassphrase string
	}
	mock.lockWalletPhassphraseChange.RLock()
	calls = mock.calls.WalletPhassphraseChange
	mock.lockWalletPhassphraseChange.RUnlock()
	return calls
}

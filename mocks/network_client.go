// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/libsv/go-bn"
	"github.com/libsv/go-bn/internal"
	"github.com/libsv/go-bn/models"
	"sync"
)

// Ensure, that NetworkClientMock does implement bn.NetworkClient.
// If this is not the case, regenerate this file with moq.
var _ bn.NetworkClient = &NetworkClientMock{}

// NetworkClientMock is a mock implementation of bn.NetworkClient.
//
// 	func TestSomethingThatUsesNetworkClient(t *testing.T) {
//
// 		// make and configure a mocked bn.NetworkClient
// 		mockedNetworkClient := &NetworkClientMock{
// 			AddNodeFunc: func(ctx context.Context, node string, command internal.NodeAddType) error {
// 				panic("mock out the AddNode method")
// 			},
// 			ClearBannedFunc: func(ctx context.Context) error {
// 				panic("mock out the ClearBanned method")
// 			},
// 			ConnectionCountFunc: func(ctx context.Context) (uint64, error) {
// 				panic("mock out the ConnectionCount method")
// 			},
// 			DisconnectNodeFunc: func(ctx context.Context, params models.ParamsDisconnectNode) error {
// 				panic("mock out the DisconnectNode method")
// 			},
// 			ExcessiveBlockFunc: func(ctx context.Context) (*models.ExcessiveBlock, error) {
// 				panic("mock out the ExcessiveBlock method")
// 			},
// 			ListBannedFunc: func(ctx context.Context) ([]*models.BannedSubnet, error) {
// 				panic("mock out the ListBanned method")
// 			},
// 			NetworkInfoFunc: func(ctx context.Context) (*models.NetworkInfo, error) {
// 				panic("mock out the NetworkInfo method")
// 			},
// 			NetworkTotalsFunc: func(ctx context.Context) (*models.NetworkTotals, error) {
// 				panic("mock out the NetworkTotals method")
// 			},
// 			NodeInfoFunc: func(ctx context.Context, opts *models.OptsNodeInfo) ([]*models.NodeInfo, error) {
// 				panic("mock out the NodeInfo method")
// 			},
// 			PeerInfoFunc: func(ctx context.Context) ([]*models.PeerInfo, error) {
// 				panic("mock out the PeerInfo method")
// 			},
// 			PingFunc: func(ctx context.Context) error {
// 				panic("mock out the Ping method")
// 			},
// 			SetBanFunc: func(ctx context.Context, subnet string, action internal.BanAction, opts *models.OptsSetBan) error {
// 				panic("mock out the SetBan method")
// 			},
// 			SetBlockMaxSizeFunc: func(ctx context.Context, size uint64) (string, error) {
// 				panic("mock out the SetBlockMaxSize method")
// 			},
// 			SetExcessiveBlockFunc: func(ctx context.Context, size uint64) (string, error) {
// 				panic("mock out the SetExcessiveBlock method")
// 			},
// 			SetNetworkActiveFunc: func(ctx context.Context, enabled bool) error {
// 				panic("mock out the SetNetworkActive method")
// 			},
// 			SetTxPropagationFrequencyFunc: func(ctx context.Context, frequency uint64) error {
// 				panic("mock out the SetTxPropagationFrequency method")
// 			},
// 		}
//
// 		// use mockedNetworkClient in code that requires bn.NetworkClient
// 		// and then make assertions.
//
// 	}
type NetworkClientMock struct {
	// AddNodeFunc mocks the AddNode method.
	AddNodeFunc func(ctx context.Context, node string, command internal.NodeAddType) error

	// ClearBannedFunc mocks the ClearBanned method.
	ClearBannedFunc func(ctx context.Context) error

	// ConnectionCountFunc mocks the ConnectionCount method.
	ConnectionCountFunc func(ctx context.Context) (uint64, error)

	// DisconnectNodeFunc mocks the DisconnectNode method.
	DisconnectNodeFunc func(ctx context.Context, params models.ParamsDisconnectNode) error

	// ExcessiveBlockFunc mocks the ExcessiveBlock method.
	ExcessiveBlockFunc func(ctx context.Context) (*models.ExcessiveBlock, error)

	// ListBannedFunc mocks the ListBanned method.
	ListBannedFunc func(ctx context.Context) ([]*models.BannedSubnet, error)

	// NetworkInfoFunc mocks the NetworkInfo method.
	NetworkInfoFunc func(ctx context.Context) (*models.NetworkInfo, error)

	// NetworkTotalsFunc mocks the NetworkTotals method.
	NetworkTotalsFunc func(ctx context.Context) (*models.NetworkTotals, error)

	// NodeInfoFunc mocks the NodeInfo method.
	NodeInfoFunc func(ctx context.Context, opts *models.OptsNodeInfo) ([]*models.NodeInfo, error)

	// PeerInfoFunc mocks the PeerInfo method.
	PeerInfoFunc func(ctx context.Context) ([]*models.PeerInfo, error)

	// PingFunc mocks the Ping method.
	PingFunc func(ctx context.Context) error

	// SetBanFunc mocks the SetBan method.
	SetBanFunc func(ctx context.Context, subnet string, action internal.BanAction, opts *models.OptsSetBan) error

	// SetBlockMaxSizeFunc mocks the SetBlockMaxSize method.
	SetBlockMaxSizeFunc func(ctx context.Context, size uint64) (string, error)

	// SetExcessiveBlockFunc mocks the SetExcessiveBlock method.
	SetExcessiveBlockFunc func(ctx context.Context, size uint64) (string, error)

	// SetNetworkActiveFunc mocks the SetNetworkActive method.
	SetNetworkActiveFunc func(ctx context.Context, enabled bool) error

	// SetTxPropagationFrequencyFunc mocks the SetTxPropagationFrequency method.
	SetTxPropagationFrequencyFunc func(ctx context.Context, frequency uint64) error

	// calls tracks calls to the methods.
	calls struct {
		// AddNode holds details about calls to the AddNode method.
		AddNode []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Node is the node argument value.
			Node string
			// Command is the command argument value.
			Command internal.NodeAddType
		}
		// ClearBanned holds details about calls to the ClearBanned method.
		ClearBanned []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ConnectionCount holds details about calls to the ConnectionCount method.
		ConnectionCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// DisconnectNode holds details about calls to the DisconnectNode method.
		DisconnectNode []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params models.ParamsDisconnectNode
		}
		// ExcessiveBlock holds details about calls to the ExcessiveBlock method.
		ExcessiveBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListBanned holds details about calls to the ListBanned method.
		ListBanned []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// NetworkInfo holds details about calls to the NetworkInfo method.
		NetworkInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// NetworkTotals holds details about calls to the NetworkTotals method.
		NetworkTotals []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// NodeInfo holds details about calls to the NodeInfo method.
		NodeInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsNodeInfo
		}
		// PeerInfo holds details about calls to the PeerInfo method.
		PeerInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Ping holds details about calls to the Ping method.
		Ping []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SetBan holds details about calls to the SetBan method.
		SetBan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Subnet is the subnet argument value.
			Subnet string
			// Action is the action argument value.
			Action internal.BanAction
			// Opts is the opts argument value.
			Opts *models.OptsSetBan
		}
		// SetBlockMaxSize holds details about calls to the SetBlockMaxSize method.
		SetBlockMaxSize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Size is the size argument value.
			Size uint64
		}
		// SetExcessiveBlock holds details about calls to the SetExcessiveBlock method.
		SetExcessiveBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Size is the size argument value.
			Size uint64
		}
		// SetNetworkActive holds details about calls to the SetNetworkActive method.
		SetNetworkActive []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Enabled is the enabled argument value.
			Enabled bool
		}
		// SetTxPropagationFrequency holds details about calls to the SetTxPropagationFrequency method.
		SetTxPropagationFrequency []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Frequency is the frequency argument value.
			Frequency uint64
		}
	}
	lockAddNode                   sync.RWMutex
	lockClearBanned               sync.RWMutex
	lockConnectionCount           sync.RWMutex
	lockDisconnectNode            sync.RWMutex
	lockExcessiveBlock            sync.RWMutex
	lockListBanned                sync.RWMutex
	lockNetworkInfo               sync.RWMutex
	lockNetworkTotals             sync.RWMutex
	lockNodeInfo                  sync.RWMutex
	lockPeerInfo                  sync.RWMutex
	lockPing                      sync.RWMutex
	lockSetBan                    sync.RWMutex
	lockSetBlockMaxSize           sync.RWMutex
	lockSetExcessiveBlock         sync.RWMutex
	lockSetNetworkActive          sync.RWMutex
	lockSetTxPropagationFrequency sync.RWMutex
}

// AddNode calls AddNodeFunc.
func (mock *NetworkClientMock) AddNode(ctx context.Context, node string, command internal.NodeAddType) error {
	if mock.AddNodeFunc == nil {
		panic("NetworkClientMock.AddNodeFunc: method is nil but NetworkClient.AddNode was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Node    string
		Command internal.NodeAddType
	}{
		Ctx:     ctx,
		Node:    node,
		Command: command,
	}
	mock.lockAddNode.Lock()
	mock.calls.AddNode = append(mock.calls.AddNode, callInfo)
	mock.lockAddNode.Unlock()
	return mock.AddNodeFunc(ctx, node, command)
}

// AddNodeCalls gets all the calls that were made to AddNode.
// Check the length with:
//     len(mockedNetworkClient.AddNodeCalls())
func (mock *NetworkClientMock) AddNodeCalls() []struct {
	Ctx     context.Context
	Node    string
	Command internal.NodeAddType
} {
	var calls []struct {
		Ctx     context.Context
		Node    string
		Command internal.NodeAddType
	}
	mock.lockAddNode.RLock()
	calls = mock.calls.AddNode
	mock.lockAddNode.RUnlock()
	return calls
}

// ClearBanned calls ClearBannedFunc.
func (mock *NetworkClientMock) ClearBanned(ctx context.Context) error {
	if mock.ClearBannedFunc == nil {
		panic("NetworkClientMock.ClearBannedFunc: method is nil but NetworkClient.ClearBanned was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClearBanned.Lock()
	mock.calls.ClearBanned = append(mock.calls.ClearBanned, callInfo)
	mock.lockClearBanned.Unlock()
	return mock.ClearBannedFunc(ctx)
}

// ClearBannedCalls gets all the calls that were made to ClearBanned.
// Check the length with:
//     len(mockedNetworkClient.ClearBannedCalls())
func (mock *NetworkClientMock) ClearBannedCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClearBanned.RLock()
	calls = mock.calls.ClearBanned
	mock.lockClearBanned.RUnlock()
	return calls
}

// ConnectionCount calls ConnectionCountFunc.
func (mock *NetworkClientMock) ConnectionCount(ctx context.Context) (uint64, error) {
	if mock.ConnectionCountFunc == nil {
		panic("NetworkClientMock.ConnectionCountFunc: method is nil but NetworkClient.ConnectionCount was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockConnectionCount.Lock()
	mock.calls.ConnectionCount = append(mock.calls.ConnectionCount, callInfo)
	mock.lockConnectionCount.Unlock()
	return mock.ConnectionCountFunc(ctx)
}

// ConnectionCountCalls gets all the calls that were made to ConnectionCount.
// Check the length with:
//     len(mockedNetworkClient.ConnectionCountCalls())
func (mock *NetworkClientMock) ConnectionCountCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockConnectionCount.RLock()
	calls = mock.calls.ConnectionCount
	mock.lockConnectionCount.RUnlock()
	return calls
}

// DisconnectNode calls DisconnectNodeFunc.
func (mock *NetworkClientMock) DisconnectNode(ctx context.Context, params models.ParamsDisconnectNode) error {
	if mock.DisconnectNodeFunc == nil {
		panic("NetworkClientMock.DisconnectNodeFunc: method is nil but NetworkClient.DisconnectNode was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params models.ParamsDisconnectNode
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockDisconnectNode.Lock()
	mock.calls.DisconnectNode = append(mock.calls.DisconnectNode, callInfo)
	mock.lockDisconnectNode.Unlock()
	return mock.DisconnectNodeFunc(ctx, params)
}

// DisconnectNodeCalls gets all the calls that were made to DisconnectNode.
// Check the length with:
//     len(mockedNetworkClient.DisconnectNodeCalls())
func (mock *NetworkClientMock) DisconnectNodeCalls() []struct {
	Ctx    context.Context
	Params models.ParamsDisconnectNode
} {
	var calls []struct {
		Ctx    context.Context
		Params models.ParamsDisconnectNode
	}
	mock.lockDisconnectNode.RLock()
	calls = mock.calls.DisconnectNode
	mock.lockDisconnectNode.RUnlock()
	return calls
}

// ExcessiveBlock calls ExcessiveBlockFunc.
func (mock *NetworkClientMock) ExcessiveBlock(ctx context.Context) (*models.ExcessiveBlock, error) {
	if mock.ExcessiveBlockFunc == nil {
		panic("NetworkClientMock.ExcessiveBlockFunc: method is nil but NetworkClient.ExcessiveBlock was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockExcessiveBlock.Lock()
	mock.calls.ExcessiveBlock = append(mock.calls.ExcessiveBlock, callInfo)
	mock.lockExcessiveBlock.Unlock()
	return mock.ExcessiveBlockFunc(ctx)
}

// ExcessiveBlockCalls gets all the calls that were made to ExcessiveBlock.
// Check the length with:
//     len(mockedNetworkClient.ExcessiveBlockCalls())
func (mock *NetworkClientMock) ExcessiveBlockCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockExcessiveBlock.RLock()
	calls = mock.calls.ExcessiveBlock
	mock.lockExcessiveBlock.RUnlock()
	return calls
}

// ListBanned calls ListBannedFunc.
func (mock *NetworkClientMock) ListBanned(ctx context.Context) ([]*models.BannedSubnet, error) {
	if mock.ListBannedFunc == nil {
		panic("NetworkClientMock.ListBannedFunc: method is nil but NetworkClient.ListBanned was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListBanned.Lock()
	mock.calls.ListBanned = append(mock.calls.ListBanned, callInfo)
	mock.lockListBanned.Unlock()
	return mock.ListBannedFunc(ctx)
}

// ListBannedCalls gets all the calls that were made to ListBanned.
// Check the length with:
//     len(mockedNetworkClient.ListBannedCalls())
func (mock *NetworkClientMock) ListBannedCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListBanned.RLock()
	calls = mock.calls.ListBanned
	mock.lockListBanned.RUnlock()
	return calls
}

// NetworkInfo calls NetworkInfoFunc.
func (mock *NetworkClientMock) NetworkInfo(ctx context.Context) (*models.NetworkInfo, error) {
	if mock.NetworkInfoFunc == nil {
		panic("NetworkClientMock.NetworkInfoFunc: method is nil but NetworkClient.NetworkInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockNetworkInfo.Lock()
	mock.calls.NetworkInfo = append(mock.calls.NetworkInfo, callInfo)
	mock.lockNetworkInfo.Unlock()
	return mock.NetworkInfoFunc(ctx)
}

// NetworkInfoCalls gets all the calls that were made to NetworkInfo.
// Check the length with:
//     len(mockedNetworkClient.NetworkInfoCalls())
func (mock *NetworkClientMock) NetworkInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockNetworkInfo.RLock()
	calls = mock.calls.NetworkInfo
	mock.lockNetworkInfo.RUnlock()
	return calls
}

// NetworkTotals calls NetworkTotalsFunc.
func (mock *NetworkClientMock) NetworkTotals(ctx context.Context) (*models.NetworkTotals, error) {
	if mock.NetworkTotalsFunc == nil {
		panic("NetworkClientMock.NetworkTotalsFunc: method is nil but NetworkClient.NetworkTotals was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockNetworkTotals.Lock()
	mock.calls.NetworkTotals = append(mock.calls.NetworkTotals, callInfo)
	mock.lockNetworkTotals.Unlock()
	return mock.NetworkTotalsFunc(ctx)
}

// NetworkTotalsCalls gets all the calls that were made to NetworkTotals.
// Check the length with:
//     len(mockedNetworkClient.NetworkTotalsCalls())
func (mock *NetworkClientMock) NetworkTotalsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockNetworkTotals.RLock()
	calls = mock.calls.NetworkTotals
	mock.lockNetworkTotals.RUnlock()
	return calls
}

// NodeInfo calls NodeInfoFunc.
func (mock *NetworkClientMock) NodeInfo(ctx context.Context, opts *models.OptsNodeInfo) ([]*models.NodeInfo, error) {
	if mock.NodeInfoFunc == nil {
		panic("NetworkClientMock.NodeInfoFunc: method is nil but NetworkClient.NodeInfo was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsNodeInfo
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockNodeInfo.Lock()
	mock.calls.NodeInfo = append(mock.calls.NodeInfo, callInfo)
	mock.lockNodeInfo.Unlock()
	return mock.NodeInfoFunc(ctx, opts)
}

// NodeInfoCalls gets all the calls that were made to NodeInfo.
// Check the length with:
//     len(mockedNetworkClient.NodeInfoCalls())
func (mock *NetworkClientMock) NodeInfoCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsNodeInfo
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsNodeInfo
	}
	mock.lockNodeInfo.RLock()
	calls = mock.calls.NodeInfo
	mock.lockNodeInfo.RUnlock()
	return calls
}

// PeerInfo calls PeerInfoFunc.
func (mock *NetworkClientMock) PeerInfo(ctx context.Context) ([]*models.PeerInfo, error) {
	if mock.PeerInfoFunc == nil {
		panic("NetworkClientMock.PeerInfoFunc: method is nil but NetworkClient.PeerInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPeerInfo.Lock()
	mock.calls.PeerInfo = append(mock.calls.PeerInfo, callInfo)
	mock.lockPeerInfo.Unlock()
	return mock.PeerInfoFunc(ctx)
}

// PeerInfoCalls gets all the calls that were made to PeerInfo.
// Check the length with:
//     len(mockedNetworkClient.PeerInfoCalls())
func (mock *NetworkClientMock) PeerInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPeerInfo.RLock()
	calls = mock.calls.PeerInfo
	mock.lockPeerInfo.RUnlock()
	return calls
}

// Ping calls PingFunc.
func (mock *NetworkClientMock) Ping(ctx context.Context) error {
	if mock.PingFunc == nil {
		panic("NetworkClientMock.PingFunc: method is nil but NetworkClient.Ping was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPing.Lock()
	mock.calls.Ping = append(mock.calls.Ping, callInfo)
	mock.lockPing.Unlock()
	return mock.PingFunc(ctx)
}

// PingCalls gets all the calls that were made to Ping.
// Check the length with:
//     len(mockedNetworkClient.PingCalls())
func (mock *NetworkClientMock) PingCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPing.RLock()
	calls = mock.calls.Ping
	mock.lockPing.RUnlock()
	return calls
}

// SetBan calls SetBanFunc.
func (mock *NetworkClientMock) SetBan(ctx context.Context, subnet string, action internal.BanAction, opts *models.OptsSetBan) error {
	if mock.SetBanFunc == nil {
		panic("NetworkClientMock.SetBanFunc: method is nil but NetworkClient.SetBan was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Subnet string
		Action internal.BanAction
		Opts   *models.OptsSetBan
	}{
		Ctx:    ctx,
		Subnet: subnet,
		Action: action,
		Opts:   opts,
	}
	mock.lockSetBan.Lock()
	mock.calls.SetBan = append(mock.calls.SetBan, callInfo)
	mock.lockSetBan.Unlock()
	return mock.SetBanFunc(ctx, subnet, action, opts)
}

// SetBanCalls gets all the calls that were made to SetBan.
// Check the length with:
//     len(mockedNetworkClient.SetBanCalls())
func (mock *NetworkClientMock) SetBanCalls() []struct {
	Ctx    context.Context
	Subnet string
	Action internal.BanAction
	Opts   *models.OptsSetBan
} {
	var calls []struct {
		Ctx    context.Context
		Subnet string
		Action internal.BanAction
		Opts   *models.OptsSetBan
	}
	mock.lockSetBan.RLock()
	calls = mock.calls.SetBan
	mock.lockSetBan.RUnlock()
	return calls
}

// SetBlockMaxSize calls SetBlockMaxSizeFunc.
func (mock *NetworkClientMock) SetBlockMaxSize(ctx context.Context, size uint64) (string, error) {
	if mock.SetBlockMaxSizeFunc == nil {
		panic("NetworkClientMock.SetBlockMaxSizeFunc: method is nil but NetworkClient.SetBlockMaxSize was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Size uint64
	}{
		Ctx:  ctx,
		Size: size,
	}
	mock.lockSetBlockMaxSize.Lock()
	mock.calls.SetBlockMaxSize = append(mock.calls.SetBlockMaxSize, callInfo)
	mock.lockSetBlockMaxSize.Unlock()
	return mock.SetBlockMaxSizeFunc(ctx, size)
}

// SetBlockMaxSizeCalls gets all the calls that were made to SetBlockMaxSize.
// Check the length with:
//     len(mockedNetworkClient.SetBlockMaxSizeCalls())
func (mock *NetworkClientMock) SetBlockMaxSizeCalls() []struct {
	Ctx  context.Context
	Size uint64
} {
	var calls []struct {
		Ctx  context.Context
		Size uint64
	}
	mock.lockSetBlockMaxSize.RLock()
	calls = mock.calls.SetBlockMaxSize
	mock.lockSetBlockMaxSize.RUnlock()
	return calls
}

// SetExcessiveBlock calls SetExcessiveBlockFunc.
func (mock *NetworkClientMock) SetExcessiveBlock(ctx context.Context, size uint64) (string, error) {
	if mock.SetExcessiveBlockFunc == nil {
		panic("NetworkClientMock.SetExcessiveBlockFunc: method is nil but NetworkClient.SetExcessiveBlock was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Size uint64
	}{
		Ctx:  ctx,
		Size: size,
	}
	mock.lockSetExcessiveBlock.Lock()
	mock.calls.SetExcessiveBlock = append(mock.calls.SetExcessiveBlock, callInfo)
	mock.lockSetExcessiveBlock.Unlock()
	return mock.SetExcessiveBlockFunc(ctx, size)
}

// SetExcessiveBlockCalls gets all the calls that were made to SetExcessiveBlock.
// Check the length with:
//     len(mockedNetworkClient.SetExcessiveBlockCalls())
func (mock *NetworkClientMock) SetExcessiveBlockCalls() []struct {
	Ctx  context.Context
	Size uint64
} {
	var calls []struct {
		Ctx  context.Context
		Size uint64
	}
	mock.lockSetExcessiveBlock.RLock()
	calls = mock.calls.SetExcessiveBlock
	mock.lockSetExcessiveBlock.RUnlock()
	return calls
}

// SetNetworkActive calls SetNetworkActiveFunc.
func (mock *NetworkClientMock) SetNetworkActive(ctx context.Context, enabled bool) error {
	if mock.SetNetworkActiveFunc == nil {
		panic("NetworkClientMock.SetNetworkActiveFunc: method is nil but NetworkClient.SetNetworkActive was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Enabled bool
	}{
		Ctx:     ctx,
		Enabled: enabled,
	}
	mock.lockSetNetworkActive.Lock()
	mock.calls.SetNetworkActive = append(mock.calls.SetNetworkActive, callInfo)
	mock.lockSetNetworkActive.Unlock()
	return mock.SetNetworkActiveFunc(ctx, enabled)
}

// SetNetworkActiveCalls gets all the calls that were made to SetNetworkActive.
// Check the length with:
//     len(mockedNetworkClient.SetNetworkActiveCalls())
func (mock *NetworkClientMock) SetNetworkActiveCalls() []struct {
	Ctx     context.Context
	Enabled bool
} {
	var calls []struct {
		Ctx     context.Context
		Enabled bool
	}
	mock.lockSetNetworkActive.RLock()
	calls = mock.calls.SetNetworkActive
	mock.lockSetNetworkActive.RUnlock()
	return calls
}

// SetTxPropagationFrequency calls SetTxPropagationFrequencyFunc.
func (mock *NetworkClientMock) SetTxPropagationFrequency(ctx context.Context, frequency uint64) error {
	if mock.SetTxPropagationFrequencyFunc == nil {
		panic("NetworkClientMock.SetTxPropagationFrequencyFunc: method is nil but NetworkClient.SetTxPropagationFrequency was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Frequency uint64
	}{
		Ctx:       ctx,
		Frequency: frequency,
	}
	mock.lockSetTxPropagationFrequency.Lock()
	mock.calls.SetTxPropagationFrequency = append(mock.calls.SetTxPropagationFrequency, callInfo)
	mock.lockSetTxPropagationFrequency.Unlock()
	return mock.SetTxPropagationFrequencyFunc(ctx, frequency)
}

// SetTxPropagationFrequencyCalls gets all the calls that were made to SetTxPropagationFrequency.
// Check the length with:
//     len(mockedNetworkClient.SetTxPropagationFrequencyCalls())
func (mock *NetworkClientMock) SetTxPropagationFrequencyCalls() []struct {
	Ctx       context.Context
	Frequency uint64
} {
	var calls []struct {
		Ctx       context.Context
		Frequency uint64
	}
	mock.lockSetTxPropagationFrequency.RLock()
	calls = mock.calls.SetTxPropagationFrequency
	mock.lockSetTxPropagationFrequency.RUnlock()
	return calls
}

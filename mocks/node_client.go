// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/libsv/go-bc"
	"github.com/libsv/go-bk/wif"
	"github.com/libsv/go-bn"
	"github.com/libsv/go-bn/internal"
	"github.com/libsv/go-bn/models"
	"github.com/libsv/go-bt/v2"
	"sync"
	"time"
)

// Ensure, that NodeClientMock does implement bn.NodeClient.
// If this is not the case, regenerate this file with moq.
var _ bn.NodeClient = &NodeClientMock{}

// NodeClientMock is a mock implementation of bn.NodeClient.
//
// 	func TestSomethingThatUsesNodeClient(t *testing.T) {
//
// 		// make and configure a mocked bn.NodeClient
// 		mockedNodeClient := &NodeClientMock{
// 			AbandonTransactionFunc: func(ctx context.Context, txID string) error {
// 				panic("mock out the AbandonTransaction method")
// 			},
// 			AccountFunc: func(ctx context.Context, address string) (string, error) {
// 				panic("mock out the Account method")
// 			},
// 			AccountAddressFunc: func(ctx context.Context, account string) (string, error) {
// 				panic("mock out the AccountAddress method")
// 			},
// 			AccountAddressesFunc: func(ctx context.Context, account string) ([]string, error) {
// 				panic("mock out the AccountAddresses method")
// 			},
// 			ActiveZMQNotificationsFunc: func(ctx context.Context) ([]*models.ZMQNotification, error) {
// 				panic("mock out the ActiveZMQNotifications method")
// 			},
// 			AddMultiSigAddressFunc: func(ctx context.Context, n int, keys ...string) (string, error) {
// 				panic("mock out the AddMultiSigAddress method")
// 			},
// 			AddNodeFunc: func(ctx context.Context, node string, command internal.NodeAddType) error {
// 				panic("mock out the AddNode method")
// 			},
// 			BackupWalletFunc: func(ctx context.Context, dest string) error {
// 				panic("mock out the BackupWallet method")
// 			},
// 			BalanceFunc: func(ctx context.Context, opts *models.OptsBalance) (uint64, error) {
// 				panic("mock out the Balance method")
// 			},
// 			BestBlockHashFunc: func(ctx context.Context) (string, error) {
// 				panic("mock out the BestBlockHash method")
// 			},
// 			BlockFunc: func(ctx context.Context, hash string) (*models.Block, error) {
// 				panic("mock out the Block method")
// 			},
// 			BlockByHeightFunc: func(ctx context.Context, height int) (*models.Block, error) {
// 				panic("mock out the BlockByHeight method")
// 			},
// 			BlockCountFunc: func(ctx context.Context) (uint32, error) {
// 				panic("mock out the BlockCount method")
// 			},
// 			BlockDecodeHeaderFunc: func(ctx context.Context, hash string) (*models.BlockDecodeHeader, error) {
// 				panic("mock out the BlockDecodeHeader method")
// 			},
// 			BlockDecodeHeaderByHeightFunc: func(ctx context.Context, height int) (*models.BlockDecodeHeader, error) {
// 				panic("mock out the BlockDecodeHeaderByHeight method")
// 			},
// 			BlockHashFunc: func(ctx context.Context, height int) (string, error) {
// 				panic("mock out the BlockHash method")
// 			},
// 			BlockHeaderFunc: func(ctx context.Context, hash string) (*models.BlockHeader, error) {
// 				panic("mock out the BlockHeader method")
// 			},
// 			BlockHeaderHexFunc: func(ctx context.Context, hash string) (string, error) {
// 				panic("mock out the BlockHeaderHex method")
// 			},
// 			BlockHexFunc: func(ctx context.Context, hash string) (string, error) {
// 				panic("mock out the BlockHex method")
// 			},
// 			BlockHexByHeightFunc: func(ctx context.Context, height int) (string, error) {
// 				panic("mock out the BlockHexByHeight method")
// 			},
// 			BlockStatsFunc: func(ctx context.Context, hash string, fields ...string) (*models.BlockStats, error) {
// 				panic("mock out the BlockStats method")
// 			},
// 			BlockStatsByHeightFunc: func(ctx context.Context, height int, fields ...string) (*models.BlockStats, error) {
// 				panic("mock out the BlockStatsByHeight method")
// 			},
// 			BlockTemplateFunc: func(ctx context.Context, opts *models.BlockTemplateRequest) (*models.BlockTemplate, error) {
// 				panic("mock out the BlockTemplate method")
// 			},
// 			ChainInfoFunc: func(ctx context.Context) (*models.ChainInfo, error) {
// 				panic("mock out the ChainInfo method")
// 			},
// 			ChainTipsFunc: func(ctx context.Context) ([]*models.ChainTip, error) {
// 				panic("mock out the ChainTips method")
// 			},
// 			ChainTxStatsFunc: func(ctx context.Context, opts *models.OptsChainTxStats) (*models.ChainTxStats, error) {
// 				panic("mock out the ChainTxStats method")
// 			},
// 			CheckJournalFunc: func(ctx context.Context) (*models.JournalStatus, error) {
// 				panic("mock out the CheckJournal method")
// 			},
// 			ClearBannedFunc: func(ctx context.Context) error {
// 				panic("mock out the ClearBanned method")
// 			},
// 			ClearInvalidTransactionsFunc: func(ctx context.Context) (uint64, error) {
// 				panic("mock out the ClearInvalidTransactions method")
// 			},
// 			ConnectionCountFunc: func(ctx context.Context) (uint64, error) {
// 				panic("mock out the ConnectionCount method")
// 			},
// 			CreateMultiSigFunc: func(ctx context.Context, n int, keys ...string) (*models.MultiSig, error) {
// 				panic("mock out the CreateMultiSig method")
// 			},
// 			CreateRawTransactionFunc: func(ctx context.Context, utxos bt.UTXOs, params models.ParamsCreateRawTransaction) (*bt.Tx, error) {
// 				panic("mock out the CreateRawTransaction method")
// 			},
// 			DifficultyFunc: func(ctx context.Context) (float64, error) {
// 				panic("mock out the Difficulty method")
// 			},
// 			DisconnectNodeFunc: func(ctx context.Context, params models.ParamsDisconnectNode) error {
// 				panic("mock out the DisconnectNode method")
// 			},
// 			DumpParamsFunc: func(ctx context.Context) ([]string, error) {
// 				panic("mock out the DumpParams method")
// 			},
// 			DumpPrivateKeyFunc: func(ctx context.Context, address string) (*wif.WIF, error) {
// 				panic("mock out the DumpPrivateKey method")
// 			},
// 			DumpWalletFunc: func(ctx context.Context, dest string) (*models.DumpWallet, error) {
// 				panic("mock out the DumpWallet method")
// 			},
// 			EncryptWalletFunc: func(ctx context.Context, passphrase string) error {
// 				panic("mock out the EncryptWallet method")
// 			},
// 			ExcessiveBlockFunc: func(ctx context.Context) (*models.ExcessiveBlock, error) {
// 				panic("mock out the ExcessiveBlock method")
// 			},
// 			FundRawTransactionFunc: func(ctx context.Context, tx *bt.Tx, opts *models.OptsFundRawTransaction) (*models.FundRawTransaction, error) {
// 				panic("mock out the FundRawTransaction method")
// 			},
// 			GenerateFunc: func(ctx context.Context, n int, opts *models.OptsGenerate) ([]string, error) {
// 				panic("mock out the Generate method")
// 			},
// 			GenerateToAddressFunc: func(ctx context.Context, n int, addr string, opts *models.OptsGenerate) ([]string, error) {
// 				panic("mock out the GenerateToAddress method")
// 			},
// 			ImportAddressFunc: func(ctx context.Context, address string, opts *models.OptsImportAddress) error {
// 				panic("mock out the ImportAddress method")
// 			},
// 			ImportMultiFunc: func(ctx context.Context, reqs []models.ImportMultiRequest, opts *models.OptsImportMulti) ([]*models.ImportMulti, error) {
// 				panic("mock out the ImportMulti method")
// 			},
// 			ImportPrivateKeyFunc: func(ctx context.Context, w *wif.WIF, opts *models.OptsImportPrivateKey) error {
// 				panic("mock out the ImportPrivateKey method")
// 			},
// 			ImportPrunedFundsFunc: func(ctx context.Context, tx *bt.Tx, txOutProof string) error {
// 				panic("mock out the ImportPrunedFunds method")
// 			},
// 			ImportPublicKeyFunc: func(ctx context.Context, publicKey string, opts *models.OptsImportPublicKey) error {
// 				panic("mock out the ImportPublicKey method")
// 			},
// 			ImportWalletFunc: func(ctx context.Context, filename string) error {
// 				panic("mock out the ImportWallet method")
// 			},
// 			InfoFunc: func(ctx context.Context) (*models.Info, error) {
// 				panic("mock out the Info method")
// 			},
// 			KeypoolRefillFunc: func(ctx context.Context, opts *models.OptsKeypoolRefill) error {
// 				panic("mock out the KeypoolRefill method")
// 			},
// 			LegacyMerkleProofFunc: func(ctx context.Context, txID string, opts *models.OptsLegacyMerkleProof) (*models.LegacyMerkleProof, error) {
// 				panic("mock out the LegacyMerkleProof method")
// 			},
// 			ListAccountsFunc: func(ctx context.Context, opts *models.OptsListAccounts) (map[string]uint64, error) {
// 				panic("mock out the ListAccounts method")
// 			},
// 			ListBannedFunc: func(ctx context.Context) ([]*models.BannedSubnet, error) {
// 				panic("mock out the ListBanned method")
// 			},
// 			ListLockUnspentFunc: func(ctx context.Context) ([]*models.LockUnspent, error) {
// 				panic("mock out the ListLockUnspent method")
// 			},
// 			ListReceivedByAccountFunc: func(ctx context.Context, opts *models.OptsListReceivedBy) ([]*models.ReceivedByAccount, error) {
// 				panic("mock out the ListReceivedByAccount method")
// 			},
// 			ListReceivedByAddressFunc: func(ctx context.Context, opts *models.OptsListReceivedBy) ([]*models.ReceivedByAddress, error) {
// 				panic("mock out the ListReceivedByAddress method")
// 			},
// 			ListSinceBlockFunc: func(ctx context.Context, opts *models.OptsListSinceBlock) (*models.SinceBlock, error) {
// 				panic("mock out the ListSinceBlock method")
// 			},
// 			ListTransactionsFunc: func(ctx context.Context, opts *models.OptsListTransactions) ([]*models.Transaction, error) {
// 				panic("mock out the ListTransactions method")
// 			},
// 			ListUnspentFunc: func(ctx context.Context, opts *models.OptsListUnspent) (bt.UTXOs, error) {
// 				panic("mock out the ListUnspent method")
// 			},
// 			ListWalletsFunc: func(ctx context.Context) ([]string, error) {
// 				panic("mock out the ListWallets method")
// 			},
// 			LockUnspentFunc: func(ctx context.Context, lock bool, opts *models.OptsLockUnspent) (bool, error) {
// 				panic("mock out the LockUnspent method")
// 			},
// 			MemoryInfoFunc: func(ctx context.Context) (*models.MemoryInfo, error) {
// 				panic("mock out the MemoryInfo method")
// 			},
// 			MempoolAncestorIDsFunc: func(ctx context.Context, txID string) ([]string, error) {
// 				panic("mock out the MempoolAncestorIDs method")
// 			},
// 			MempoolAncestorsFunc: func(ctx context.Context, txID string) (models.MempoolTxs, error) {
// 				panic("mock out the MempoolAncestors method")
// 			},
// 			MempoolDescendantIDsFunc: func(ctx context.Context, txID string) ([]string, error) {
// 				panic("mock out the MempoolDescendantIDs method")
// 			},
// 			MempoolDescendantsFunc: func(ctx context.Context, txID string) (models.MempoolTxs, error) {
// 				panic("mock out the MempoolDescendants method")
// 			},
// 			MempoolEntryFunc: func(ctx context.Context, txID string) (*models.MempoolEntry, error) {
// 				panic("mock out the MempoolEntry method")
// 			},
// 			MerkleProofFunc: func(ctx context.Context, blockHash string, txID string, opts *models.OptsMerkleProof) (*bc.MerkleProof, error) {
// 				panic("mock out the MerkleProof method")
// 			},
// 			MiningCandidateFunc: func(ctx context.Context, opts *models.OptsMiningCandidate) (*models.MiningCandidate, error) {
// 				panic("mock out the MiningCandidate method")
// 			},
// 			MiningInfoFunc: func(ctx context.Context) (*models.MiningInfo, error) {
// 				panic("mock out the MiningInfo method")
// 			},
// 			MoveFunc: func(ctx context.Context, from string, to string, amount uint64, opts *models.OptsMove) (bool, error) {
// 				panic("mock out the Move method")
// 			},
// 			NetworkHashPSFunc: func(ctx context.Context, opts *models.OptsNetworkHashPS) (uint64, error) {
// 				panic("mock out the NetworkHashPS method")
// 			},
// 			NetworkInfoFunc: func(ctx context.Context) (*models.NetworkInfo, error) {
// 				panic("mock out the NetworkInfo method")
// 			},
// 			NetworkTotalsFunc: func(ctx context.Context) (*models.NetworkTotals, error) {
// 				panic("mock out the NetworkTotals method")
// 			},
// 			NewAddressFunc: func(ctx context.Context, opts *models.OptsNewAddress) (string, error) {
// 				panic("mock out the NewAddress method")
// 			},
// 			NodeInfoFunc: func(ctx context.Context, opts *models.OptsNodeInfo) ([]*models.NodeInfo, error) {
// 				panic("mock out the NodeInfo method")
// 			},
// 			OutputFunc: func(ctx context.Context, txID string, n int, opts *models.OptsOutput) (*models.Output, error) {
// 				panic("mock out the Output method")
// 			},
// 			OutputSetInfoFunc: func(ctx context.Context) (*models.OutputSetInfo, error) {
// 				panic("mock out the OutputSetInfo method")
// 			},
// 			PeerInfoFunc: func(ctx context.Context) ([]*models.PeerInfo, error) {
// 				panic("mock out the PeerInfo method")
// 			},
// 			PingFunc: func(ctx context.Context) error {
// 				panic("mock out the Ping method")
// 			},
// 			PreciousBlockFunc: func(ctx context.Context, blockHash string) error {
// 				panic("mock out the PreciousBlock method")
// 			},
// 			PrioritiseTxFunc: func(ctx context.Context, txID string, feeDelta int64) (bool, error) {
// 				panic("mock out the PrioritiseTx method")
// 			},
// 			PruneChainFunc: func(ctx context.Context, height int) (uint32, error) {
// 				panic("mock out the PruneChain method")
// 			},
// 			RawChangeAddressFunc: func(ctx context.Context) (string, error) {
// 				panic("mock out the RawChangeAddress method")
// 			},
// 			RawMempoolFunc: func(ctx context.Context) (models.MempoolTxs, error) {
// 				panic("mock out the RawMempool method")
// 			},
// 			RawMempoolIDsFunc: func(ctx context.Context) ([]string, error) {
// 				panic("mock out the RawMempoolIDs method")
// 			},
// 			RawNonFinalMempoolFunc: func(ctx context.Context) ([]string, error) {
// 				panic("mock out the RawNonFinalMempool method")
// 			},
// 			RawTransactionFunc: func(ctx context.Context, txID string) (*bt.Tx, error) {
// 				panic("mock out the RawTransaction method")
// 			},
// 			RebuildJournalFunc: func(ctx context.Context) error {
// 				panic("mock out the RebuildJournal method")
// 			},
// 			ReceivedByAddressFunc: func(ctx context.Context, address string) (uint64, error) {
// 				panic("mock out the ReceivedByAddress method")
// 			},
// 			RemovePrunedFundsFunc: func(ctx context.Context, txID string) error {
// 				panic("mock out the RemovePrunedFunds method")
// 			},
// 			SendFromFunc: func(ctx context.Context, from string, to string, amount uint64, opts *models.OptsSendFrom) (string, error) {
// 				panic("mock out the SendFrom method")
// 			},
// 			SendManyFunc: func(ctx context.Context, from string, amounts map[string]uint64, opts *models.OptsSendMany) (string, error) {
// 				panic("mock out the SendMany method")
// 			},
// 			SendRawTransactionFunc: func(ctx context.Context, tx *bt.Tx, opts *models.OptsSendRawTransaction) (string, error) {
// 				panic("mock out the SendRawTransaction method")
// 			},
// 			SendRawTransactionsFunc: func(ctx context.Context, params ...models.ParamsSendRawTransactions) (*models.SendRawTransactionsResponse, error) {
// 				panic("mock out the SendRawTransactions method")
// 			},
// 			SendToAddressFunc: func(ctx context.Context, address string, amount uint64, opts *models.OptsSendToAddress) (string, error) {
// 				panic("mock out the SendToAddress method")
// 			},
// 			SetAccountFunc: func(ctx context.Context, address string, account string) error {
// 				panic("mock out the SetAccount method")
// 			},
// 			SetBanFunc: func(ctx context.Context, subnet string, action internal.BanAction, opts *models.OptsSetBan) error {
// 				panic("mock out the SetBan method")
// 			},
// 			SetBlockMaxSizeFunc: func(ctx context.Context, size uint64) (string, error) {
// 				panic("mock out the SetBlockMaxSize method")
// 			},
// 			SetExcessiveBlockFunc: func(ctx context.Context, size uint64) (string, error) {
// 				panic("mock out the SetExcessiveBlock method")
// 			},
// 			SetNetworkActiveFunc: func(ctx context.Context, enabled bool) error {
// 				panic("mock out the SetNetworkActive method")
// 			},
// 			SetTxFeeFunc: func(ctx context.Context, amount uint64) (bool, error) {
// 				panic("mock out the SetTxFee method")
// 			},
// 			SetTxPropagationFrequencyFunc: func(ctx context.Context, frequency uint64) error {
// 				panic("mock out the SetTxPropagationFrequency method")
// 			},
// 			SettingsFunc: func(ctx context.Context) (*models.Settings, error) {
// 				panic("mock out the Settings method")
// 			},
// 			SignMessageFunc: func(ctx context.Context, address string, message string) (string, error) {
// 				panic("mock out the SignMessage method")
// 			},
// 			SignMessageWithPrivKeyFunc: func(ctx context.Context, w *wif.WIF, msg string) (string, error) {
// 				panic("mock out the SignMessageWithPrivKey method")
// 			},
// 			SignRawTransactionFunc: func(ctx context.Context, tx *bt.Tx, opts *models.OptsSignRawTransaction) (*models.SignedRawTransaction, error) {
// 				panic("mock out the SignRawTransaction method")
// 			},
// 			StopFunc: func(ctx context.Context) error {
// 				panic("mock out the Stop method")
// 			},
// 			SubmitBlockFunc: func(ctx context.Context, block *bc.Block, params *models.OptsSubmitBlock) (string, error) {
// 				panic("mock out the SubmitBlock method")
// 			},
// 			SubmitMiningSolutionFunc: func(ctx context.Context, solution *models.MiningSolution) (string, error) {
// 				panic("mock out the SubmitMiningSolution method")
// 			},
// 			TransactionFunc: func(ctx context.Context, txID string) (*models.Transaction, error) {
// 				panic("mock out the Transaction method")
// 			},
// 			UnconfirmedBalanceFunc: func(ctx context.Context) (uint64, error) {
// 				panic("mock out the UnconfirmedBalance method")
// 			},
// 			UptimeFunc: func(ctx context.Context) (time.Duration, error) {
// 				panic("mock out the Uptime method")
// 			},
// 			ValidateAddressFunc: func(ctx context.Context, address string) (*models.ValidateAddress, error) {
// 				panic("mock out the ValidateAddress method")
// 			},
// 			VerifyBlockCandidateFunc: func(ctx context.Context, block *bc.Block, params *models.OptsSubmitBlock) (string, error) {
// 				panic("mock out the VerifyBlockCandidate method")
// 			},
// 			VerifyChainFunc: func(ctx context.Context) (bool, error) {
// 				panic("mock out the VerifyChain method")
// 			},
// 			VerifySignedMessageFunc: func(ctx context.Context, w *wif.WIF, signature string, message string) (bool, error) {
// 				panic("mock out the VerifySignedMessage method")
// 			},
// 			WalletInfoFunc: func(ctx context.Context) (*models.WalletInfo, error) {
// 				panic("mock out the WalletInfo method")
// 			},
// 			WalletLockFunc: func(ctx context.Context) error {
// 				panic("mock out the WalletLock method")
// 			},
// 			WalletPhassphraseFunc: func(ctx context.Context, passphrase string, timeout int) error {
// 				panic("mock out the WalletPhassphrase method")
// 			},
// 			WalletPhassphraseChangeFunc: func(ctx context.Context, oldPassphrase string, newPassphrase string) error {
// 				panic("mock out the WalletPhassphraseChange method")
// 			},
// 		}
//
// 		// use mockedNodeClient in code that requires bn.NodeClient
// 		// and then make assertions.
//
// 	}
type NodeClientMock struct {
	// AbandonTransactionFunc mocks the AbandonTransaction method.
	AbandonTransactionFunc func(ctx context.Context, txID string) error

	// AccountFunc mocks the Account method.
	AccountFunc func(ctx context.Context, address string) (string, error)

	// AccountAddressFunc mocks the AccountAddress method.
	AccountAddressFunc func(ctx context.Context, account string) (string, error)

	// AccountAddressesFunc mocks the AccountAddresses method.
	AccountAddressesFunc func(ctx context.Context, account string) ([]string, error)

	// ActiveZMQNotificationsFunc mocks the ActiveZMQNotifications method.
	ActiveZMQNotificationsFunc func(ctx context.Context) ([]*models.ZMQNotification, error)

	// AddMultiSigAddressFunc mocks the AddMultiSigAddress method.
	AddMultiSigAddressFunc func(ctx context.Context, n int, keys ...string) (string, error)

	// AddNodeFunc mocks the AddNode method.
	AddNodeFunc func(ctx context.Context, node string, command internal.NodeAddType) error

	// AddToConfiscationTransactionWhitelist mocks the AddToConfiscationTransactionWhitelist method
	AddToConfiscationTransactionWhitelistFunc func(ctx context.Context, confiscationTransactions []models.ConfiscationTransactionDetails) (*models.AddToConfiscationTransactionWhitelistResponse, error)

	// AddToConsensusBlacklistFunc mocks the AddToConsensusBlacklist
	AddToConsensusBlacklistFunc func(ctx context.Context, funds []models.Fund) (*models.AddToConsensusBlacklistResponse, error)

	// BackupWalletFunc mocks the BackupWallet method.
	BackupWalletFunc func(ctx context.Context, dest string) error

	// BalanceFunc mocks the Balance method.
	BalanceFunc func(ctx context.Context, opts *models.OptsBalance) (uint64, error)

	// BestBlockHashFunc mocks the BestBlockHash method.
	BestBlockHashFunc func(ctx context.Context) (string, error)

	// BlockFunc mocks the Block method.
	BlockFunc func(ctx context.Context, hash string) (*models.Block, error)

	// BlockByHeightFunc mocks the BlockByHeight method.
	BlockByHeightFunc func(ctx context.Context, height int) (*models.Block, error)

	// BlockCountFunc mocks the BlockCount method.
	BlockCountFunc func(ctx context.Context) (uint32, error)

	// BlockDecodeHeaderFunc mocks the BlockDecodeHeader method.
	BlockDecodeHeaderFunc func(ctx context.Context, hash string) (*models.BlockDecodeHeader, error)

	// BlockDecodeHeaderByHeightFunc mocks the BlockDecodeHeaderByHeight method.
	BlockDecodeHeaderByHeightFunc func(ctx context.Context, height int) (*models.BlockDecodeHeader, error)

	// BlockHashFunc mocks the BlockHash method.
	BlockHashFunc func(ctx context.Context, height int) (string, error)

	// BlockHeaderFunc mocks the BlockHeader method.
	BlockHeaderFunc func(ctx context.Context, hash string) (*models.BlockHeader, error)

	// BlockHeaderHexFunc mocks the BlockHeaderHex method.
	BlockHeaderHexFunc func(ctx context.Context, hash string) (string, error)

	// BlockHexFunc mocks the BlockHex method.
	BlockHexFunc func(ctx context.Context, hash string) (string, error)

	// BlockHexByHeightFunc mocks the BlockHexByHeight method.
	BlockHexByHeightFunc func(ctx context.Context, height int) (string, error)

	// BlockStatsFunc mocks the BlockStats method.
	BlockStatsFunc func(ctx context.Context, hash string, fields ...string) (*models.BlockStats, error)

	// BlockStatsByHeightFunc mocks the BlockStatsByHeight method.
	BlockStatsByHeightFunc func(ctx context.Context, height int, fields ...string) (*models.BlockStats, error)

	// BlockTemplateFunc mocks the BlockTemplate method.
	BlockTemplateFunc func(ctx context.Context, opts *models.BlockTemplateRequest) (*models.BlockTemplate, error)

	// ChainInfoFunc mocks the ChainInfo method.
	ChainInfoFunc func(ctx context.Context) (*models.ChainInfo, error)

	// ChainTipsFunc mocks the ChainTips method.
	ChainTipsFunc func(ctx context.Context) ([]*models.ChainTip, error)

	// ChainTxStatsFunc mocks the ChainTxStats method.
	ChainTxStatsFunc func(ctx context.Context, opts *models.OptsChainTxStats) (*models.ChainTxStats, error)

	// CheckJournalFunc mocks the CheckJournal method.
	CheckJournalFunc func(ctx context.Context) (*models.JournalStatus, error)

	// ClearBannedFunc mocks the ClearBanned method.
	ClearBannedFunc func(ctx context.Context) error

	// ClearInvalidTransactionsFunc mocks the ClearInvalidTransactions method.
	ClearInvalidTransactionsFunc func(ctx context.Context) (uint64, error)

	// ConnectionCountFunc mocks the ConnectionCount method.
	ConnectionCountFunc func(ctx context.Context) (uint64, error)

	// CreateMultiSigFunc mocks the CreateMultiSig method.
	CreateMultiSigFunc func(ctx context.Context, n int, keys ...string) (*models.MultiSig, error)

	// CreateRawTransactionFunc mocks the CreateRawTransaction method.
	CreateRawTransactionFunc func(ctx context.Context, utxos bt.UTXOs, params models.ParamsCreateRawTransaction) (*bt.Tx, error)

	// DifficultyFunc mocks the Difficulty method.
	DifficultyFunc func(ctx context.Context) (float64, error)

	// DisconnectNodeFunc mocks the DisconnectNode method.
	DisconnectNodeFunc func(ctx context.Context, params models.ParamsDisconnectNode) error

	// DumpParamsFunc mocks the DumpParams method.
	DumpParamsFunc func(ctx context.Context) ([]string, error)

	// DumpPrivateKeyFunc mocks the DumpPrivateKey method.
	DumpPrivateKeyFunc func(ctx context.Context, address string) (*wif.WIF, error)

	// DumpWalletFunc mocks the DumpWallet method.
	DumpWalletFunc func(ctx context.Context, dest string) (*models.DumpWallet, error)

	// EncryptWalletFunc mocks the EncryptWallet method.
	EncryptWalletFunc func(ctx context.Context, passphrase string) error

	// ExcessiveBlockFunc mocks the ExcessiveBlock method.
	ExcessiveBlockFunc func(ctx context.Context) (*models.ExcessiveBlock, error)

	// FundRawTransactionFunc mocks the FundRawTransaction method.
	FundRawTransactionFunc func(ctx context.Context, tx *bt.Tx, opts *models.OptsFundRawTransaction) (*models.FundRawTransaction, error)

	// GenerateFunc mocks the Generate method.
	GenerateFunc func(ctx context.Context, n int, opts *models.OptsGenerate) ([]string, error)

	// GenerateToAddressFunc mocks the GenerateToAddress method.
	GenerateToAddressFunc func(ctx context.Context, n int, addr string, opts *models.OptsGenerate) ([]string, error)

	// ImportAddressFunc mocks the ImportAddress method.
	ImportAddressFunc func(ctx context.Context, address string, opts *models.OptsImportAddress) error

	// ImportMultiFunc mocks the ImportMulti method.
	ImportMultiFunc func(ctx context.Context, reqs []models.ImportMultiRequest, opts *models.OptsImportMulti) ([]*models.ImportMulti, error)

	// ImportPrivateKeyFunc mocks the ImportPrivateKey method.
	ImportPrivateKeyFunc func(ctx context.Context, w *wif.WIF, opts *models.OptsImportPrivateKey) error

	// ImportPrunedFundsFunc mocks the ImportPrunedFunds method.
	ImportPrunedFundsFunc func(ctx context.Context, tx *bt.Tx, txOutProof string) error

	// ImportPublicKeyFunc mocks the ImportPublicKey method.
	ImportPublicKeyFunc func(ctx context.Context, publicKey string, opts *models.OptsImportPublicKey) error

	// ImportWalletFunc mocks the ImportWallet method.
	ImportWalletFunc func(ctx context.Context, filename string) error

	// InfoFunc mocks the Info method.
	InfoFunc func(ctx context.Context) (*models.Info, error)

	// InvalidateBlockFunc mocks the InvalidateBlock method.
	InvalidateBlockFunc func(ctx context.Context, hash string) error

	// KeypoolRefillFunc mocks the KeypoolRefill method.
	KeypoolRefillFunc func(ctx context.Context, opts *models.OptsKeypoolRefill) error

	// LegacyMerkleProofFunc mocks the LegacyMerkleProof method.
	LegacyMerkleProofFunc func(ctx context.Context, txID string, opts *models.OptsLegacyMerkleProof) (*models.LegacyMerkleProof, error)

	// ListAccountsFunc mocks the ListAccounts method.
	ListAccountsFunc func(ctx context.Context, opts *models.OptsListAccounts) (map[string]uint64, error)

	// ListBannedFunc mocks the ListBanned method.
	ListBannedFunc func(ctx context.Context) ([]*models.BannedSubnet, error)

	// ListLockUnspentFunc mocks the ListLockUnspent method.
	ListLockUnspentFunc func(ctx context.Context) ([]*models.LockUnspent, error)

	// ListReceivedByAccountFunc mocks the ListReceivedByAccount method.
	ListReceivedByAccountFunc func(ctx context.Context, opts *models.OptsListReceivedBy) ([]*models.ReceivedByAccount, error)

	// ListReceivedByAddressFunc mocks the ListReceivedByAddress method.
	ListReceivedByAddressFunc func(ctx context.Context, opts *models.OptsListReceivedBy) ([]*models.ReceivedByAddress, error)

	// ListSinceBlockFunc mocks the ListSinceBlock method.
	ListSinceBlockFunc func(ctx context.Context, opts *models.OptsListSinceBlock) (*models.SinceBlock, error)

	// ListTransactionsFunc mocks the ListTransactions method.
	ListTransactionsFunc func(ctx context.Context, opts *models.OptsListTransactions) ([]*models.Transaction, error)

	// ListUnspentFunc mocks the ListUnspent method.
	ListUnspentFunc func(ctx context.Context, opts *models.OptsListUnspent) (bt.UTXOs, error)

	// ListWalletsFunc mocks the ListWallets method.
	ListWalletsFunc func(ctx context.Context) ([]string, error)

	// LockUnspentFunc mocks the LockUnspent method.
	LockUnspentFunc func(ctx context.Context, lock bool, opts *models.OptsLockUnspent) (bool, error)

	// MemoryInfoFunc mocks the MemoryInfo method.
	MemoryInfoFunc func(ctx context.Context) (*models.MemoryInfo, error)

	// MempoolAncestorIDsFunc mocks the MempoolAncestorIDs method.
	MempoolAncestorIDsFunc func(ctx context.Context, txID string) ([]string, error)

	// MempoolAncestorsFunc mocks the MempoolAncestors method.
	MempoolAncestorsFunc func(ctx context.Context, txID string) (models.MempoolTxs, error)

	// MempoolDescendantIDsFunc mocks the MempoolDescendantIDs method.
	MempoolDescendantIDsFunc func(ctx context.Context, txID string) ([]string, error)

	// MempoolDescendantsFunc mocks the MempoolDescendants method.
	MempoolDescendantsFunc func(ctx context.Context, txID string) (models.MempoolTxs, error)

	// MempoolEntryFunc mocks the MempoolEntry method.
	MempoolEntryFunc func(ctx context.Context, txID string) (*models.MempoolEntry, error)

	// MerkleProofFunc mocks the MerkleProof method.
	MerkleProofFunc func(ctx context.Context, blockHash string, txID string, opts *models.OptsMerkleProof) (*bc.MerkleProof, error)

	// MiningCandidateFunc mocks the MiningCandidate method.
	MiningCandidateFunc func(ctx context.Context, opts *models.OptsMiningCandidate) (*models.MiningCandidate, error)

	// MiningInfoFunc mocks the MiningInfo method.
	MiningInfoFunc func(ctx context.Context) (*models.MiningInfo, error)

	// MoveFunc mocks the Move method.
	MoveFunc func(ctx context.Context, from string, to string, amount uint64, opts *models.OptsMove) (bool, error)

	// NetworkHashPSFunc mocks the NetworkHashPS method.
	NetworkHashPSFunc func(ctx context.Context, opts *models.OptsNetworkHashPS) (uint64, error)

	// NetworkInfoFunc mocks the NetworkInfo method.
	NetworkInfoFunc func(ctx context.Context) (*models.NetworkInfo, error)

	// NetworkTotalsFunc mocks the NetworkTotals method.
	NetworkTotalsFunc func(ctx context.Context) (*models.NetworkTotals, error)

	// NewAddressFunc mocks the NewAddress method.
	NewAddressFunc func(ctx context.Context, opts *models.OptsNewAddress) (string, error)

	// NodeInfoFunc mocks the NodeInfo method.
	NodeInfoFunc func(ctx context.Context, opts *models.OptsNodeInfo) ([]*models.NodeInfo, error)

	// OutputFunc mocks the Output method.
	OutputFunc func(ctx context.Context, txID string, n int, opts *models.OptsOutput) (*models.Output, error)

	// OutputSetInfoFunc mocks the OutputSetInfo method.
	OutputSetInfoFunc func(ctx context.Context) (*models.OutputSetInfo, error)

	// PeerInfoFunc mocks the PeerInfo method.
	PeerInfoFunc func(ctx context.Context) ([]*models.PeerInfo, error)

	// PingFunc mocks the Ping method.
	PingFunc func(ctx context.Context) error

	// PreciousBlockFunc mocks the PreciousBlock method.
	PreciousBlockFunc func(ctx context.Context, blockHash string) error

	// PrioritiseTxFunc mocks the PrioritiseTx method.
	PrioritiseTxFunc func(ctx context.Context, txID string, feeDelta int64) (bool, error)

	// PruneChainFunc mocks the PruneChain method.
	PruneChainFunc func(ctx context.Context, height int) (uint32, error)

	// RawChangeAddressFunc mocks the RawChangeAddress method.
	RawChangeAddressFunc func(ctx context.Context) (string, error)

	// RawMempoolFunc mocks the RawMempool method.
	RawMempoolFunc func(ctx context.Context) (models.MempoolTxs, error)

	// RawMempoolIDsFunc mocks the RawMempoolIDs method.
	RawMempoolIDsFunc func(ctx context.Context) ([]string, error)

	// RawNonFinalMempoolFunc mocks the RawNonFinalMempool method.
	RawNonFinalMempoolFunc func(ctx context.Context) ([]string, error)

	// RawTransactionFunc mocks the RawTransaction method.
	RawTransactionFunc func(ctx context.Context, txID string) (*bt.Tx, error)

	// RebuildJournalFunc mocks the RebuildJournal method.
	RebuildJournalFunc func(ctx context.Context) error

	// ReceivedByAddressFunc mocks the ReceivedByAddress method.
	ReceivedByAddressFunc func(ctx context.Context, address string) (uint64, error)

	// RemovePrunedFundsFunc mocks the RemovePrunedFunds method.
	RemovePrunedFundsFunc func(ctx context.Context, txID string) error

	// SendFromFunc mocks the SendFrom method.
	SendFromFunc func(ctx context.Context, from string, to string, amount uint64, opts *models.OptsSendFrom) (string, error)

	// SendManyFunc mocks the SendMany method.
	SendManyFunc func(ctx context.Context, from string, amounts map[string]uint64, opts *models.OptsSendMany) (string, error)

	// SendRawTransactionFunc mocks the SendRawTransaction method.
	SendRawTransactionFunc func(ctx context.Context, tx *bt.Tx, opts *models.OptsSendRawTransaction) (string, error)

	// SendRawTransactionsFunc mocks the SendRawTransactions method.
	SendRawTransactionsFunc func(ctx context.Context, params ...models.ParamsSendRawTransactions) (*models.SendRawTransactionsResponse, error)

	// SendToAddressFunc mocks the SendToAddress method.
	SendToAddressFunc func(ctx context.Context, address string, amount uint64, opts *models.OptsSendToAddress) (string, error)

	// SetAccountFunc mocks the SetAccount method.
	SetAccountFunc func(ctx context.Context, address string, account string) error

	// SetBanFunc mocks the SetBan method.
	SetBanFunc func(ctx context.Context, subnet string, action internal.BanAction, opts *models.OptsSetBan) error

	// SetBlockMaxSizeFunc mocks the SetBlockMaxSize method.
	SetBlockMaxSizeFunc func(ctx context.Context, size uint64) (string, error)

	// SetExcessiveBlockFunc mocks the SetExcessiveBlock method.
	SetExcessiveBlockFunc func(ctx context.Context, size uint64) (string, error)

	// SetNetworkActiveFunc mocks the SetNetworkActive method.
	SetNetworkActiveFunc func(ctx context.Context, enabled bool) error

	// SetTxFeeFunc mocks the SetTxFee method.
	SetTxFeeFunc func(ctx context.Context, amount uint64) (bool, error)

	// SetTxPropagationFrequencyFunc mocks the SetTxPropagationFrequency method.
	SetTxPropagationFrequencyFunc func(ctx context.Context, frequency uint64) error

	// SettingsFunc mocks the Settings method.
	SettingsFunc func(ctx context.Context) (*models.Settings, error)

	// SignMessageFunc mocks the SignMessage method.
	SignMessageFunc func(ctx context.Context, address string, message string) (string, error)

	// SignMessageWithPrivKeyFunc mocks the SignMessageWithPrivKey method.
	SignMessageWithPrivKeyFunc func(ctx context.Context, w *wif.WIF, msg string) (string, error)

	// SignRawTransactionFunc mocks the SignRawTransaction method.
	SignRawTransactionFunc func(ctx context.Context, tx *bt.Tx, opts *models.OptsSignRawTransaction) (*models.SignedRawTransaction, error)

	// StopFunc mocks the Stop method.
	StopFunc func(ctx context.Context) error

	// SubmitBlockFunc mocks the SubmitBlock method.
	SubmitBlockFunc func(ctx context.Context, block *bc.Block, params *models.OptsSubmitBlock) (string, error)

	// SubmitMiningSolutionFunc mocks the SubmitMiningSolution method.
	SubmitMiningSolutionFunc func(ctx context.Context, solution *models.MiningSolution) (string, error)

	// TransactionFunc mocks the Transaction method.
	TransactionFunc func(ctx context.Context, txID string) (*models.Transaction, error)

	// UnconfirmedBalanceFunc mocks the UnconfirmedBalance method.
	UnconfirmedBalanceFunc func(ctx context.Context) (uint64, error)

	// UptimeFunc mocks the Uptime method.
	UptimeFunc func(ctx context.Context) (time.Duration, error)

	// ValidateAddressFunc mocks the ValidateAddress method.
	ValidateAddressFunc func(ctx context.Context, address string) (*models.ValidateAddress, error)

	// VerifyBlockCandidateFunc mocks the VerifyBlockCandidate method.
	VerifyBlockCandidateFunc func(ctx context.Context, block *bc.Block, params *models.OptsSubmitBlock) (string, error)

	// VerifyChainFunc mocks the VerifyChain method.
	VerifyChainFunc func(ctx context.Context) (bool, error)

	// VerifySignedMessageFunc mocks the VerifySignedMessage method.
	VerifySignedMessageFunc func(ctx context.Context, w *wif.WIF, signature string, message string) (bool, error)

	// WalletInfoFunc mocks the WalletInfo method.
	WalletInfoFunc func(ctx context.Context) (*models.WalletInfo, error)

	// WalletLockFunc mocks the WalletLock method.
	WalletLockFunc func(ctx context.Context) error

	// WalletPhassphraseFunc mocks the WalletPhassphrase method.
	WalletPhassphraseFunc func(ctx context.Context, passphrase string, timeout int) error

	// WalletPhassphraseChangeFunc mocks the WalletPhassphraseChange method.
	WalletPhassphraseChangeFunc func(ctx context.Context, oldPassphrase string, newPassphrase string) error

	// calls tracks calls to the methods.
	calls struct {
		// AbandonTransaction holds details about calls to the AbandonTransaction method.
		AbandonTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// Account holds details about calls to the Account method.
		Account []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
		}
		// AccountAddress holds details about calls to the AccountAddress method.
		AccountAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account string
		}
		// AccountAddresses holds details about calls to the AccountAddresses method.
		AccountAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account string
		}
		// ActiveZMQNotifications holds details about calls to the ActiveZMQNotifications method.
		ActiveZMQNotifications []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// AddMultiSigAddress holds details about calls to the AddMultiSigAddress method.
		AddMultiSigAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// N is the n argument value.
			N int
			// Keys is the keys argument value.
			Keys []string
		}
		// AddNode holds details about calls to the AddNode method.
		AddNode []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Node is the node argument value.
			Node string
			// Command is the command argument value.
			Command internal.NodeAddType
		}
		// AddToConfiscationTransactionWhitelist holds details about calls to the AddToConfiscationTransactionWhitelist method
		AddToConfiscationTransactionWhitelist []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ConfiscationTransactions is the confiscation transactions argument value
			ConfiscationTransactions []models.ConfiscationTransactionDetails
		}
		// AddToConsensusBlacklist holds details about calls to the AddToConsensusBlacklist method
		AddToConsensusBlacklist []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Funds is the funds argument value
			Funds []models.Fund
		}
		// BackupWallet holds details about calls to the BackupWallet method.
		BackupWallet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dest is the dest argument value.
			Dest string
		}
		// Balance holds details about calls to the Balance method.
		Balance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsBalance
		}
		// BestBlockHash holds details about calls to the BestBlockHash method.
		BestBlockHash []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Block holds details about calls to the Block method.
		Block []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash string
		}
		// BlockByHeight holds details about calls to the BlockByHeight method.
		BlockByHeight []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height int
		}
		// BlockCount holds details about calls to the BlockCount method.
		BlockCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// BlockDecodeHeader holds details about calls to the BlockDecodeHeader method.
		BlockDecodeHeader []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash string
		}
		// BlockDecodeHeaderByHeight holds details about calls to the BlockDecodeHeaderByHeight method.
		BlockDecodeHeaderByHeight []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height int
		}
		// BlockHash holds details about calls to the BlockHash method.
		BlockHash []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height int
		}
		// BlockHeader holds details about calls to the BlockHeader method.
		BlockHeader []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash string
		}
		// BlockHeaderHex holds details about calls to the BlockHeaderHex method.
		BlockHeaderHex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash string
		}
		// BlockHex holds details about calls to the BlockHex method.
		BlockHex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash string
		}
		// BlockHexByHeight holds details about calls to the BlockHexByHeight method.
		BlockHexByHeight []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height int
		}
		// BlockStats holds details about calls to the BlockStats method.
		BlockStats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash string
			// Fields is the fields argument value.
			Fields []string
		}
		// BlockStatsByHeight holds details about calls to the BlockStatsByHeight method.
		BlockStatsByHeight []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height int
			// Fields is the fields argument value.
			Fields []string
		}
		// BlockTemplate holds details about calls to the BlockTemplate method.
		BlockTemplate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.BlockTemplateRequest
		}
		// ChainInfo holds details about calls to the ChainInfo method.
		ChainInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ChainTips holds details about calls to the ChainTips method.
		ChainTips []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ChainTxStats holds details about calls to the ChainTxStats method.
		ChainTxStats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsChainTxStats
		}
		// CheckJournal holds details about calls to the CheckJournal method.
		CheckJournal []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClearBanned holds details about calls to the ClearBanned method.
		ClearBanned []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClearInvalidTransactions holds details about calls to the ClearInvalidTransactions method.
		ClearInvalidTransactions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ConnectionCount holds details about calls to the ConnectionCount method.
		ConnectionCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CreateMultiSig holds details about calls to the CreateMultiSig method.
		CreateMultiSig []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// N is the n argument value.
			N int
			// Keys is the keys argument value.
			Keys []string
		}
		// CreateRawTransaction holds details about calls to the CreateRawTransaction method.
		CreateRawTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Utxos is the utxos argument value.
			Utxos bt.UTXOs
			// Params is the params argument value.
			Params models.ParamsCreateRawTransaction
		}
		// Difficulty holds details about calls to the Difficulty method.
		Difficulty []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// DisconnectNode holds details about calls to the DisconnectNode method.
		DisconnectNode []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params models.ParamsDisconnectNode
		}
		// DumpParams holds details about calls to the DumpParams method.
		DumpParams []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// DumpPrivateKey holds details about calls to the DumpPrivateKey method.
		DumpPrivateKey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
		}
		// DumpWallet holds details about calls to the DumpWallet method.
		DumpWallet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dest is the dest argument value.
			Dest string
		}
		// EncryptWallet holds details about calls to the EncryptWallet method.
		EncryptWallet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Passphrase is the passphrase argument value.
			Passphrase string
		}
		// ExcessiveBlock holds details about calls to the ExcessiveBlock method.
		ExcessiveBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FundRawTransaction holds details about calls to the FundRawTransaction method.
		FundRawTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx *bt.Tx
			// Opts is the opts argument value.
			Opts *models.OptsFundRawTransaction
		}
		// Generate holds details about calls to the Generate method.
		Generate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// N is the n argument value.
			N int
			// Opts is the opts argument value.
			Opts *models.OptsGenerate
		}
		// GenerateToAddress holds details about calls to the GenerateToAddress method.
		GenerateToAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// N is the n argument value.
			N int
			// Addr is the addr argument value.
			Addr string
			// Opts is the opts argument value.
			Opts *models.OptsGenerate
		}
		// ImportAddress holds details about calls to the ImportAddress method.
		ImportAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
			// Opts is the opts argument value.
			Opts *models.OptsImportAddress
		}
		// ImportMulti holds details about calls to the ImportMulti method.
		ImportMulti []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Reqs is the reqs argument value.
			Reqs []models.ImportMultiRequest
			// Opts is the opts argument value.
			Opts *models.OptsImportMulti
		}
		// ImportPrivateKey holds details about calls to the ImportPrivateKey method.
		ImportPrivateKey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// W is the w argument value.
			W *wif.WIF
			// Opts is the opts argument value.
			Opts *models.OptsImportPrivateKey
		}
		// ImportPrunedFunds holds details about calls to the ImportPrunedFunds method.
		ImportPrunedFunds []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx *bt.Tx
			// TxOutProof is the txOutProof argument value.
			TxOutProof string
		}
		// ImportPublicKey holds details about calls to the ImportPublicKey method.
		ImportPublicKey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PublicKey is the publicKey argument value.
			PublicKey string
			// Opts is the opts argument value.
			Opts *models.OptsImportPublicKey
		}
		// ImportWallet holds details about calls to the ImportWallet method.
		ImportWallet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filename is the filename argument value.
			Filename string
		}
		// Info holds details about calls to the Info method.
		Info []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// InvalidateBlock holds details about calls to the InvalidateBlock method.
		InvalidateBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BlockHash is the hash argument value.
			BlockHash string
		}
		// KeypoolRefill holds details about calls to the KeypoolRefill method.
		KeypoolRefill []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsKeypoolRefill
		}
		// LegacyMerkleProof holds details about calls to the LegacyMerkleProof method.
		LegacyMerkleProof []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
			// Opts is the opts argument value.
			Opts *models.OptsLegacyMerkleProof
		}
		// ListAccounts holds details about calls to the ListAccounts method.
		ListAccounts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsListAccounts
		}
		// ListBanned holds details about calls to the ListBanned method.
		ListBanned []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListLockUnspent holds details about calls to the ListLockUnspent method.
		ListLockUnspent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListReceivedByAccount holds details about calls to the ListReceivedByAccount method.
		ListReceivedByAccount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsListReceivedBy
		}
		// ListReceivedByAddress holds details about calls to the ListReceivedByAddress method.
		ListReceivedByAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsListReceivedBy
		}
		// ListSinceBlock holds details about calls to the ListSinceBlock method.
		ListSinceBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsListSinceBlock
		}
		// ListTransactions holds details about calls to the ListTransactions method.
		ListTransactions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsListTransactions
		}
		// ListUnspent holds details about calls to the ListUnspent method.
		ListUnspent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsListUnspent
		}
		// ListWallets holds details about calls to the ListWallets method.
		ListWallets []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// LockUnspent holds details about calls to the LockUnspent method.
		LockUnspent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Lock is the lock argument value.
			Lock bool
			// Opts is the opts argument value.
			Opts *models.OptsLockUnspent
		}
		// MemoryInfo holds details about calls to the MemoryInfo method.
		MemoryInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// MempoolAncestorIDs holds details about calls to the MempoolAncestorIDs method.
		MempoolAncestorIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// MempoolAncestors holds details about calls to the MempoolAncestors method.
		MempoolAncestors []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// MempoolDescendantIDs holds details about calls to the MempoolDescendantIDs method.
		MempoolDescendantIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// MempoolDescendants holds details about calls to the MempoolDescendants method.
		MempoolDescendants []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// MempoolEntry holds details about calls to the MempoolEntry method.
		MempoolEntry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// MerkleProof holds details about calls to the MerkleProof method.
		MerkleProof []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BlockHash is the blockHash argument value.
			BlockHash string
			// TxID is the txID argument value.
			TxID string
			// Opts is the opts argument value.
			Opts *models.OptsMerkleProof
		}
		// MiningCandidate holds details about calls to the MiningCandidate method.
		MiningCandidate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsMiningCandidate
		}
		// MiningInfo holds details about calls to the MiningInfo method.
		MiningInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Move holds details about calls to the Move method.
		Move []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// From is the from argument value.
			From string
			// To is the to argument value.
			To string
			// Amount is the amount argument value.
			Amount uint64
			// Opts is the opts argument value.
			Opts *models.OptsMove
		}
		// NetworkHashPS holds details about calls to the NetworkHashPS method.
		NetworkHashPS []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsNetworkHashPS
		}
		// NetworkInfo holds details about calls to the NetworkInfo method.
		NetworkInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// NetworkTotals holds details about calls to the NetworkTotals method.
		NetworkTotals []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// NewAddress holds details about calls to the NewAddress method.
		NewAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsNewAddress
		}
		// NodeInfo holds details about calls to the NodeInfo method.
		NodeInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *models.OptsNodeInfo
		}
		// Output holds details about calls to the Output method.
		Output []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
			// N is the n argument value.
			N int
			// Opts is the opts argument value.
			Opts *models.OptsOutput
		}
		// OutputSetInfo holds details about calls to the OutputSetInfo method.
		OutputSetInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// PeerInfo holds details about calls to the PeerInfo method.
		PeerInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Ping holds details about calls to the Ping method.
		Ping []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// PreciousBlock holds details about calls to the PreciousBlock method.
		PreciousBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BlockHash is the blockHash argument value.
			BlockHash string
		}
		// PrioritiseTx holds details about calls to the PrioritiseTx method.
		PrioritiseTx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
			// FeeDelta is the feeDelta argument value.
			FeeDelta int64
		}
		// PruneChain holds details about calls to the PruneChain method.
		PruneChain []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height int
		}
		// RawChangeAddress holds details about calls to the RawChangeAddress method.
		RawChangeAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// RawMempool holds details about calls to the RawMempool method.
		RawMempool []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// RawMempoolIDs holds details about calls to the RawMempoolIDs method.
		RawMempoolIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// RawNonFinalMempool holds details about calls to the RawNonFinalMempool method.
		RawNonFinalMempool []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// RawTransaction holds details about calls to the RawTransaction method.
		RawTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// RebuildJournal holds details about calls to the RebuildJournal method.
		RebuildJournal []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ReceivedByAddress holds details about calls to the ReceivedByAddress method.
		ReceivedByAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
		}
		// RemovePrunedFunds holds details about calls to the RemovePrunedFunds method.
		RemovePrunedFunds []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// SendFrom holds details about calls to the SendFrom method.
		SendFrom []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// From is the from argument value.
			From string
			// To is the to argument value.
			To string
			// Amount is the amount argument value.
			Amount uint64
			// Opts is the opts argument value.
			Opts *models.OptsSendFrom
		}
		// SendMany holds details about calls to the SendMany method.
		SendMany []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// From is the from argument value.
			From string
			// Amounts is the amounts argument value.
			Amounts map[string]uint64
			// Opts is the opts argument value.
			Opts *models.OptsSendMany
		}
		// SendRawTransaction holds details about calls to the SendRawTransaction method.
		SendRawTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx *bt.Tx
			// Opts is the opts argument value.
			Opts *models.OptsSendRawTransaction
		}
		// SendRawTransactions holds details about calls to the SendRawTransactions method.
		SendRawTransactions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params []models.ParamsSendRawTransactions
		}
		// SendToAddress holds details about calls to the SendToAddress method.
		SendToAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
			// Amount is the amount argument value.
			Amount uint64
			// Opts is the opts argument value.
			Opts *models.OptsSendToAddress
		}
		// SetAccount holds details about calls to the SetAccount method.
		SetAccount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
			// Account is the account argument value.
			Account string
		}
		// SetBan holds details about calls to the SetBan method.
		SetBan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Subnet is the subnet argument value.
			Subnet string
			// Action is the action argument value.
			Action internal.BanAction
			// Opts is the opts argument value.
			Opts *models.OptsSetBan
		}
		// SetBlockMaxSize holds details about calls to the SetBlockMaxSize method.
		SetBlockMaxSize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Size is the size argument value.
			Size uint64
		}
		// SetExcessiveBlock holds details about calls to the SetExcessiveBlock method.
		SetExcessiveBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Size is the size argument value.
			Size uint64
		}
		// SetNetworkActive holds details about calls to the SetNetworkActive method.
		SetNetworkActive []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Enabled is the enabled argument value.
			Enabled bool
		}
		// SetTxFee holds details about calls to the SetTxFee method.
		SetTxFee []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Amount is the amount argument value.
			Amount uint64
		}
		// SetTxPropagationFrequency holds details about calls to the SetTxPropagationFrequency method.
		SetTxPropagationFrequency []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Frequency is the frequency argument value.
			Frequency uint64
		}
		// Settings holds details about calls to the Settings method.
		Settings []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SignMessage holds details about calls to the SignMessage method.
		SignMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
			// Message is the message argument value.
			Message string
		}
		// SignMessageWithPrivKey holds details about calls to the SignMessageWithPrivKey method.
		SignMessageWithPrivKey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// W is the w argument value.
			W *wif.WIF
			// Msg is the msg argument value.
			Msg string
		}
		// SignRawTransaction holds details about calls to the SignRawTransaction method.
		SignRawTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx *bt.Tx
			// Opts is the opts argument value.
			Opts *models.OptsSignRawTransaction
		}
		// Stop holds details about calls to the Stop method.
		Stop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SubmitBlock holds details about calls to the SubmitBlock method.
		SubmitBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Block is the block argument value.
			Block *bc.Block
			// Params is the params argument value.
			Params *models.OptsSubmitBlock
		}
		// SubmitMiningSolution holds details about calls to the SubmitMiningSolution method.
		SubmitMiningSolution []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Solution is the solution argument value.
			Solution *models.MiningSolution
		}
		// Transaction holds details about calls to the Transaction method.
		Transaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// UnconfirmedBalance holds details about calls to the UnconfirmedBalance method.
		UnconfirmedBalance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Uptime holds details about calls to the Uptime method.
		Uptime []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ValidateAddress holds details about calls to the ValidateAddress method.
		ValidateAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
		}
		// VerifyBlockCandidate holds details about calls to the VerifyBlockCandidate method.
		VerifyBlockCandidate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Block is the block argument value.
			Block *bc.Block
			// Params is the params argument value.
			Params *models.OptsSubmitBlock
		}
		// VerifyChain holds details about calls to the VerifyChain method.
		VerifyChain []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// VerifySignedMessage holds details about calls to the VerifySignedMessage method.
		VerifySignedMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// W is the w argument value.
			W *wif.WIF
			// Signature is the signature argument value.
			Signature string
			// Message is the message argument value.
			Message string
		}
		// WalletInfo holds details about calls to the WalletInfo method.
		WalletInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// WalletLock holds details about calls to the WalletLock method.
		WalletLock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// WalletPhassphrase holds details about calls to the WalletPhassphrase method.
		WalletPhassphrase []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Passphrase is the passphrase argument value.
			Passphrase string
			// Timeout is the timeout argument value.
			Timeout int
		}
		// WalletPhassphraseChange holds details about calls to the WalletPhassphraseChange method.
		WalletPhassphraseChange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OldPassphrase is the oldPassphrase argument value.
			OldPassphrase string
			// NewPassphrase is the newPassphrase argument value.
			NewPassphrase string
		}
	}
	lockAbandonTransaction        sync.RWMutex
	lockAccount                   sync.RWMutex
	lockAccountAddress            sync.RWMutex
	lockAccountAddresses          sync.RWMutex
	lockActiveZMQNotifications    sync.RWMutex
	lockAddMultiSigAddress        sync.RWMutex
	lockAddNode                   sync.RWMutex
	lockAddToConsensusBlacklist                   sync.RWMutex
	lockAddToConfiscationTransactionWhitelist sync.RWMutex
	lockBackupWallet              sync.RWMutex
	lockBalance                   sync.RWMutex
	lockBestBlockHash             sync.RWMutex
	lockBlock                     sync.RWMutex
	lockBlockByHeight             sync.RWMutex
	lockBlockCount                sync.RWMutex
	lockBlockDecodeHeader         sync.RWMutex
	lockBlockDecodeHeaderByHeight sync.RWMutex
	lockBlockHash                 sync.RWMutex
	lockBlockHeader               sync.RWMutex
	lockBlockHeaderHex            sync.RWMutex
	lockBlockHex                  sync.RWMutex
	lockBlockHexByHeight          sync.RWMutex
	lockBlockStats                sync.RWMutex
	lockBlockStatsByHeight        sync.RWMutex
	lockBlockTemplate             sync.RWMutex
	lockChainInfo                 sync.RWMutex
	lockChainTips                 sync.RWMutex
	lockChainTxStats              sync.RWMutex
	lockCheckJournal              sync.RWMutex
	lockClearBanned               sync.RWMutex
	lockClearInvalidTransactions  sync.RWMutex
	lockConnectionCount           sync.RWMutex
	lockCreateMultiSig            sync.RWMutex
	lockCreateRawTransaction      sync.RWMutex
	lockDifficulty                sync.RWMutex
	lockDisconnectNode            sync.RWMutex
	lockDumpParams                sync.RWMutex
	lockDumpPrivateKey            sync.RWMutex
	lockDumpWallet                sync.RWMutex
	lockEncryptWallet             sync.RWMutex
	lockExcessiveBlock            sync.RWMutex
	lockFundRawTransaction        sync.RWMutex
	lockGenerate                  sync.RWMutex
	lockGenerateToAddress         sync.RWMutex
	lockImportAddress             sync.RWMutex
	lockImportMulti               sync.RWMutex
	lockImportPrivateKey          sync.RWMutex
	lockImportPrunedFunds         sync.RWMutex
	lockImportPublicKey           sync.RWMutex
	lockImportWallet              sync.RWMutex
	lockInfo                      sync.RWMutex
	lockInvalidateBlock                     sync.RWMutex
	lockKeypoolRefill             sync.RWMutex
	lockLegacyMerkleProof         sync.RWMutex
	lockListAccounts              sync.RWMutex
	lockListBanned                sync.RWMutex
	lockListLockUnspent           sync.RWMutex
	lockListReceivedByAccount     sync.RWMutex
	lockListReceivedByAddress     sync.RWMutex
	lockListSinceBlock            sync.RWMutex
	lockListTransactions          sync.RWMutex
	lockListUnspent               sync.RWMutex
	lockListWallets               sync.RWMutex
	lockLockUnspent               sync.RWMutex
	lockMemoryInfo                sync.RWMutex
	lockMempoolAncestorIDs        sync.RWMutex
	lockMempoolAncestors          sync.RWMutex
	lockMempoolDescendantIDs      sync.RWMutex
	lockMempoolDescendants        sync.RWMutex
	lockMempoolEntry              sync.RWMutex
	lockMerkleProof               sync.RWMutex
	lockMiningCandidate           sync.RWMutex
	lockMiningInfo                sync.RWMutex
	lockMove                      sync.RWMutex
	lockNetworkHashPS             sync.RWMutex
	lockNetworkInfo               sync.RWMutex
	lockNetworkTotals             sync.RWMutex
	lockNewAddress                sync.RWMutex
	lockNodeInfo                  sync.RWMutex
	lockOutput                    sync.RWMutex
	lockOutputSetInfo             sync.RWMutex
	lockPeerInfo                  sync.RWMutex
	lockPing                      sync.RWMutex
	lockPreciousBlock             sync.RWMutex
	lockPrioritiseTx              sync.RWMutex
	lockPruneChain                sync.RWMutex
	lockRawChangeAddress          sync.RWMutex
	lockRawMempool                sync.RWMutex
	lockRawMempoolIDs             sync.RWMutex
	lockRawNonFinalMempool        sync.RWMutex
	lockRawTransaction            sync.RWMutex
	lockRebuildJournal            sync.RWMutex
	lockReceivedByAddress         sync.RWMutex
	lockRemovePrunedFunds         sync.RWMutex
	lockSendFrom                  sync.RWMutex
	lockSendMany                  sync.RWMutex
	lockSendRawTransaction        sync.RWMutex
	lockSendRawTransactions       sync.RWMutex
	lockSendToAddress             sync.RWMutex
	lockSetAccount                sync.RWMutex
	lockSetBan                    sync.RWMutex
	lockSetBlockMaxSize           sync.RWMutex
	lockSetExcessiveBlock         sync.RWMutex
	lockSetNetworkActive          sync.RWMutex
	lockSetTxFee                  sync.RWMutex
	lockSetTxPropagationFrequency sync.RWMutex
	lockSettings                  sync.RWMutex
	lockSignMessage               sync.RWMutex
	lockSignMessageWithPrivKey    sync.RWMutex
	lockSignRawTransaction        sync.RWMutex
	lockStop                      sync.RWMutex
	lockSubmitBlock               sync.RWMutex
	lockSubmitMiningSolution      sync.RWMutex
	lockTransaction               sync.RWMutex
	lockUnconfirmedBalance        sync.RWMutex
	lockUptime                    sync.RWMutex
	lockValidateAddress           sync.RWMutex
	lockVerifyBlockCandidate      sync.RWMutex
	lockVerifyChain               sync.RWMutex
	lockVerifySignedMessage       sync.RWMutex
	lockWalletInfo                sync.RWMutex
	lockWalletLock                sync.RWMutex
	lockWalletPhassphrase         sync.RWMutex
	lockWalletPhassphraseChange   sync.RWMutex
}

// AbandonTransaction calls AbandonTransactionFunc.
func (mock *NodeClientMock) AbandonTransaction(ctx context.Context, txID string) error {
	if mock.AbandonTransactionFunc == nil {
		panic("NodeClientMock.AbandonTransactionFunc: method is nil but NodeClient.AbandonTransaction was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockAbandonTransaction.Lock()
	mock.calls.AbandonTransaction = append(mock.calls.AbandonTransaction, callInfo)
	mock.lockAbandonTransaction.Unlock()
	return mock.AbandonTransactionFunc(ctx, txID)
}

// AbandonTransactionCalls gets all the calls that were made to AbandonTransaction.
// Check the length with:
//     len(mockedNodeClient.AbandonTransactionCalls())
func (mock *NodeClientMock) AbandonTransactionCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockAbandonTransaction.RLock()
	calls = mock.calls.AbandonTransaction
	mock.lockAbandonTransaction.RUnlock()
	return calls
}

// Account calls AccountFunc.
func (mock *NodeClientMock) Account(ctx context.Context, address string) (string, error) {
	if mock.AccountFunc == nil {
		panic("NodeClientMock.AccountFunc: method is nil but NodeClient.Account was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockAccount.Lock()
	mock.calls.Account = append(mock.calls.Account, callInfo)
	mock.lockAccount.Unlock()
	return mock.AccountFunc(ctx, address)
}

// AccountCalls gets all the calls that were made to Account.
// Check the length with:
//     len(mockedNodeClient.AccountCalls())
func (mock *NodeClientMock) AccountCalls() []struct {
	Ctx     context.Context
	Address string
} {
	var calls []struct {
		Ctx     context.Context
		Address string
	}
	mock.lockAccount.RLock()
	calls = mock.calls.Account
	mock.lockAccount.RUnlock()
	return calls
}

// AccountAddress calls AccountAddressFunc.
func (mock *NodeClientMock) AccountAddress(ctx context.Context, account string) (string, error) {
	if mock.AccountAddressFunc == nil {
		panic("NodeClientMock.AccountAddressFunc: method is nil but NodeClient.AccountAddress was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Account string
	}{
		Ctx:     ctx,
		Account: account,
	}
	mock.lockAccountAddress.Lock()
	mock.calls.AccountAddress = append(mock.calls.AccountAddress, callInfo)
	mock.lockAccountAddress.Unlock()
	return mock.AccountAddressFunc(ctx, account)
}

// AccountAddressCalls gets all the calls that were made to AccountAddress.
// Check the length with:
//     len(mockedNodeClient.AccountAddressCalls())
func (mock *NodeClientMock) AccountAddressCalls() []struct {
	Ctx     context.Context
	Account string
} {
	var calls []struct {
		Ctx     context.Context
		Account string
	}
	mock.lockAccountAddress.RLock()
	calls = mock.calls.AccountAddress
	mock.lockAccountAddress.RUnlock()
	return calls
}

// AccountAddresses calls AccountAddressesFunc.
func (mock *NodeClientMock) AccountAddresses(ctx context.Context, account string) ([]string, error) {
	if mock.AccountAddressesFunc == nil {
		panic("NodeClientMock.AccountAddressesFunc: method is nil but NodeClient.AccountAddresses was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Account string
	}{
		Ctx:     ctx,
		Account: account,
	}
	mock.lockAccountAddresses.Lock()
	mock.calls.AccountAddresses = append(mock.calls.AccountAddresses, callInfo)
	mock.lockAccountAddresses.Unlock()
	return mock.AccountAddressesFunc(ctx, account)
}

// AccountAddressesCalls gets all the calls that were made to AccountAddresses.
// Check the length with:
//     len(mockedNodeClient.AccountAddressesCalls())
func (mock *NodeClientMock) AccountAddressesCalls() []struct {
	Ctx     context.Context
	Account string
} {
	var calls []struct {
		Ctx     context.Context
		Account string
	}
	mock.lockAccountAddresses.RLock()
	calls = mock.calls.AccountAddresses
	mock.lockAccountAddresses.RUnlock()
	return calls
}

// ActiveZMQNotifications calls ActiveZMQNotificationsFunc.
func (mock *NodeClientMock) ActiveZMQNotifications(ctx context.Context) ([]*models.ZMQNotification, error) {
	if mock.ActiveZMQNotificationsFunc == nil {
		panic("NodeClientMock.ActiveZMQNotificationsFunc: method is nil but NodeClient.ActiveZMQNotifications was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockActiveZMQNotifications.Lock()
	mock.calls.ActiveZMQNotifications = append(mock.calls.ActiveZMQNotifications, callInfo)
	mock.lockActiveZMQNotifications.Unlock()
	return mock.ActiveZMQNotificationsFunc(ctx)
}

// ActiveZMQNotificationsCalls gets all the calls that were made to ActiveZMQNotifications.
// Check the length with:
//     len(mockedNodeClient.ActiveZMQNotificationsCalls())
func (mock *NodeClientMock) ActiveZMQNotificationsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockActiveZMQNotifications.RLock()
	calls = mock.calls.ActiveZMQNotifications
	mock.lockActiveZMQNotifications.RUnlock()
	return calls
}

// AddMultiSigAddress calls AddMultiSigAddressFunc.
func (mock *NodeClientMock) AddMultiSigAddress(ctx context.Context, n int, keys ...string) (string, error) {
	if mock.AddMultiSigAddressFunc == nil {
		panic("NodeClientMock.AddMultiSigAddressFunc: method is nil but NodeClient.AddMultiSigAddress was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		N    int
		Keys []string
	}{
		Ctx:  ctx,
		N:    n,
		Keys: keys,
	}
	mock.lockAddMultiSigAddress.Lock()
	mock.calls.AddMultiSigAddress = append(mock.calls.AddMultiSigAddress, callInfo)
	mock.lockAddMultiSigAddress.Unlock()
	return mock.AddMultiSigAddressFunc(ctx, n, keys...)
}

// AddMultiSigAddressCalls gets all the calls that were made to AddMultiSigAddress.
// Check the length with:
//     len(mockedNodeClient.AddMultiSigAddressCalls())
func (mock *NodeClientMock) AddMultiSigAddressCalls() []struct {
	Ctx  context.Context
	N    int
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		N    int
		Keys []string
	}
	mock.lockAddMultiSigAddress.RLock()
	calls = mock.calls.AddMultiSigAddress
	mock.lockAddMultiSigAddress.RUnlock()
	return calls
}

// AddNode calls AddNodeFunc.
func (mock *NodeClientMock) AddNode(ctx context.Context, node string, command internal.NodeAddType) error {
	if mock.AddNodeFunc == nil {
		panic("NodeClientMock.AddNodeFunc: method is nil but NodeClient.AddNode was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Node    string
		Command internal.NodeAddType
	}{
		Ctx:     ctx,
		Node:    node,
		Command: command,
	}
	mock.lockAddNode.Lock()
	mock.calls.AddNode = append(mock.calls.AddNode, callInfo)
	mock.lockAddNode.Unlock()
	return mock.AddNodeFunc(ctx, node, command)
}

// AddNodeCalls gets all the calls that were made to AddNode.
// Check the length with:
//     len(mockedNodeClient.AddNodeCalls())
func (mock *NodeClientMock) AddNodeCalls() []struct {
	Ctx     context.Context
	Node    string
	Command internal.NodeAddType
} {
	var calls []struct {
		Ctx     context.Context
		Node    string
		Command internal.NodeAddType
	}
	mock.lockAddNode.RLock()
	calls = mock.calls.AddNode
	mock.lockAddNode.RUnlock()
	return calls
}

// AddToConfiscationTransactionWhitelist calls AddToConfiscationTransactionWhitelistFunc
func (mock *NodeClientMock) AddToConfiscationTransactionWhitelist(ctx context.Context, confiscationTxs []models.ConfiscationTransactionDetails) (*models.AddToConfiscationTransactionWhitelistResponse, error) {
	if mock.AddToConfiscationTransactionWhitelistFunc == nil {
		panic("TransactionClientMock.AddToConfiscationTransactionWhitelistFunc: method is nil but TransactionClient.AddToConfiscationTransactionWhitelist was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		ConfiscationTransactions []models.ConfiscationTransactionDetails
	}{
		Ctx: ctx,
		ConfiscationTransactions: confiscationTxs,
	}
	mock.lockAddToConfiscationTransactionWhitelist.Lock()
	mock.calls.AddToConfiscationTransactionWhitelist = append(mock.calls.AddToConfiscationTransactionWhitelist, callInfo)
	mock.lockAddToConfiscationTransactionWhitelist.Unlock()
	return mock.AddToConfiscationTransactionWhitelist(ctx, confiscationTxs)
}

// AddToConsensusBlacklist calls AddToConsensusBlacklistFunc
func (mock *NodeClientMock) AddToConsensusBlacklist(ctx context.Context, funds []models.Fund) (*models.AddToConsensusBlacklistResponse, error) {
	if mock.AddToConsensusBlacklistFunc == nil {
		panic("TransactionClientMock.AddToConsensusBlacklistFunc: method is nil but TransactionClient.CreateRawTransaction was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Funds []models.Fund
	}{
		Ctx: ctx,
		Funds: funds,
	}
	mock.lockAddToConsensusBlacklist.Lock()
	mock.calls.AddToConsensusBlacklist = append(mock.calls.AddToConsensusBlacklist, callInfo)
	mock.lockAddToConsensusBlacklist.Unlock()
	return mock.AddToConsensusBlacklistFunc(ctx, funds)
}

// BackupWallet calls BackupWalletFunc.
func (mock *NodeClientMock) BackupWallet(ctx context.Context, dest string) error {
	if mock.BackupWalletFunc == nil {
		panic("NodeClientMock.BackupWalletFunc: method is nil but NodeClient.BackupWallet was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Dest string
	}{
		Ctx:  ctx,
		Dest: dest,
	}
	mock.lockBackupWallet.Lock()
	mock.calls.BackupWallet = append(mock.calls.BackupWallet, callInfo)
	mock.lockBackupWallet.Unlock()
	return mock.BackupWalletFunc(ctx, dest)
}

// BackupWalletCalls gets all the calls that were made to BackupWallet.
// Check the length with:
//     len(mockedNodeClient.BackupWalletCalls())
func (mock *NodeClientMock) BackupWalletCalls() []struct {
	Ctx  context.Context
	Dest string
} {
	var calls []struct {
		Ctx  context.Context
		Dest string
	}
	mock.lockBackupWallet.RLock()
	calls = mock.calls.BackupWallet
	mock.lockBackupWallet.RUnlock()
	return calls
}

// Balance calls BalanceFunc.
func (mock *NodeClientMock) Balance(ctx context.Context, opts *models.OptsBalance) (uint64, error) {
	if mock.BalanceFunc == nil {
		panic("NodeClientMock.BalanceFunc: method is nil but NodeClient.Balance was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsBalance
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockBalance.Lock()
	mock.calls.Balance = append(mock.calls.Balance, callInfo)
	mock.lockBalance.Unlock()
	return mock.BalanceFunc(ctx, opts)
}

// BalanceCalls gets all the calls that were made to Balance.
// Check the length with:
//     len(mockedNodeClient.BalanceCalls())
func (mock *NodeClientMock) BalanceCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsBalance
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsBalance
	}
	mock.lockBalance.RLock()
	calls = mock.calls.Balance
	mock.lockBalance.RUnlock()
	return calls
}

// BestBlockHash calls BestBlockHashFunc.
func (mock *NodeClientMock) BestBlockHash(ctx context.Context) (string, error) {
	if mock.BestBlockHashFunc == nil {
		panic("NodeClientMock.BestBlockHashFunc: method is nil but NodeClient.BestBlockHash was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockBestBlockHash.Lock()
	mock.calls.BestBlockHash = append(mock.calls.BestBlockHash, callInfo)
	mock.lockBestBlockHash.Unlock()
	return mock.BestBlockHashFunc(ctx)
}

// BestBlockHashCalls gets all the calls that were made to BestBlockHash.
// Check the length with:
//     len(mockedNodeClient.BestBlockHashCalls())
func (mock *NodeClientMock) BestBlockHashCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockBestBlockHash.RLock()
	calls = mock.calls.BestBlockHash
	mock.lockBestBlockHash.RUnlock()
	return calls
}

// Block calls BlockFunc.
func (mock *NodeClientMock) Block(ctx context.Context, hash string) (*models.Block, error) {
	if mock.BlockFunc == nil {
		panic("NodeClientMock.BlockFunc: method is nil but NodeClient.Block was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash string
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockBlock.Lock()
	mock.calls.Block = append(mock.calls.Block, callInfo)
	mock.lockBlock.Unlock()
	return mock.BlockFunc(ctx, hash)
}

// BlockCalls gets all the calls that were made to Block.
// Check the length with:
//     len(mockedNodeClient.BlockCalls())
func (mock *NodeClientMock) BlockCalls() []struct {
	Ctx  context.Context
	Hash string
} {
	var calls []struct {
		Ctx  context.Context
		Hash string
	}
	mock.lockBlock.RLock()
	calls = mock.calls.Block
	mock.lockBlock.RUnlock()
	return calls
}

// BlockByHeight calls BlockByHeightFunc.
func (mock *NodeClientMock) BlockByHeight(ctx context.Context, height int) (*models.Block, error) {
	if mock.BlockByHeightFunc == nil {
		panic("NodeClientMock.BlockByHeightFunc: method is nil but NodeClient.BlockByHeight was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height int
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockBlockByHeight.Lock()
	mock.calls.BlockByHeight = append(mock.calls.BlockByHeight, callInfo)
	mock.lockBlockByHeight.Unlock()
	return mock.BlockByHeightFunc(ctx, height)
}

// BlockByHeightCalls gets all the calls that were made to BlockByHeight.
// Check the length with:
//     len(mockedNodeClient.BlockByHeightCalls())
func (mock *NodeClientMock) BlockByHeightCalls() []struct {
	Ctx    context.Context
	Height int
} {
	var calls []struct {
		Ctx    context.Context
		Height int
	}
	mock.lockBlockByHeight.RLock()
	calls = mock.calls.BlockByHeight
	mock.lockBlockByHeight.RUnlock()
	return calls
}

// BlockCount calls BlockCountFunc.
func (mock *NodeClientMock) BlockCount(ctx context.Context) (uint32, error) {
	if mock.BlockCountFunc == nil {
		panic("NodeClientMock.BlockCountFunc: method is nil but NodeClient.BlockCount was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockBlockCount.Lock()
	mock.calls.BlockCount = append(mock.calls.BlockCount, callInfo)
	mock.lockBlockCount.Unlock()
	return mock.BlockCountFunc(ctx)
}

// BlockCountCalls gets all the calls that were made to BlockCount.
// Check the length with:
//     len(mockedNodeClient.BlockCountCalls())
func (mock *NodeClientMock) BlockCountCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockBlockCount.RLock()
	calls = mock.calls.BlockCount
	mock.lockBlockCount.RUnlock()
	return calls
}

// BlockDecodeHeader calls BlockDecodeHeaderFunc.
func (mock *NodeClientMock) BlockDecodeHeader(ctx context.Context, hash string) (*models.BlockDecodeHeader, error) {
	if mock.BlockDecodeHeaderFunc == nil {
		panic("NodeClientMock.BlockDecodeHeaderFunc: method is nil but NodeClient.BlockDecodeHeader was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash string
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockBlockDecodeHeader.Lock()
	mock.calls.BlockDecodeHeader = append(mock.calls.BlockDecodeHeader, callInfo)
	mock.lockBlockDecodeHeader.Unlock()
	return mock.BlockDecodeHeaderFunc(ctx, hash)
}

// BlockDecodeHeaderCalls gets all the calls that were made to BlockDecodeHeader.
// Check the length with:
//     len(mockedNodeClient.BlockDecodeHeaderCalls())
func (mock *NodeClientMock) BlockDecodeHeaderCalls() []struct {
	Ctx  context.Context
	Hash string
} {
	var calls []struct {
		Ctx  context.Context
		Hash string
	}
	mock.lockBlockDecodeHeader.RLock()
	calls = mock.calls.BlockDecodeHeader
	mock.lockBlockDecodeHeader.RUnlock()
	return calls
}

// BlockDecodeHeaderByHeight calls BlockDecodeHeaderByHeightFunc.
func (mock *NodeClientMock) BlockDecodeHeaderByHeight(ctx context.Context, height int) (*models.BlockDecodeHeader, error) {
	if mock.BlockDecodeHeaderByHeightFunc == nil {
		panic("NodeClientMock.BlockDecodeHeaderByHeightFunc: method is nil but NodeClient.BlockDecodeHeaderByHeight was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height int
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockBlockDecodeHeaderByHeight.Lock()
	mock.calls.BlockDecodeHeaderByHeight = append(mock.calls.BlockDecodeHeaderByHeight, callInfo)
	mock.lockBlockDecodeHeaderByHeight.Unlock()
	return mock.BlockDecodeHeaderByHeightFunc(ctx, height)
}

// BlockDecodeHeaderByHeightCalls gets all the calls that were made to BlockDecodeHeaderByHeight.
// Check the length with:
//     len(mockedNodeClient.BlockDecodeHeaderByHeightCalls())
func (mock *NodeClientMock) BlockDecodeHeaderByHeightCalls() []struct {
	Ctx    context.Context
	Height int
} {
	var calls []struct {
		Ctx    context.Context
		Height int
	}
	mock.lockBlockDecodeHeaderByHeight.RLock()
	calls = mock.calls.BlockDecodeHeaderByHeight
	mock.lockBlockDecodeHeaderByHeight.RUnlock()
	return calls
}

// BlockHash calls BlockHashFunc.
func (mock *NodeClientMock) BlockHash(ctx context.Context, height int) (string, error) {
	if mock.BlockHashFunc == nil {
		panic("NodeClientMock.BlockHashFunc: method is nil but NodeClient.BlockHash was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height int
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockBlockHash.Lock()
	mock.calls.BlockHash = append(mock.calls.BlockHash, callInfo)
	mock.lockBlockHash.Unlock()
	return mock.BlockHashFunc(ctx, height)
}

// BlockHashCalls gets all the calls that were made to BlockHash.
// Check the length with:
//     len(mockedNodeClient.BlockHashCalls())
func (mock *NodeClientMock) BlockHashCalls() []struct {
	Ctx    context.Context
	Height int
} {
	var calls []struct {
		Ctx    context.Context
		Height int
	}
	mock.lockBlockHash.RLock()
	calls = mock.calls.BlockHash
	mock.lockBlockHash.RUnlock()
	return calls
}

// BlockHeader calls BlockHeaderFunc.
func (mock *NodeClientMock) BlockHeader(ctx context.Context, hash string) (*models.BlockHeader, error) {
	if mock.BlockHeaderFunc == nil {
		panic("NodeClientMock.BlockHeaderFunc: method is nil but NodeClient.BlockHeader was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash string
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockBlockHeader.Lock()
	mock.calls.BlockHeader = append(mock.calls.BlockHeader, callInfo)
	mock.lockBlockHeader.Unlock()
	return mock.BlockHeaderFunc(ctx, hash)
}

// BlockHeaderCalls gets all the calls that were made to BlockHeader.
// Check the length with:
//     len(mockedNodeClient.BlockHeaderCalls())
func (mock *NodeClientMock) BlockHeaderCalls() []struct {
	Ctx  context.Context
	Hash string
} {
	var calls []struct {
		Ctx  context.Context
		Hash string
	}
	mock.lockBlockHeader.RLock()
	calls = mock.calls.BlockHeader
	mock.lockBlockHeader.RUnlock()
	return calls
}

// BlockHeaderHex calls BlockHeaderHexFunc.
func (mock *NodeClientMock) BlockHeaderHex(ctx context.Context, hash string) (string, error) {
	if mock.BlockHeaderHexFunc == nil {
		panic("NodeClientMock.BlockHeaderHexFunc: method is nil but NodeClient.BlockHeaderHex was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash string
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockBlockHeaderHex.Lock()
	mock.calls.BlockHeaderHex = append(mock.calls.BlockHeaderHex, callInfo)
	mock.lockBlockHeaderHex.Unlock()
	return mock.BlockHeaderHexFunc(ctx, hash)
}

// BlockHeaderHexCalls gets all the calls that were made to BlockHeaderHex.
// Check the length with:
//     len(mockedNodeClient.BlockHeaderHexCalls())
func (mock *NodeClientMock) BlockHeaderHexCalls() []struct {
	Ctx  context.Context
	Hash string
} {
	var calls []struct {
		Ctx  context.Context
		Hash string
	}
	mock.lockBlockHeaderHex.RLock()
	calls = mock.calls.BlockHeaderHex
	mock.lockBlockHeaderHex.RUnlock()
	return calls
}

// BlockHex calls BlockHexFunc.
func (mock *NodeClientMock) BlockHex(ctx context.Context, hash string) (string, error) {
	if mock.BlockHexFunc == nil {
		panic("NodeClientMock.BlockHexFunc: method is nil but NodeClient.BlockHex was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash string
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockBlockHex.Lock()
	mock.calls.BlockHex = append(mock.calls.BlockHex, callInfo)
	mock.lockBlockHex.Unlock()
	return mock.BlockHexFunc(ctx, hash)
}

// BlockHexCalls gets all the calls that were made to BlockHex.
// Check the length with:
//     len(mockedNodeClient.BlockHexCalls())
func (mock *NodeClientMock) BlockHexCalls() []struct {
	Ctx  context.Context
	Hash string
} {
	var calls []struct {
		Ctx  context.Context
		Hash string
	}
	mock.lockBlockHex.RLock()
	calls = mock.calls.BlockHex
	mock.lockBlockHex.RUnlock()
	return calls
}

// BlockHexByHeight calls BlockHexByHeightFunc.
func (mock *NodeClientMock) BlockHexByHeight(ctx context.Context, height int) (string, error) {
	if mock.BlockHexByHeightFunc == nil {
		panic("NodeClientMock.BlockHexByHeightFunc: method is nil but NodeClient.BlockHexByHeight was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height int
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockBlockHexByHeight.Lock()
	mock.calls.BlockHexByHeight = append(mock.calls.BlockHexByHeight, callInfo)
	mock.lockBlockHexByHeight.Unlock()
	return mock.BlockHexByHeightFunc(ctx, height)
}

// BlockHexByHeightCalls gets all the calls that were made to BlockHexByHeight.
// Check the length with:
//     len(mockedNodeClient.BlockHexByHeightCalls())
func (mock *NodeClientMock) BlockHexByHeightCalls() []struct {
	Ctx    context.Context
	Height int
} {
	var calls []struct {
		Ctx    context.Context
		Height int
	}
	mock.lockBlockHexByHeight.RLock()
	calls = mock.calls.BlockHexByHeight
	mock.lockBlockHexByHeight.RUnlock()
	return calls
}

// BlockStats calls BlockStatsFunc.
func (mock *NodeClientMock) BlockStats(ctx context.Context, hash string, fields ...string) (*models.BlockStats, error) {
	if mock.BlockStatsFunc == nil {
		panic("NodeClientMock.BlockStatsFunc: method is nil but NodeClient.BlockStats was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Hash   string
		Fields []string
	}{
		Ctx:    ctx,
		Hash:   hash,
		Fields: fields,
	}
	mock.lockBlockStats.Lock()
	mock.calls.BlockStats = append(mock.calls.BlockStats, callInfo)
	mock.lockBlockStats.Unlock()
	return mock.BlockStatsFunc(ctx, hash, fields...)
}

// BlockStatsCalls gets all the calls that were made to BlockStats.
// Check the length with:
//     len(mockedNodeClient.BlockStatsCalls())
func (mock *NodeClientMock) BlockStatsCalls() []struct {
	Ctx    context.Context
	Hash   string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Hash   string
		Fields []string
	}
	mock.lockBlockStats.RLock()
	calls = mock.calls.BlockStats
	mock.lockBlockStats.RUnlock()
	return calls
}

// BlockStatsByHeight calls BlockStatsByHeightFunc.
func (mock *NodeClientMock) BlockStatsByHeight(ctx context.Context, height int, fields ...string) (*models.BlockStats, error) {
	if mock.BlockStatsByHeightFunc == nil {
		panic("NodeClientMock.BlockStatsByHeightFunc: method is nil but NodeClient.BlockStatsByHeight was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height int
		Fields []string
	}{
		Ctx:    ctx,
		Height: height,
		Fields: fields,
	}
	mock.lockBlockStatsByHeight.Lock()
	mock.calls.BlockStatsByHeight = append(mock.calls.BlockStatsByHeight, callInfo)
	mock.lockBlockStatsByHeight.Unlock()
	return mock.BlockStatsByHeightFunc(ctx, height, fields...)
}

// BlockStatsByHeightCalls gets all the calls that were made to BlockStatsByHeight.
// Check the length with:
//     len(mockedNodeClient.BlockStatsByHeightCalls())
func (mock *NodeClientMock) BlockStatsByHeightCalls() []struct {
	Ctx    context.Context
	Height int
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Height int
		Fields []string
	}
	mock.lockBlockStatsByHeight.RLock()
	calls = mock.calls.BlockStatsByHeight
	mock.lockBlockStatsByHeight.RUnlock()
	return calls
}

// BlockTemplate calls BlockTemplateFunc.
func (mock *NodeClientMock) BlockTemplate(ctx context.Context, opts *models.BlockTemplateRequest) (*models.BlockTemplate, error) {
	if mock.BlockTemplateFunc == nil {
		panic("NodeClientMock.BlockTemplateFunc: method is nil but NodeClient.BlockTemplate was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.BlockTemplateRequest
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockBlockTemplate.Lock()
	mock.calls.BlockTemplate = append(mock.calls.BlockTemplate, callInfo)
	mock.lockBlockTemplate.Unlock()
	return mock.BlockTemplateFunc(ctx, opts)
}

// BlockTemplateCalls gets all the calls that were made to BlockTemplate.
// Check the length with:
//     len(mockedNodeClient.BlockTemplateCalls())
func (mock *NodeClientMock) BlockTemplateCalls() []struct {
	Ctx  context.Context
	Opts *models.BlockTemplateRequest
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.BlockTemplateRequest
	}
	mock.lockBlockTemplate.RLock()
	calls = mock.calls.BlockTemplate
	mock.lockBlockTemplate.RUnlock()
	return calls
}

// ChainInfo calls ChainInfoFunc.
func (mock *NodeClientMock) ChainInfo(ctx context.Context) (*models.ChainInfo, error) {
	if mock.ChainInfoFunc == nil {
		panic("NodeClientMock.ChainInfoFunc: method is nil but NodeClient.ChainInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockChainInfo.Lock()
	mock.calls.ChainInfo = append(mock.calls.ChainInfo, callInfo)
	mock.lockChainInfo.Unlock()
	return mock.ChainInfoFunc(ctx)
}

// ChainInfoCalls gets all the calls that were made to ChainInfo.
// Check the length with:
//     len(mockedNodeClient.ChainInfoCalls())
func (mock *NodeClientMock) ChainInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockChainInfo.RLock()
	calls = mock.calls.ChainInfo
	mock.lockChainInfo.RUnlock()
	return calls
}

// ChainTips calls ChainTipsFunc.
func (mock *NodeClientMock) ChainTips(ctx context.Context) ([]*models.ChainTip, error) {
	if mock.ChainTipsFunc == nil {
		panic("NodeClientMock.ChainTipsFunc: method is nil but NodeClient.ChainTips was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockChainTips.Lock()
	mock.calls.ChainTips = append(mock.calls.ChainTips, callInfo)
	mock.lockChainTips.Unlock()
	return mock.ChainTipsFunc(ctx)
}

// ChainTipsCalls gets all the calls that were made to ChainTips.
// Check the length with:
//     len(mockedNodeClient.ChainTipsCalls())
func (mock *NodeClientMock) ChainTipsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockChainTips.RLock()
	calls = mock.calls.ChainTips
	mock.lockChainTips.RUnlock()
	return calls
}

// ChainTxStats calls ChainTxStatsFunc.
func (mock *NodeClientMock) ChainTxStats(ctx context.Context, opts *models.OptsChainTxStats) (*models.ChainTxStats, error) {
	if mock.ChainTxStatsFunc == nil {
		panic("NodeClientMock.ChainTxStatsFunc: method is nil but NodeClient.ChainTxStats was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsChainTxStats
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockChainTxStats.Lock()
	mock.calls.ChainTxStats = append(mock.calls.ChainTxStats, callInfo)
	mock.lockChainTxStats.Unlock()
	return mock.ChainTxStatsFunc(ctx, opts)
}

// ChainTxStatsCalls gets all the calls that were made to ChainTxStats.
// Check the length with:
//     len(mockedNodeClient.ChainTxStatsCalls())
func (mock *NodeClientMock) ChainTxStatsCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsChainTxStats
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsChainTxStats
	}
	mock.lockChainTxStats.RLock()
	calls = mock.calls.ChainTxStats
	mock.lockChainTxStats.RUnlock()
	return calls
}

// CheckJournal calls CheckJournalFunc.
func (mock *NodeClientMock) CheckJournal(ctx context.Context) (*models.JournalStatus, error) {
	if mock.CheckJournalFunc == nil {
		panic("NodeClientMock.CheckJournalFunc: method is nil but NodeClient.CheckJournal was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCheckJournal.Lock()
	mock.calls.CheckJournal = append(mock.calls.CheckJournal, callInfo)
	mock.lockCheckJournal.Unlock()
	return mock.CheckJournalFunc(ctx)
}

// CheckJournalCalls gets all the calls that were made to CheckJournal.
// Check the length with:
//     len(mockedNodeClient.CheckJournalCalls())
func (mock *NodeClientMock) CheckJournalCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCheckJournal.RLock()
	calls = mock.calls.CheckJournal
	mock.lockCheckJournal.RUnlock()
	return calls
}

// ClearBanned calls ClearBannedFunc.
func (mock *NodeClientMock) ClearBanned(ctx context.Context) error {
	if mock.ClearBannedFunc == nil {
		panic("NodeClientMock.ClearBannedFunc: method is nil but NodeClient.ClearBanned was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClearBanned.Lock()
	mock.calls.ClearBanned = append(mock.calls.ClearBanned, callInfo)
	mock.lockClearBanned.Unlock()
	return mock.ClearBannedFunc(ctx)
}

// ClearBannedCalls gets all the calls that were made to ClearBanned.
// Check the length with:
//     len(mockedNodeClient.ClearBannedCalls())
func (mock *NodeClientMock) ClearBannedCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClearBanned.RLock()
	calls = mock.calls.ClearBanned
	mock.lockClearBanned.RUnlock()
	return calls
}

// ClearInvalidTransactions calls ClearInvalidTransactionsFunc.
func (mock *NodeClientMock) ClearInvalidTransactions(ctx context.Context) (uint64, error) {
	if mock.ClearInvalidTransactionsFunc == nil {
		panic("NodeClientMock.ClearInvalidTransactionsFunc: method is nil but NodeClient.ClearInvalidTransactions was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClearInvalidTransactions.Lock()
	mock.calls.ClearInvalidTransactions = append(mock.calls.ClearInvalidTransactions, callInfo)
	mock.lockClearInvalidTransactions.Unlock()
	return mock.ClearInvalidTransactionsFunc(ctx)
}

// ClearInvalidTransactionsCalls gets all the calls that were made to ClearInvalidTransactions.
// Check the length with:
//     len(mockedNodeClient.ClearInvalidTransactionsCalls())
func (mock *NodeClientMock) ClearInvalidTransactionsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClearInvalidTransactions.RLock()
	calls = mock.calls.ClearInvalidTransactions
	mock.lockClearInvalidTransactions.RUnlock()
	return calls
}

// ConnectionCount calls ConnectionCountFunc.
func (mock *NodeClientMock) ConnectionCount(ctx context.Context) (uint64, error) {
	if mock.ConnectionCountFunc == nil {
		panic("NodeClientMock.ConnectionCountFunc: method is nil but NodeClient.ConnectionCount was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockConnectionCount.Lock()
	mock.calls.ConnectionCount = append(mock.calls.ConnectionCount, callInfo)
	mock.lockConnectionCount.Unlock()
	return mock.ConnectionCountFunc(ctx)
}

// ConnectionCountCalls gets all the calls that were made to ConnectionCount.
// Check the length with:
//     len(mockedNodeClient.ConnectionCountCalls())
func (mock *NodeClientMock) ConnectionCountCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockConnectionCount.RLock()
	calls = mock.calls.ConnectionCount
	mock.lockConnectionCount.RUnlock()
	return calls
}

// CreateMultiSig calls CreateMultiSigFunc.
func (mock *NodeClientMock) CreateMultiSig(ctx context.Context, n int, keys ...string) (*models.MultiSig, error) {
	if mock.CreateMultiSigFunc == nil {
		panic("NodeClientMock.CreateMultiSigFunc: method is nil but NodeClient.CreateMultiSig was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		N    int
		Keys []string
	}{
		Ctx:  ctx,
		N:    n,
		Keys: keys,
	}
	mock.lockCreateMultiSig.Lock()
	mock.calls.CreateMultiSig = append(mock.calls.CreateMultiSig, callInfo)
	mock.lockCreateMultiSig.Unlock()
	return mock.CreateMultiSigFunc(ctx, n, keys...)
}

// CreateMultiSigCalls gets all the calls that were made to CreateMultiSig.
// Check the length with:
//     len(mockedNodeClient.CreateMultiSigCalls())
func (mock *NodeClientMock) CreateMultiSigCalls() []struct {
	Ctx  context.Context
	N    int
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		N    int
		Keys []string
	}
	mock.lockCreateMultiSig.RLock()
	calls = mock.calls.CreateMultiSig
	mock.lockCreateMultiSig.RUnlock()
	return calls
}

// CreateRawTransaction calls CreateRawTransactionFunc.
func (mock *NodeClientMock) CreateRawTransaction(ctx context.Context, utxos bt.UTXOs, params models.ParamsCreateRawTransaction) (*bt.Tx, error) {
	if mock.CreateRawTransactionFunc == nil {
		panic("NodeClientMock.CreateRawTransactionFunc: method is nil but NodeClient.CreateRawTransaction was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Utxos  bt.UTXOs
		Params models.ParamsCreateRawTransaction
	}{
		Ctx:    ctx,
		Utxos:  utxos,
		Params: params,
	}
	mock.lockCreateRawTransaction.Lock()
	mock.calls.CreateRawTransaction = append(mock.calls.CreateRawTransaction, callInfo)
	mock.lockCreateRawTransaction.Unlock()
	return mock.CreateRawTransactionFunc(ctx, utxos, params)
}

// CreateRawTransactionCalls gets all the calls that were made to CreateRawTransaction.
// Check the length with:
//     len(mockedNodeClient.CreateRawTransactionCalls())
func (mock *NodeClientMock) CreateRawTransactionCalls() []struct {
	Ctx    context.Context
	Utxos  bt.UTXOs
	Params models.ParamsCreateRawTransaction
} {
	var calls []struct {
		Ctx    context.Context
		Utxos  bt.UTXOs
		Params models.ParamsCreateRawTransaction
	}
	mock.lockCreateRawTransaction.RLock()
	calls = mock.calls.CreateRawTransaction
	mock.lockCreateRawTransaction.RUnlock()
	return calls
}

// Difficulty calls DifficultyFunc.
func (mock *NodeClientMock) Difficulty(ctx context.Context) (float64, error) {
	if mock.DifficultyFunc == nil {
		panic("NodeClientMock.DifficultyFunc: method is nil but NodeClient.Difficulty was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockDifficulty.Lock()
	mock.calls.Difficulty = append(mock.calls.Difficulty, callInfo)
	mock.lockDifficulty.Unlock()
	return mock.DifficultyFunc(ctx)
}

// DifficultyCalls gets all the calls that were made to Difficulty.
// Check the length with:
//     len(mockedNodeClient.DifficultyCalls())
func (mock *NodeClientMock) DifficultyCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockDifficulty.RLock()
	calls = mock.calls.Difficulty
	mock.lockDifficulty.RUnlock()
	return calls
}

// DisconnectNode calls DisconnectNodeFunc.
func (mock *NodeClientMock) DisconnectNode(ctx context.Context, params models.ParamsDisconnectNode) error {
	if mock.DisconnectNodeFunc == nil {
		panic("NodeClientMock.DisconnectNodeFunc: method is nil but NodeClient.DisconnectNode was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params models.ParamsDisconnectNode
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockDisconnectNode.Lock()
	mock.calls.DisconnectNode = append(mock.calls.DisconnectNode, callInfo)
	mock.lockDisconnectNode.Unlock()
	return mock.DisconnectNodeFunc(ctx, params)
}

// DisconnectNodeCalls gets all the calls that were made to DisconnectNode.
// Check the length with:
//     len(mockedNodeClient.DisconnectNodeCalls())
func (mock *NodeClientMock) DisconnectNodeCalls() []struct {
	Ctx    context.Context
	Params models.ParamsDisconnectNode
} {
	var calls []struct {
		Ctx    context.Context
		Params models.ParamsDisconnectNode
	}
	mock.lockDisconnectNode.RLock()
	calls = mock.calls.DisconnectNode
	mock.lockDisconnectNode.RUnlock()
	return calls
}

// DumpParams calls DumpParamsFunc.
func (mock *NodeClientMock) DumpParams(ctx context.Context) ([]string, error) {
	if mock.DumpParamsFunc == nil {
		panic("NodeClientMock.DumpParamsFunc: method is nil but NodeClient.DumpParams was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockDumpParams.Lock()
	mock.calls.DumpParams = append(mock.calls.DumpParams, callInfo)
	mock.lockDumpParams.Unlock()
	return mock.DumpParamsFunc(ctx)
}

// DumpParamsCalls gets all the calls that were made to DumpParams.
// Check the length with:
//     len(mockedNodeClient.DumpParamsCalls())
func (mock *NodeClientMock) DumpParamsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockDumpParams.RLock()
	calls = mock.calls.DumpParams
	mock.lockDumpParams.RUnlock()
	return calls
}

// DumpPrivateKey calls DumpPrivateKeyFunc.
func (mock *NodeClientMock) DumpPrivateKey(ctx context.Context, address string) (*wif.WIF, error) {
	if mock.DumpPrivateKeyFunc == nil {
		panic("NodeClientMock.DumpPrivateKeyFunc: method is nil but NodeClient.DumpPrivateKey was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockDumpPrivateKey.Lock()
	mock.calls.DumpPrivateKey = append(mock.calls.DumpPrivateKey, callInfo)
	mock.lockDumpPrivateKey.Unlock()
	return mock.DumpPrivateKeyFunc(ctx, address)
}

// DumpPrivateKeyCalls gets all the calls that were made to DumpPrivateKey.
// Check the length with:
//     len(mockedNodeClient.DumpPrivateKeyCalls())
func (mock *NodeClientMock) DumpPrivateKeyCalls() []struct {
	Ctx     context.Context
	Address string
} {
	var calls []struct {
		Ctx     context.Context
		Address string
	}
	mock.lockDumpPrivateKey.RLock()
	calls = mock.calls.DumpPrivateKey
	mock.lockDumpPrivateKey.RUnlock()
	return calls
}

// DumpWallet calls DumpWalletFunc.
func (mock *NodeClientMock) DumpWallet(ctx context.Context, dest string) (*models.DumpWallet, error) {
	if mock.DumpWalletFunc == nil {
		panic("NodeClientMock.DumpWalletFunc: method is nil but NodeClient.DumpWallet was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Dest string
	}{
		Ctx:  ctx,
		Dest: dest,
	}
	mock.lockDumpWallet.Lock()
	mock.calls.DumpWallet = append(mock.calls.DumpWallet, callInfo)
	mock.lockDumpWallet.Unlock()
	return mock.DumpWalletFunc(ctx, dest)
}

// DumpWalletCalls gets all the calls that were made to DumpWallet.
// Check the length with:
//     len(mockedNodeClient.DumpWalletCalls())
func (mock *NodeClientMock) DumpWalletCalls() []struct {
	Ctx  context.Context
	Dest string
} {
	var calls []struct {
		Ctx  context.Context
		Dest string
	}
	mock.lockDumpWallet.RLock()
	calls = mock.calls.DumpWallet
	mock.lockDumpWallet.RUnlock()
	return calls
}

// EncryptWallet calls EncryptWalletFunc.
func (mock *NodeClientMock) EncryptWallet(ctx context.Context, passphrase string) error {
	if mock.EncryptWalletFunc == nil {
		panic("NodeClientMock.EncryptWalletFunc: method is nil but NodeClient.EncryptWallet was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Passphrase string
	}{
		Ctx:        ctx,
		Passphrase: passphrase,
	}
	mock.lockEncryptWallet.Lock()
	mock.calls.EncryptWallet = append(mock.calls.EncryptWallet, callInfo)
	mock.lockEncryptWallet.Unlock()
	return mock.EncryptWalletFunc(ctx, passphrase)
}

// EncryptWalletCalls gets all the calls that were made to EncryptWallet.
// Check the length with:
//     len(mockedNodeClient.EncryptWalletCalls())
func (mock *NodeClientMock) EncryptWalletCalls() []struct {
	Ctx        context.Context
	Passphrase string
} {
	var calls []struct {
		Ctx        context.Context
		Passphrase string
	}
	mock.lockEncryptWallet.RLock()
	calls = mock.calls.EncryptWallet
	mock.lockEncryptWallet.RUnlock()
	return calls
}

// ExcessiveBlock calls ExcessiveBlockFunc.
func (mock *NodeClientMock) ExcessiveBlock(ctx context.Context) (*models.ExcessiveBlock, error) {
	if mock.ExcessiveBlockFunc == nil {
		panic("NodeClientMock.ExcessiveBlockFunc: method is nil but NodeClient.ExcessiveBlock was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockExcessiveBlock.Lock()
	mock.calls.ExcessiveBlock = append(mock.calls.ExcessiveBlock, callInfo)
	mock.lockExcessiveBlock.Unlock()
	return mock.ExcessiveBlockFunc(ctx)
}

// ExcessiveBlockCalls gets all the calls that were made to ExcessiveBlock.
// Check the length with:
//     len(mockedNodeClient.ExcessiveBlockCalls())
func (mock *NodeClientMock) ExcessiveBlockCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockExcessiveBlock.RLock()
	calls = mock.calls.ExcessiveBlock
	mock.lockExcessiveBlock.RUnlock()
	return calls
}

// FundRawTransaction calls FundRawTransactionFunc.
func (mock *NodeClientMock) FundRawTransaction(ctx context.Context, tx *bt.Tx, opts *models.OptsFundRawTransaction) (*models.FundRawTransaction, error) {
	if mock.FundRawTransactionFunc == nil {
		panic("NodeClientMock.FundRawTransactionFunc: method is nil but NodeClient.FundRawTransaction was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Tx   *bt.Tx
		Opts *models.OptsFundRawTransaction
	}{
		Ctx:  ctx,
		Tx:   tx,
		Opts: opts,
	}
	mock.lockFundRawTransaction.Lock()
	mock.calls.FundRawTransaction = append(mock.calls.FundRawTransaction, callInfo)
	mock.lockFundRawTransaction.Unlock()
	return mock.FundRawTransactionFunc(ctx, tx, opts)
}

// FundRawTransactionCalls gets all the calls that were made to FundRawTransaction.
// Check the length with:
//     len(mockedNodeClient.FundRawTransactionCalls())
func (mock *NodeClientMock) FundRawTransactionCalls() []struct {
	Ctx  context.Context
	Tx   *bt.Tx
	Opts *models.OptsFundRawTransaction
} {
	var calls []struct {
		Ctx  context.Context
		Tx   *bt.Tx
		Opts *models.OptsFundRawTransaction
	}
	mock.lockFundRawTransaction.RLock()
	calls = mock.calls.FundRawTransaction
	mock.lockFundRawTransaction.RUnlock()
	return calls
}

// Generate calls GenerateFunc.
func (mock *NodeClientMock) Generate(ctx context.Context, n int, opts *models.OptsGenerate) ([]string, error) {
	if mock.GenerateFunc == nil {
		panic("NodeClientMock.GenerateFunc: method is nil but NodeClient.Generate was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		N    int
		Opts *models.OptsGenerate
	}{
		Ctx:  ctx,
		N:    n,
		Opts: opts,
	}
	mock.lockGenerate.Lock()
	mock.calls.Generate = append(mock.calls.Generate, callInfo)
	mock.lockGenerate.Unlock()
	return mock.GenerateFunc(ctx, n, opts)
}

// GenerateCalls gets all the calls that were made to Generate.
// Check the length with:
//     len(mockedNodeClient.GenerateCalls())
func (mock *NodeClientMock) GenerateCalls() []struct {
	Ctx  context.Context
	N    int
	Opts *models.OptsGenerate
} {
	var calls []struct {
		Ctx  context.Context
		N    int
		Opts *models.OptsGenerate
	}
	mock.lockGenerate.RLock()
	calls = mock.calls.Generate
	mock.lockGenerate.RUnlock()
	return calls
}

// GenerateToAddress calls GenerateToAddressFunc.
func (mock *NodeClientMock) GenerateToAddress(ctx context.Context, n int, addr string, opts *models.OptsGenerate) ([]string, error) {
	if mock.GenerateToAddressFunc == nil {
		panic("NodeClientMock.GenerateToAddressFunc: method is nil but NodeClient.GenerateToAddress was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		N    int
		Addr string
		Opts *models.OptsGenerate
	}{
		Ctx:  ctx,
		N:    n,
		Addr: addr,
		Opts: opts,
	}
	mock.lockGenerateToAddress.Lock()
	mock.calls.GenerateToAddress = append(mock.calls.GenerateToAddress, callInfo)
	mock.lockGenerateToAddress.Unlock()
	return mock.GenerateToAddressFunc(ctx, n, addr, opts)
}

// GenerateToAddressCalls gets all the calls that were made to GenerateToAddress.
// Check the length with:
//     len(mockedNodeClient.GenerateToAddressCalls())
func (mock *NodeClientMock) GenerateToAddressCalls() []struct {
	Ctx  context.Context
	N    int
	Addr string
	Opts *models.OptsGenerate
} {
	var calls []struct {
		Ctx  context.Context
		N    int
		Addr string
		Opts *models.OptsGenerate
	}
	mock.lockGenerateToAddress.RLock()
	calls = mock.calls.GenerateToAddress
	mock.lockGenerateToAddress.RUnlock()
	return calls
}

// ImportAddress calls ImportAddressFunc.
func (mock *NodeClientMock) ImportAddress(ctx context.Context, address string, opts *models.OptsImportAddress) error {
	if mock.ImportAddressFunc == nil {
		panic("NodeClientMock.ImportAddressFunc: method is nil but NodeClient.ImportAddress was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
		Opts    *models.OptsImportAddress
	}{
		Ctx:     ctx,
		Address: address,
		Opts:    opts,
	}
	mock.lockImportAddress.Lock()
	mock.calls.ImportAddress = append(mock.calls.ImportAddress, callInfo)
	mock.lockImportAddress.Unlock()
	return mock.ImportAddressFunc(ctx, address, opts)
}

// ImportAddressCalls gets all the calls that were made to ImportAddress.
// Check the length with:
//     len(mockedNodeClient.ImportAddressCalls())
func (mock *NodeClientMock) ImportAddressCalls() []struct {
	Ctx     context.Context
	Address string
	Opts    *models.OptsImportAddress
} {
	var calls []struct {
		Ctx     context.Context
		Address string
		Opts    *models.OptsImportAddress
	}
	mock.lockImportAddress.RLock()
	calls = mock.calls.ImportAddress
	mock.lockImportAddress.RUnlock()
	return calls
}

// ImportMulti calls ImportMultiFunc.
func (mock *NodeClientMock) ImportMulti(ctx context.Context, reqs []models.ImportMultiRequest, opts *models.OptsImportMulti) ([]*models.ImportMulti, error) {
	if mock.ImportMultiFunc == nil {
		panic("NodeClientMock.ImportMultiFunc: method is nil but NodeClient.ImportMulti was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Reqs []models.ImportMultiRequest
		Opts *models.OptsImportMulti
	}{
		Ctx:  ctx,
		Reqs: reqs,
		Opts: opts,
	}
	mock.lockImportMulti.Lock()
	mock.calls.ImportMulti = append(mock.calls.ImportMulti, callInfo)
	mock.lockImportMulti.Unlock()
	return mock.ImportMultiFunc(ctx, reqs, opts)
}

// ImportMultiCalls gets all the calls that were made to ImportMulti.
// Check the length with:
//     len(mockedNodeClient.ImportMultiCalls())
func (mock *NodeClientMock) ImportMultiCalls() []struct {
	Ctx  context.Context
	Reqs []models.ImportMultiRequest
	Opts *models.OptsImportMulti
} {
	var calls []struct {
		Ctx  context.Context
		Reqs []models.ImportMultiRequest
		Opts *models.OptsImportMulti
	}
	mock.lockImportMulti.RLock()
	calls = mock.calls.ImportMulti
	mock.lockImportMulti.RUnlock()
	return calls
}

// ImportPrivateKey calls ImportPrivateKeyFunc.
func (mock *NodeClientMock) ImportPrivateKey(ctx context.Context, w *wif.WIF, opts *models.OptsImportPrivateKey) error {
	if mock.ImportPrivateKeyFunc == nil {
		panic("NodeClientMock.ImportPrivateKeyFunc: method is nil but NodeClient.ImportPrivateKey was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		W    *wif.WIF
		Opts *models.OptsImportPrivateKey
	}{
		Ctx:  ctx,
		W:    w,
		Opts: opts,
	}
	mock.lockImportPrivateKey.Lock()
	mock.calls.ImportPrivateKey = append(mock.calls.ImportPrivateKey, callInfo)
	mock.lockImportPrivateKey.Unlock()
	return mock.ImportPrivateKeyFunc(ctx, w, opts)
}

// ImportPrivateKeyCalls gets all the calls that were made to ImportPrivateKey.
// Check the length with:
//     len(mockedNodeClient.ImportPrivateKeyCalls())
func (mock *NodeClientMock) ImportPrivateKeyCalls() []struct {
	Ctx  context.Context
	W    *wif.WIF
	Opts *models.OptsImportPrivateKey
} {
	var calls []struct {
		Ctx  context.Context
		W    *wif.WIF
		Opts *models.OptsImportPrivateKey
	}
	mock.lockImportPrivateKey.RLock()
	calls = mock.calls.ImportPrivateKey
	mock.lockImportPrivateKey.RUnlock()
	return calls
}

// ImportPrunedFunds calls ImportPrunedFundsFunc.
func (mock *NodeClientMock) ImportPrunedFunds(ctx context.Context, tx *bt.Tx, txOutProof string) error {
	if mock.ImportPrunedFundsFunc == nil {
		panic("NodeClientMock.ImportPrunedFundsFunc: method is nil but NodeClient.ImportPrunedFunds was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Tx         *bt.Tx
		TxOutProof string
	}{
		Ctx:        ctx,
		Tx:         tx,
		TxOutProof: txOutProof,
	}
	mock.lockImportPrunedFunds.Lock()
	mock.calls.ImportPrunedFunds = append(mock.calls.ImportPrunedFunds, callInfo)
	mock.lockImportPrunedFunds.Unlock()
	return mock.ImportPrunedFundsFunc(ctx, tx, txOutProof)
}

// ImportPrunedFundsCalls gets all the calls that were made to ImportPrunedFunds.
// Check the length with:
//     len(mockedNodeClient.ImportPrunedFundsCalls())
func (mock *NodeClientMock) ImportPrunedFundsCalls() []struct {
	Ctx        context.Context
	Tx         *bt.Tx
	TxOutProof string
} {
	var calls []struct {
		Ctx        context.Context
		Tx         *bt.Tx
		TxOutProof string
	}
	mock.lockImportPrunedFunds.RLock()
	calls = mock.calls.ImportPrunedFunds
	mock.lockImportPrunedFunds.RUnlock()
	return calls
}

// ImportPublicKey calls ImportPublicKeyFunc.
func (mock *NodeClientMock) ImportPublicKey(ctx context.Context, publicKey string, opts *models.OptsImportPublicKey) error {
	if mock.ImportPublicKeyFunc == nil {
		panic("NodeClientMock.ImportPublicKeyFunc: method is nil but NodeClient.ImportPublicKey was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		PublicKey string
		Opts      *models.OptsImportPublicKey
	}{
		Ctx:       ctx,
		PublicKey: publicKey,
		Opts:      opts,
	}
	mock.lockImportPublicKey.Lock()
	mock.calls.ImportPublicKey = append(mock.calls.ImportPublicKey, callInfo)
	mock.lockImportPublicKey.Unlock()
	return mock.ImportPublicKeyFunc(ctx, publicKey, opts)
}

// ImportPublicKeyCalls gets all the calls that were made to ImportPublicKey.
// Check the length with:
//     len(mockedNodeClient.ImportPublicKeyCalls())
func (mock *NodeClientMock) ImportPublicKeyCalls() []struct {
	Ctx       context.Context
	PublicKey string
	Opts      *models.OptsImportPublicKey
} {
	var calls []struct {
		Ctx       context.Context
		PublicKey string
		Opts      *models.OptsImportPublicKey
	}
	mock.lockImportPublicKey.RLock()
	calls = mock.calls.ImportPublicKey
	mock.lockImportPublicKey.RUnlock()
	return calls
}

// ImportWallet calls ImportWalletFunc.
func (mock *NodeClientMock) ImportWallet(ctx context.Context, filename string) error {
	if mock.ImportWalletFunc == nil {
		panic("NodeClientMock.ImportWalletFunc: method is nil but NodeClient.ImportWallet was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Filename string
	}{
		Ctx:      ctx,
		Filename: filename,
	}
	mock.lockImportWallet.Lock()
	mock.calls.ImportWallet = append(mock.calls.ImportWallet, callInfo)
	mock.lockImportWallet.Unlock()
	return mock.ImportWalletFunc(ctx, filename)
}

// ImportWalletCalls gets all the calls that were made to ImportWallet.
// Check the length with:
//     len(mockedNodeClient.ImportWalletCalls())
func (mock *NodeClientMock) ImportWalletCalls() []struct {
	Ctx      context.Context
	Filename string
} {
	var calls []struct {
		Ctx      context.Context
		Filename string
	}
	mock.lockImportWallet.RLock()
	calls = mock.calls.ImportWallet
	mock.lockImportWallet.RUnlock()
	return calls
}

// Info calls InfoFunc.
func (mock *NodeClientMock) Info(ctx context.Context) (*models.Info, error) {
	if mock.InfoFunc == nil {
		panic("NodeClientMock.InfoFunc: method is nil but NodeClient.Info was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	return mock.InfoFunc(ctx)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//     len(mockedNodeClient.InfoCalls())
func (mock *NodeClientMock) InfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// InvalidateBlock calls InvalidateBlockFunc.
func (mock *NodeClientMock) InvalidateBlock(ctx context.Context, hash string) error {
	if mock.InvalidateBlockFunc == nil {
		panic("NodeClientMock.InvalidateBlockFunc: method is nil but NodeClient.InvalidateBlock was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		BlockHash string
	}{
		Ctx:  ctx,
		BlockHash: hash,
	}
	mock.lockBlock.Lock()
	mock.calls.InvalidateBlock = append(mock.calls.InvalidateBlock, callInfo)
	mock.lockBlock.Unlock()
	return mock.InvalidateBlockFunc(ctx, hash)
}

// KeypoolRefill calls KeypoolRefillFunc.
func (mock *NodeClientMock) KeypoolRefill(ctx context.Context, opts *models.OptsKeypoolRefill) error {
	if mock.KeypoolRefillFunc == nil {
		panic("NodeClientMock.KeypoolRefillFunc: method is nil but NodeClient.KeypoolRefill was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsKeypoolRefill
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockKeypoolRefill.Lock()
	mock.calls.KeypoolRefill = append(mock.calls.KeypoolRefill, callInfo)
	mock.lockKeypoolRefill.Unlock()
	return mock.KeypoolRefillFunc(ctx, opts)
}

// KeypoolRefillCalls gets all the calls that were made to KeypoolRefill.
// Check the length with:
//     len(mockedNodeClient.KeypoolRefillCalls())
func (mock *NodeClientMock) KeypoolRefillCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsKeypoolRefill
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsKeypoolRefill
	}
	mock.lockKeypoolRefill.RLock()
	calls = mock.calls.KeypoolRefill
	mock.lockKeypoolRefill.RUnlock()
	return calls
}

// LegacyMerkleProof calls LegacyMerkleProofFunc.
func (mock *NodeClientMock) LegacyMerkleProof(ctx context.Context, txID string, opts *models.OptsLegacyMerkleProof) (*models.LegacyMerkleProof, error) {
	if mock.LegacyMerkleProofFunc == nil {
		panic("NodeClientMock.LegacyMerkleProofFunc: method is nil but NodeClient.LegacyMerkleProof was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
		Opts *models.OptsLegacyMerkleProof
	}{
		Ctx:  ctx,
		TxID: txID,
		Opts: opts,
	}
	mock.lockLegacyMerkleProof.Lock()
	mock.calls.LegacyMerkleProof = append(mock.calls.LegacyMerkleProof, callInfo)
	mock.lockLegacyMerkleProof.Unlock()
	return mock.LegacyMerkleProofFunc(ctx, txID, opts)
}

// LegacyMerkleProofCalls gets all the calls that were made to LegacyMerkleProof.
// Check the length with:
//     len(mockedNodeClient.LegacyMerkleProofCalls())
func (mock *NodeClientMock) LegacyMerkleProofCalls() []struct {
	Ctx  context.Context
	TxID string
	Opts *models.OptsLegacyMerkleProof
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
		Opts *models.OptsLegacyMerkleProof
	}
	mock.lockLegacyMerkleProof.RLock()
	calls = mock.calls.LegacyMerkleProof
	mock.lockLegacyMerkleProof.RUnlock()
	return calls
}

// ListAccounts calls ListAccountsFunc.
func (mock *NodeClientMock) ListAccounts(ctx context.Context, opts *models.OptsListAccounts) (map[string]uint64, error) {
	if mock.ListAccountsFunc == nil {
		panic("NodeClientMock.ListAccountsFunc: method is nil but NodeClient.ListAccounts was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsListAccounts
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockListAccounts.Lock()
	mock.calls.ListAccounts = append(mock.calls.ListAccounts, callInfo)
	mock.lockListAccounts.Unlock()
	return mock.ListAccountsFunc(ctx, opts)
}

// ListAccountsCalls gets all the calls that were made to ListAccounts.
// Check the length with:
//     len(mockedNodeClient.ListAccountsCalls())
func (mock *NodeClientMock) ListAccountsCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsListAccounts
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsListAccounts
	}
	mock.lockListAccounts.RLock()
	calls = mock.calls.ListAccounts
	mock.lockListAccounts.RUnlock()
	return calls
}

// ListBanned calls ListBannedFunc.
func (mock *NodeClientMock) ListBanned(ctx context.Context) ([]*models.BannedSubnet, error) {
	if mock.ListBannedFunc == nil {
		panic("NodeClientMock.ListBannedFunc: method is nil but NodeClient.ListBanned was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListBanned.Lock()
	mock.calls.ListBanned = append(mock.calls.ListBanned, callInfo)
	mock.lockListBanned.Unlock()
	return mock.ListBannedFunc(ctx)
}

// ListBannedCalls gets all the calls that were made to ListBanned.
// Check the length with:
//     len(mockedNodeClient.ListBannedCalls())
func (mock *NodeClientMock) ListBannedCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListBanned.RLock()
	calls = mock.calls.ListBanned
	mock.lockListBanned.RUnlock()
	return calls
}

// ListLockUnspent calls ListLockUnspentFunc.
func (mock *NodeClientMock) ListLockUnspent(ctx context.Context) ([]*models.LockUnspent, error) {
	if mock.ListLockUnspentFunc == nil {
		panic("NodeClientMock.ListLockUnspentFunc: method is nil but NodeClient.ListLockUnspent was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListLockUnspent.Lock()
	mock.calls.ListLockUnspent = append(mock.calls.ListLockUnspent, callInfo)
	mock.lockListLockUnspent.Unlock()
	return mock.ListLockUnspentFunc(ctx)
}

// ListLockUnspentCalls gets all the calls that were made to ListLockUnspent.
// Check the length with:
//     len(mockedNodeClient.ListLockUnspentCalls())
func (mock *NodeClientMock) ListLockUnspentCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListLockUnspent.RLock()
	calls = mock.calls.ListLockUnspent
	mock.lockListLockUnspent.RUnlock()
	return calls
}

// ListReceivedByAccount calls ListReceivedByAccountFunc.
func (mock *NodeClientMock) ListReceivedByAccount(ctx context.Context, opts *models.OptsListReceivedBy) ([]*models.ReceivedByAccount, error) {
	if mock.ListReceivedByAccountFunc == nil {
		panic("NodeClientMock.ListReceivedByAccountFunc: method is nil but NodeClient.ListReceivedByAccount was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsListReceivedBy
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockListReceivedByAccount.Lock()
	mock.calls.ListReceivedByAccount = append(mock.calls.ListReceivedByAccount, callInfo)
	mock.lockListReceivedByAccount.Unlock()
	return mock.ListReceivedByAccountFunc(ctx, opts)
}

// ListReceivedByAccountCalls gets all the calls that were made to ListReceivedByAccount.
// Check the length with:
//     len(mockedNodeClient.ListReceivedByAccountCalls())
func (mock *NodeClientMock) ListReceivedByAccountCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsListReceivedBy
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsListReceivedBy
	}
	mock.lockListReceivedByAccount.RLock()
	calls = mock.calls.ListReceivedByAccount
	mock.lockListReceivedByAccount.RUnlock()
	return calls
}

// ListReceivedByAddress calls ListReceivedByAddressFunc.
func (mock *NodeClientMock) ListReceivedByAddress(ctx context.Context, opts *models.OptsListReceivedBy) ([]*models.ReceivedByAddress, error) {
	if mock.ListReceivedByAddressFunc == nil {
		panic("NodeClientMock.ListReceivedByAddressFunc: method is nil but NodeClient.ListReceivedByAddress was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsListReceivedBy
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockListReceivedByAddress.Lock()
	mock.calls.ListReceivedByAddress = append(mock.calls.ListReceivedByAddress, callInfo)
	mock.lockListReceivedByAddress.Unlock()
	return mock.ListReceivedByAddressFunc(ctx, opts)
}

// ListReceivedByAddressCalls gets all the calls that were made to ListReceivedByAddress.
// Check the length with:
//     len(mockedNodeClient.ListReceivedByAddressCalls())
func (mock *NodeClientMock) ListReceivedByAddressCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsListReceivedBy
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsListReceivedBy
	}
	mock.lockListReceivedByAddress.RLock()
	calls = mock.calls.ListReceivedByAddress
	mock.lockListReceivedByAddress.RUnlock()
	return calls
}

// ListSinceBlock calls ListSinceBlockFunc.
func (mock *NodeClientMock) ListSinceBlock(ctx context.Context, opts *models.OptsListSinceBlock) (*models.SinceBlock, error) {
	if mock.ListSinceBlockFunc == nil {
		panic("NodeClientMock.ListSinceBlockFunc: method is nil but NodeClient.ListSinceBlock was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsListSinceBlock
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockListSinceBlock.Lock()
	mock.calls.ListSinceBlock = append(mock.calls.ListSinceBlock, callInfo)
	mock.lockListSinceBlock.Unlock()
	return mock.ListSinceBlockFunc(ctx, opts)
}

// ListSinceBlockCalls gets all the calls that were made to ListSinceBlock.
// Check the length with:
//     len(mockedNodeClient.ListSinceBlockCalls())
func (mock *NodeClientMock) ListSinceBlockCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsListSinceBlock
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsListSinceBlock
	}
	mock.lockListSinceBlock.RLock()
	calls = mock.calls.ListSinceBlock
	mock.lockListSinceBlock.RUnlock()
	return calls
}

// ListTransactions calls ListTransactionsFunc.
func (mock *NodeClientMock) ListTransactions(ctx context.Context, opts *models.OptsListTransactions) ([]*models.Transaction, error) {
	if mock.ListTransactionsFunc == nil {
		panic("NodeClientMock.ListTransactionsFunc: method is nil but NodeClient.ListTransactions was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsListTransactions
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockListTransactions.Lock()
	mock.calls.ListTransactions = append(mock.calls.ListTransactions, callInfo)
	mock.lockListTransactions.Unlock()
	return mock.ListTransactionsFunc(ctx, opts)
}

// ListTransactionsCalls gets all the calls that were made to ListTransactions.
// Check the length with:
//     len(mockedNodeClient.ListTransactionsCalls())
func (mock *NodeClientMock) ListTransactionsCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsListTransactions
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsListTransactions
	}
	mock.lockListTransactions.RLock()
	calls = mock.calls.ListTransactions
	mock.lockListTransactions.RUnlock()
	return calls
}

// ListUnspent calls ListUnspentFunc.
func (mock *NodeClientMock) ListUnspent(ctx context.Context, opts *models.OptsListUnspent) (bt.UTXOs, error) {
	if mock.ListUnspentFunc == nil {
		panic("NodeClientMock.ListUnspentFunc: method is nil but NodeClient.ListUnspent was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsListUnspent
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockListUnspent.Lock()
	mock.calls.ListUnspent = append(mock.calls.ListUnspent, callInfo)
	mock.lockListUnspent.Unlock()
	return mock.ListUnspentFunc(ctx, opts)
}

// ListUnspentCalls gets all the calls that were made to ListUnspent.
// Check the length with:
//     len(mockedNodeClient.ListUnspentCalls())
func (mock *NodeClientMock) ListUnspentCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsListUnspent
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsListUnspent
	}
	mock.lockListUnspent.RLock()
	calls = mock.calls.ListUnspent
	mock.lockListUnspent.RUnlock()
	return calls
}

// ListWallets calls ListWalletsFunc.
func (mock *NodeClientMock) ListWallets(ctx context.Context) ([]string, error) {
	if mock.ListWalletsFunc == nil {
		panic("NodeClientMock.ListWalletsFunc: method is nil but NodeClient.ListWallets was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListWallets.Lock()
	mock.calls.ListWallets = append(mock.calls.ListWallets, callInfo)
	mock.lockListWallets.Unlock()
	return mock.ListWalletsFunc(ctx)
}

// ListWalletsCalls gets all the calls that were made to ListWallets.
// Check the length with:
//     len(mockedNodeClient.ListWalletsCalls())
func (mock *NodeClientMock) ListWalletsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListWallets.RLock()
	calls = mock.calls.ListWallets
	mock.lockListWallets.RUnlock()
	return calls
}

// LockUnspent calls LockUnspentFunc.
func (mock *NodeClientMock) LockUnspent(ctx context.Context, lock bool, opts *models.OptsLockUnspent) (bool, error) {
	if mock.LockUnspentFunc == nil {
		panic("NodeClientMock.LockUnspentFunc: method is nil but NodeClient.LockUnspent was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Lock bool
		Opts *models.OptsLockUnspent
	}{
		Ctx:  ctx,
		Lock: lock,
		Opts: opts,
	}
	mock.lockLockUnspent.Lock()
	mock.calls.LockUnspent = append(mock.calls.LockUnspent, callInfo)
	mock.lockLockUnspent.Unlock()
	return mock.LockUnspentFunc(ctx, lock, opts)
}

// LockUnspentCalls gets all the calls that were made to LockUnspent.
// Check the length with:
//     len(mockedNodeClient.LockUnspentCalls())
func (mock *NodeClientMock) LockUnspentCalls() []struct {
	Ctx  context.Context
	Lock bool
	Opts *models.OptsLockUnspent
} {
	var calls []struct {
		Ctx  context.Context
		Lock bool
		Opts *models.OptsLockUnspent
	}
	mock.lockLockUnspent.RLock()
	calls = mock.calls.LockUnspent
	mock.lockLockUnspent.RUnlock()
	return calls
}

// MemoryInfo calls MemoryInfoFunc.
func (mock *NodeClientMock) MemoryInfo(ctx context.Context) (*models.MemoryInfo, error) {
	if mock.MemoryInfoFunc == nil {
		panic("NodeClientMock.MemoryInfoFunc: method is nil but NodeClient.MemoryInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockMemoryInfo.Lock()
	mock.calls.MemoryInfo = append(mock.calls.MemoryInfo, callInfo)
	mock.lockMemoryInfo.Unlock()
	return mock.MemoryInfoFunc(ctx)
}

// MemoryInfoCalls gets all the calls that were made to MemoryInfo.
// Check the length with:
//     len(mockedNodeClient.MemoryInfoCalls())
func (mock *NodeClientMock) MemoryInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockMemoryInfo.RLock()
	calls = mock.calls.MemoryInfo
	mock.lockMemoryInfo.RUnlock()
	return calls
}

// MempoolAncestorIDs calls MempoolAncestorIDsFunc.
func (mock *NodeClientMock) MempoolAncestorIDs(ctx context.Context, txID string) ([]string, error) {
	if mock.MempoolAncestorIDsFunc == nil {
		panic("NodeClientMock.MempoolAncestorIDsFunc: method is nil but NodeClient.MempoolAncestorIDs was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockMempoolAncestorIDs.Lock()
	mock.calls.MempoolAncestorIDs = append(mock.calls.MempoolAncestorIDs, callInfo)
	mock.lockMempoolAncestorIDs.Unlock()
	return mock.MempoolAncestorIDsFunc(ctx, txID)
}

// MempoolAncestorIDsCalls gets all the calls that were made to MempoolAncestorIDs.
// Check the length with:
//     len(mockedNodeClient.MempoolAncestorIDsCalls())
func (mock *NodeClientMock) MempoolAncestorIDsCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockMempoolAncestorIDs.RLock()
	calls = mock.calls.MempoolAncestorIDs
	mock.lockMempoolAncestorIDs.RUnlock()
	return calls
}

// MempoolAncestors calls MempoolAncestorsFunc.
func (mock *NodeClientMock) MempoolAncestors(ctx context.Context, txID string) (models.MempoolTxs, error) {
	if mock.MempoolAncestorsFunc == nil {
		panic("NodeClientMock.MempoolAncestorsFunc: method is nil but NodeClient.MempoolAncestors was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockMempoolAncestors.Lock()
	mock.calls.MempoolAncestors = append(mock.calls.MempoolAncestors, callInfo)
	mock.lockMempoolAncestors.Unlock()
	return mock.MempoolAncestorsFunc(ctx, txID)
}

// MempoolAncestorsCalls gets all the calls that were made to MempoolAncestors.
// Check the length with:
//     len(mockedNodeClient.MempoolAncestorsCalls())
func (mock *NodeClientMock) MempoolAncestorsCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockMempoolAncestors.RLock()
	calls = mock.calls.MempoolAncestors
	mock.lockMempoolAncestors.RUnlock()
	return calls
}

// MempoolDescendantIDs calls MempoolDescendantIDsFunc.
func (mock *NodeClientMock) MempoolDescendantIDs(ctx context.Context, txID string) ([]string, error) {
	if mock.MempoolDescendantIDsFunc == nil {
		panic("NodeClientMock.MempoolDescendantIDsFunc: method is nil but NodeClient.MempoolDescendantIDs was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockMempoolDescendantIDs.Lock()
	mock.calls.MempoolDescendantIDs = append(mock.calls.MempoolDescendantIDs, callInfo)
	mock.lockMempoolDescendantIDs.Unlock()
	return mock.MempoolDescendantIDsFunc(ctx, txID)
}

// MempoolDescendantIDsCalls gets all the calls that were made to MempoolDescendantIDs.
// Check the length with:
//     len(mockedNodeClient.MempoolDescendantIDsCalls())
func (mock *NodeClientMock) MempoolDescendantIDsCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockMempoolDescendantIDs.RLock()
	calls = mock.calls.MempoolDescendantIDs
	mock.lockMempoolDescendantIDs.RUnlock()
	return calls
}

// MempoolDescendants calls MempoolDescendantsFunc.
func (mock *NodeClientMock) MempoolDescendants(ctx context.Context, txID string) (models.MempoolTxs, error) {
	if mock.MempoolDescendantsFunc == nil {
		panic("NodeClientMock.MempoolDescendantsFunc: method is nil but NodeClient.MempoolDescendants was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockMempoolDescendants.Lock()
	mock.calls.MempoolDescendants = append(mock.calls.MempoolDescendants, callInfo)
	mock.lockMempoolDescendants.Unlock()
	return mock.MempoolDescendantsFunc(ctx, txID)
}

// MempoolDescendantsCalls gets all the calls that were made to MempoolDescendants.
// Check the length with:
//     len(mockedNodeClient.MempoolDescendantsCalls())
func (mock *NodeClientMock) MempoolDescendantsCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockMempoolDescendants.RLock()
	calls = mock.calls.MempoolDescendants
	mock.lockMempoolDescendants.RUnlock()
	return calls
}

// MempoolEntry calls MempoolEntryFunc.
func (mock *NodeClientMock) MempoolEntry(ctx context.Context, txID string) (*models.MempoolEntry, error) {
	if mock.MempoolEntryFunc == nil {
		panic("NodeClientMock.MempoolEntryFunc: method is nil but NodeClient.MempoolEntry was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockMempoolEntry.Lock()
	mock.calls.MempoolEntry = append(mock.calls.MempoolEntry, callInfo)
	mock.lockMempoolEntry.Unlock()
	return mock.MempoolEntryFunc(ctx, txID)
}

// MempoolEntryCalls gets all the calls that were made to MempoolEntry.
// Check the length with:
//     len(mockedNodeClient.MempoolEntryCalls())
func (mock *NodeClientMock) MempoolEntryCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockMempoolEntry.RLock()
	calls = mock.calls.MempoolEntry
	mock.lockMempoolEntry.RUnlock()
	return calls
}

// MerkleProof calls MerkleProofFunc.
func (mock *NodeClientMock) MerkleProof(ctx context.Context, blockHash string, txID string, opts *models.OptsMerkleProof) (*bc.MerkleProof, error) {
	if mock.MerkleProofFunc == nil {
		panic("NodeClientMock.MerkleProofFunc: method is nil but NodeClient.MerkleProof was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		BlockHash string
		TxID      string
		Opts      *models.OptsMerkleProof
	}{
		Ctx:       ctx,
		BlockHash: blockHash,
		TxID:      txID,
		Opts:      opts,
	}
	mock.lockMerkleProof.Lock()
	mock.calls.MerkleProof = append(mock.calls.MerkleProof, callInfo)
	mock.lockMerkleProof.Unlock()
	return mock.MerkleProofFunc(ctx, blockHash, txID, opts)
}

// MerkleProofCalls gets all the calls that were made to MerkleProof.
// Check the length with:
//     len(mockedNodeClient.MerkleProofCalls())
func (mock *NodeClientMock) MerkleProofCalls() []struct {
	Ctx       context.Context
	BlockHash string
	TxID      string
	Opts      *models.OptsMerkleProof
} {
	var calls []struct {
		Ctx       context.Context
		BlockHash string
		TxID      string
		Opts      *models.OptsMerkleProof
	}
	mock.lockMerkleProof.RLock()
	calls = mock.calls.MerkleProof
	mock.lockMerkleProof.RUnlock()
	return calls
}

// MiningCandidate calls MiningCandidateFunc.
func (mock *NodeClientMock) MiningCandidate(ctx context.Context, opts *models.OptsMiningCandidate) (*models.MiningCandidate, error) {
	if mock.MiningCandidateFunc == nil {
		panic("NodeClientMock.MiningCandidateFunc: method is nil but NodeClient.MiningCandidate was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsMiningCandidate
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockMiningCandidate.Lock()
	mock.calls.MiningCandidate = append(mock.calls.MiningCandidate, callInfo)
	mock.lockMiningCandidate.Unlock()
	return mock.MiningCandidateFunc(ctx, opts)
}

// MiningCandidateCalls gets all the calls that were made to MiningCandidate.
// Check the length with:
//     len(mockedNodeClient.MiningCandidateCalls())
func (mock *NodeClientMock) MiningCandidateCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsMiningCandidate
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsMiningCandidate
	}
	mock.lockMiningCandidate.RLock()
	calls = mock.calls.MiningCandidate
	mock.lockMiningCandidate.RUnlock()
	return calls
}

// MiningInfo calls MiningInfoFunc.
func (mock *NodeClientMock) MiningInfo(ctx context.Context) (*models.MiningInfo, error) {
	if mock.MiningInfoFunc == nil {
		panic("NodeClientMock.MiningInfoFunc: method is nil but NodeClient.MiningInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockMiningInfo.Lock()
	mock.calls.MiningInfo = append(mock.calls.MiningInfo, callInfo)
	mock.lockMiningInfo.Unlock()
	return mock.MiningInfoFunc(ctx)
}

// MiningInfoCalls gets all the calls that were made to MiningInfo.
// Check the length with:
//     len(mockedNodeClient.MiningInfoCalls())
func (mock *NodeClientMock) MiningInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockMiningInfo.RLock()
	calls = mock.calls.MiningInfo
	mock.lockMiningInfo.RUnlock()
	return calls
}

// Move calls MoveFunc.
func (mock *NodeClientMock) Move(ctx context.Context, from string, to string, amount uint64, opts *models.OptsMove) (bool, error) {
	if mock.MoveFunc == nil {
		panic("NodeClientMock.MoveFunc: method is nil but NodeClient.Move was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		From   string
		To     string
		Amount uint64
		Opts   *models.OptsMove
	}{
		Ctx:    ctx,
		From:   from,
		To:     to,
		Amount: amount,
		Opts:   opts,
	}
	mock.lockMove.Lock()
	mock.calls.Move = append(mock.calls.Move, callInfo)
	mock.lockMove.Unlock()
	return mock.MoveFunc(ctx, from, to, amount, opts)
}

// MoveCalls gets all the calls that were made to Move.
// Check the length with:
//     len(mockedNodeClient.MoveCalls())
func (mock *NodeClientMock) MoveCalls() []struct {
	Ctx    context.Context
	From   string
	To     string
	Amount uint64
	Opts   *models.OptsMove
} {
	var calls []struct {
		Ctx    context.Context
		From   string
		To     string
		Amount uint64
		Opts   *models.OptsMove
	}
	mock.lockMove.RLock()
	calls = mock.calls.Move
	mock.lockMove.RUnlock()
	return calls
}

// NetworkHashPS calls NetworkHashPSFunc.
func (mock *NodeClientMock) NetworkHashPS(ctx context.Context, opts *models.OptsNetworkHashPS) (uint64, error) {
	if mock.NetworkHashPSFunc == nil {
		panic("NodeClientMock.NetworkHashPSFunc: method is nil but NodeClient.NetworkHashPS was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsNetworkHashPS
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockNetworkHashPS.Lock()
	mock.calls.NetworkHashPS = append(mock.calls.NetworkHashPS, callInfo)
	mock.lockNetworkHashPS.Unlock()
	return mock.NetworkHashPSFunc(ctx, opts)
}

// NetworkHashPSCalls gets all the calls that were made to NetworkHashPS.
// Check the length with:
//     len(mockedNodeClient.NetworkHashPSCalls())
func (mock *NodeClientMock) NetworkHashPSCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsNetworkHashPS
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsNetworkHashPS
	}
	mock.lockNetworkHashPS.RLock()
	calls = mock.calls.NetworkHashPS
	mock.lockNetworkHashPS.RUnlock()
	return calls
}

// NetworkInfo calls NetworkInfoFunc.
func (mock *NodeClientMock) NetworkInfo(ctx context.Context) (*models.NetworkInfo, error) {
	if mock.NetworkInfoFunc == nil {
		panic("NodeClientMock.NetworkInfoFunc: method is nil but NodeClient.NetworkInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockNetworkInfo.Lock()
	mock.calls.NetworkInfo = append(mock.calls.NetworkInfo, callInfo)
	mock.lockNetworkInfo.Unlock()
	return mock.NetworkInfoFunc(ctx)
}

// NetworkInfoCalls gets all the calls that were made to NetworkInfo.
// Check the length with:
//     len(mockedNodeClient.NetworkInfoCalls())
func (mock *NodeClientMock) NetworkInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockNetworkInfo.RLock()
	calls = mock.calls.NetworkInfo
	mock.lockNetworkInfo.RUnlock()
	return calls
}

// NetworkTotals calls NetworkTotalsFunc.
func (mock *NodeClientMock) NetworkTotals(ctx context.Context) (*models.NetworkTotals, error) {
	if mock.NetworkTotalsFunc == nil {
		panic("NodeClientMock.NetworkTotalsFunc: method is nil but NodeClient.NetworkTotals was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockNetworkTotals.Lock()
	mock.calls.NetworkTotals = append(mock.calls.NetworkTotals, callInfo)
	mock.lockNetworkTotals.Unlock()
	return mock.NetworkTotalsFunc(ctx)
}

// NetworkTotalsCalls gets all the calls that were made to NetworkTotals.
// Check the length with:
//     len(mockedNodeClient.NetworkTotalsCalls())
func (mock *NodeClientMock) NetworkTotalsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockNetworkTotals.RLock()
	calls = mock.calls.NetworkTotals
	mock.lockNetworkTotals.RUnlock()
	return calls
}

// NewAddress calls NewAddressFunc.
func (mock *NodeClientMock) NewAddress(ctx context.Context, opts *models.OptsNewAddress) (string, error) {
	if mock.NewAddressFunc == nil {
		panic("NodeClientMock.NewAddressFunc: method is nil but NodeClient.NewAddress was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsNewAddress
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockNewAddress.Lock()
	mock.calls.NewAddress = append(mock.calls.NewAddress, callInfo)
	mock.lockNewAddress.Unlock()
	return mock.NewAddressFunc(ctx, opts)
}

// NewAddressCalls gets all the calls that were made to NewAddress.
// Check the length with:
//     len(mockedNodeClient.NewAddressCalls())
func (mock *NodeClientMock) NewAddressCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsNewAddress
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsNewAddress
	}
	mock.lockNewAddress.RLock()
	calls = mock.calls.NewAddress
	mock.lockNewAddress.RUnlock()
	return calls
}

// NodeInfo calls NodeInfoFunc.
func (mock *NodeClientMock) NodeInfo(ctx context.Context, opts *models.OptsNodeInfo) ([]*models.NodeInfo, error) {
	if mock.NodeInfoFunc == nil {
		panic("NodeClientMock.NodeInfoFunc: method is nil but NodeClient.NodeInfo was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *models.OptsNodeInfo
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockNodeInfo.Lock()
	mock.calls.NodeInfo = append(mock.calls.NodeInfo, callInfo)
	mock.lockNodeInfo.Unlock()
	return mock.NodeInfoFunc(ctx, opts)
}

// NodeInfoCalls gets all the calls that were made to NodeInfo.
// Check the length with:
//     len(mockedNodeClient.NodeInfoCalls())
func (mock *NodeClientMock) NodeInfoCalls() []struct {
	Ctx  context.Context
	Opts *models.OptsNodeInfo
} {
	var calls []struct {
		Ctx  context.Context
		Opts *models.OptsNodeInfo
	}
	mock.lockNodeInfo.RLock()
	calls = mock.calls.NodeInfo
	mock.lockNodeInfo.RUnlock()
	return calls
}

// Output calls OutputFunc.
func (mock *NodeClientMock) Output(ctx context.Context, txID string, n int, opts *models.OptsOutput) (*models.Output, error) {
	if mock.OutputFunc == nil {
		panic("NodeClientMock.OutputFunc: method is nil but NodeClient.Output was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
		N    int
		Opts *models.OptsOutput
	}{
		Ctx:  ctx,
		TxID: txID,
		N:    n,
		Opts: opts,
	}
	mock.lockOutput.Lock()
	mock.calls.Output = append(mock.calls.Output, callInfo)
	mock.lockOutput.Unlock()
	return mock.OutputFunc(ctx, txID, n, opts)
}

// OutputCalls gets all the calls that were made to Output.
// Check the length with:
//     len(mockedNodeClient.OutputCalls())
func (mock *NodeClientMock) OutputCalls() []struct {
	Ctx  context.Context
	TxID string
	N    int
	Opts *models.OptsOutput
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
		N    int
		Opts *models.OptsOutput
	}
	mock.lockOutput.RLock()
	calls = mock.calls.Output
	mock.lockOutput.RUnlock()
	return calls
}

// OutputSetInfo calls OutputSetInfoFunc.
func (mock *NodeClientMock) OutputSetInfo(ctx context.Context) (*models.OutputSetInfo, error) {
	if mock.OutputSetInfoFunc == nil {
		panic("NodeClientMock.OutputSetInfoFunc: method is nil but NodeClient.OutputSetInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockOutputSetInfo.Lock()
	mock.calls.OutputSetInfo = append(mock.calls.OutputSetInfo, callInfo)
	mock.lockOutputSetInfo.Unlock()
	return mock.OutputSetInfoFunc(ctx)
}

// OutputSetInfoCalls gets all the calls that were made to OutputSetInfo.
// Check the length with:
//     len(mockedNodeClient.OutputSetInfoCalls())
func (mock *NodeClientMock) OutputSetInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockOutputSetInfo.RLock()
	calls = mock.calls.OutputSetInfo
	mock.lockOutputSetInfo.RUnlock()
	return calls
}

// PeerInfo calls PeerInfoFunc.
func (mock *NodeClientMock) PeerInfo(ctx context.Context) ([]*models.PeerInfo, error) {
	if mock.PeerInfoFunc == nil {
		panic("NodeClientMock.PeerInfoFunc: method is nil but NodeClient.PeerInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPeerInfo.Lock()
	mock.calls.PeerInfo = append(mock.calls.PeerInfo, callInfo)
	mock.lockPeerInfo.Unlock()
	return mock.PeerInfoFunc(ctx)
}

// PeerInfoCalls gets all the calls that were made to PeerInfo.
// Check the length with:
//     len(mockedNodeClient.PeerInfoCalls())
func (mock *NodeClientMock) PeerInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPeerInfo.RLock()
	calls = mock.calls.PeerInfo
	mock.lockPeerInfo.RUnlock()
	return calls
}

// Ping calls PingFunc.
func (mock *NodeClientMock) Ping(ctx context.Context) error {
	if mock.PingFunc == nil {
		panic("NodeClientMock.PingFunc: method is nil but NodeClient.Ping was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPing.Lock()
	mock.calls.Ping = append(mock.calls.Ping, callInfo)
	mock.lockPing.Unlock()
	return mock.PingFunc(ctx)
}

// PingCalls gets all the calls that were made to Ping.
// Check the length with:
//     len(mockedNodeClient.PingCalls())
func (mock *NodeClientMock) PingCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPing.RLock()
	calls = mock.calls.Ping
	mock.lockPing.RUnlock()
	return calls
}

// PreciousBlock calls PreciousBlockFunc.
func (mock *NodeClientMock) PreciousBlock(ctx context.Context, blockHash string) error {
	if mock.PreciousBlockFunc == nil {
		panic("NodeClientMock.PreciousBlockFunc: method is nil but NodeClient.PreciousBlock was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		BlockHash string
	}{
		Ctx:       ctx,
		BlockHash: blockHash,
	}
	mock.lockPreciousBlock.Lock()
	mock.calls.PreciousBlock = append(mock.calls.PreciousBlock, callInfo)
	mock.lockPreciousBlock.Unlock()
	return mock.PreciousBlockFunc(ctx, blockHash)
}

// PreciousBlockCalls gets all the calls that were made to PreciousBlock.
// Check the length with:
//     len(mockedNodeClient.PreciousBlockCalls())
func (mock *NodeClientMock) PreciousBlockCalls() []struct {
	Ctx       context.Context
	BlockHash string
} {
	var calls []struct {
		Ctx       context.Context
		BlockHash string
	}
	mock.lockPreciousBlock.RLock()
	calls = mock.calls.PreciousBlock
	mock.lockPreciousBlock.RUnlock()
	return calls
}

// PrioritiseTx calls PrioritiseTxFunc.
func (mock *NodeClientMock) PrioritiseTx(ctx context.Context, txID string, feeDelta int64) (bool, error) {
	if mock.PrioritiseTxFunc == nil {
		panic("NodeClientMock.PrioritiseTxFunc: method is nil but NodeClient.PrioritiseTx was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		TxID     string
		FeeDelta int64
	}{
		Ctx:      ctx,
		TxID:     txID,
		FeeDelta: feeDelta,
	}
	mock.lockPrioritiseTx.Lock()
	mock.calls.PrioritiseTx = append(mock.calls.PrioritiseTx, callInfo)
	mock.lockPrioritiseTx.Unlock()
	return mock.PrioritiseTxFunc(ctx, txID, feeDelta)
}

// PrioritiseTxCalls gets all the calls that were made to PrioritiseTx.
// Check the length with:
//     len(mockedNodeClient.PrioritiseTxCalls())
func (mock *NodeClientMock) PrioritiseTxCalls() []struct {
	Ctx      context.Context
	TxID     string
	FeeDelta int64
} {
	var calls []struct {
		Ctx      context.Context
		TxID     string
		FeeDelta int64
	}
	mock.lockPrioritiseTx.RLock()
	calls = mock.calls.PrioritiseTx
	mock.lockPrioritiseTx.RUnlock()
	return calls
}

// PruneChain calls PruneChainFunc.
func (mock *NodeClientMock) PruneChain(ctx context.Context, height int) (uint32, error) {
	if mock.PruneChainFunc == nil {
		panic("NodeClientMock.PruneChainFunc: method is nil but NodeClient.PruneChain was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height int
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockPruneChain.Lock()
	mock.calls.PruneChain = append(mock.calls.PruneChain, callInfo)
	mock.lockPruneChain.Unlock()
	return mock.PruneChainFunc(ctx, height)
}

// PruneChainCalls gets all the calls that were made to PruneChain.
// Check the length with:
//     len(mockedNodeClient.PruneChainCalls())
func (mock *NodeClientMock) PruneChainCalls() []struct {
	Ctx    context.Context
	Height int
} {
	var calls []struct {
		Ctx    context.Context
		Height int
	}
	mock.lockPruneChain.RLock()
	calls = mock.calls.PruneChain
	mock.lockPruneChain.RUnlock()
	return calls
}

// RawChangeAddress calls RawChangeAddressFunc.
func (mock *NodeClientMock) RawChangeAddress(ctx context.Context) (string, error) {
	if mock.RawChangeAddressFunc == nil {
		panic("NodeClientMock.RawChangeAddressFunc: method is nil but NodeClient.RawChangeAddress was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRawChangeAddress.Lock()
	mock.calls.RawChangeAddress = append(mock.calls.RawChangeAddress, callInfo)
	mock.lockRawChangeAddress.Unlock()
	return mock.RawChangeAddressFunc(ctx)
}

// RawChangeAddressCalls gets all the calls that were made to RawChangeAddress.
// Check the length with:
//     len(mockedNodeClient.RawChangeAddressCalls())
func (mock *NodeClientMock) RawChangeAddressCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRawChangeAddress.RLock()
	calls = mock.calls.RawChangeAddress
	mock.lockRawChangeAddress.RUnlock()
	return calls
}

// RawMempool calls RawMempoolFunc.
func (mock *NodeClientMock) RawMempool(ctx context.Context) (models.MempoolTxs, error) {
	if mock.RawMempoolFunc == nil {
		panic("NodeClientMock.RawMempoolFunc: method is nil but NodeClient.RawMempool was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRawMempool.Lock()
	mock.calls.RawMempool = append(mock.calls.RawMempool, callInfo)
	mock.lockRawMempool.Unlock()
	return mock.RawMempoolFunc(ctx)
}

// RawMempoolCalls gets all the calls that were made to RawMempool.
// Check the length with:
//     len(mockedNodeClient.RawMempoolCalls())
func (mock *NodeClientMock) RawMempoolCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRawMempool.RLock()
	calls = mock.calls.RawMempool
	mock.lockRawMempool.RUnlock()
	return calls
}

// RawMempoolIDs calls RawMempoolIDsFunc.
func (mock *NodeClientMock) RawMempoolIDs(ctx context.Context) ([]string, error) {
	if mock.RawMempoolIDsFunc == nil {
		panic("NodeClientMock.RawMempoolIDsFunc: method is nil but NodeClient.RawMempoolIDs was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRawMempoolIDs.Lock()
	mock.calls.RawMempoolIDs = append(mock.calls.RawMempoolIDs, callInfo)
	mock.lockRawMempoolIDs.Unlock()
	return mock.RawMempoolIDsFunc(ctx)
}

// RawMempoolIDsCalls gets all the calls that were made to RawMempoolIDs.
// Check the length with:
//     len(mockedNodeClient.RawMempoolIDsCalls())
func (mock *NodeClientMock) RawMempoolIDsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRawMempoolIDs.RLock()
	calls = mock.calls.RawMempoolIDs
	mock.lockRawMempoolIDs.RUnlock()
	return calls
}

// RawNonFinalMempool calls RawNonFinalMempoolFunc.
func (mock *NodeClientMock) RawNonFinalMempool(ctx context.Context) ([]string, error) {
	if mock.RawNonFinalMempoolFunc == nil {
		panic("NodeClientMock.RawNonFinalMempoolFunc: method is nil but NodeClient.RawNonFinalMempool was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRawNonFinalMempool.Lock()
	mock.calls.RawNonFinalMempool = append(mock.calls.RawNonFinalMempool, callInfo)
	mock.lockRawNonFinalMempool.Unlock()
	return mock.RawNonFinalMempoolFunc(ctx)
}

// RawNonFinalMempoolCalls gets all the calls that were made to RawNonFinalMempool.
// Check the length with:
//     len(mockedNodeClient.RawNonFinalMempoolCalls())
func (mock *NodeClientMock) RawNonFinalMempoolCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRawNonFinalMempool.RLock()
	calls = mock.calls.RawNonFinalMempool
	mock.lockRawNonFinalMempool.RUnlock()
	return calls
}

// RawTransaction calls RawTransactionFunc.
func (mock *NodeClientMock) RawTransaction(ctx context.Context, txID string) (*bt.Tx, error) {
	if mock.RawTransactionFunc == nil {
		panic("NodeClientMock.RawTransactionFunc: method is nil but NodeClient.RawTransaction was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockRawTransaction.Lock()
	mock.calls.RawTransaction = append(mock.calls.RawTransaction, callInfo)
	mock.lockRawTransaction.Unlock()
	return mock.RawTransactionFunc(ctx, txID)
}

// RawTransactionCalls gets all the calls that were made to RawTransaction.
// Check the length with:
//     len(mockedNodeClient.RawTransactionCalls())
func (mock *NodeClientMock) RawTransactionCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockRawTransaction.RLock()
	calls = mock.calls.RawTransaction
	mock.lockRawTransaction.RUnlock()
	return calls
}

// RebuildJournal calls RebuildJournalFunc.
func (mock *NodeClientMock) RebuildJournal(ctx context.Context) error {
	if mock.RebuildJournalFunc == nil {
		panic("NodeClientMock.RebuildJournalFunc: method is nil but NodeClient.RebuildJournal was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRebuildJournal.Lock()
	mock.calls.RebuildJournal = append(mock.calls.RebuildJournal, callInfo)
	mock.lockRebuildJournal.Unlock()
	return mock.RebuildJournalFunc(ctx)
}

// RebuildJournalCalls gets all the calls that were made to RebuildJournal.
// Check the length with:
//     len(mockedNodeClient.RebuildJournalCalls())
func (mock *NodeClientMock) RebuildJournalCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRebuildJournal.RLock()
	calls = mock.calls.RebuildJournal
	mock.lockRebuildJournal.RUnlock()
	return calls
}

// ReceivedByAddress calls ReceivedByAddressFunc.
func (mock *NodeClientMock) ReceivedByAddress(ctx context.Context, address string) (uint64, error) {
	if mock.ReceivedByAddressFunc == nil {
		panic("NodeClientMock.ReceivedByAddressFunc: method is nil but NodeClient.ReceivedByAddress was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockReceivedByAddress.Lock()
	mock.calls.ReceivedByAddress = append(mock.calls.ReceivedByAddress, callInfo)
	mock.lockReceivedByAddress.Unlock()
	return mock.ReceivedByAddressFunc(ctx, address)
}

// ReceivedByAddressCalls gets all the calls that were made to ReceivedByAddress.
// Check the length with:
//     len(mockedNodeClient.ReceivedByAddressCalls())
func (mock *NodeClientMock) ReceivedByAddressCalls() []struct {
	Ctx     context.Context
	Address string
} {
	var calls []struct {
		Ctx     context.Context
		Address string
	}
	mock.lockReceivedByAddress.RLock()
	calls = mock.calls.ReceivedByAddress
	mock.lockReceivedByAddress.RUnlock()
	return calls
}

// RemovePrunedFunds calls RemovePrunedFundsFunc.
func (mock *NodeClientMock) RemovePrunedFunds(ctx context.Context, txID string) error {
	if mock.RemovePrunedFundsFunc == nil {
		panic("NodeClientMock.RemovePrunedFundsFunc: method is nil but NodeClient.RemovePrunedFunds was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockRemovePrunedFunds.Lock()
	mock.calls.RemovePrunedFunds = append(mock.calls.RemovePrunedFunds, callInfo)
	mock.lockRemovePrunedFunds.Unlock()
	return mock.RemovePrunedFundsFunc(ctx, txID)
}

// RemovePrunedFundsCalls gets all the calls that were made to RemovePrunedFunds.
// Check the length with:
//     len(mockedNodeClient.RemovePrunedFundsCalls())
func (mock *NodeClientMock) RemovePrunedFundsCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockRemovePrunedFunds.RLock()
	calls = mock.calls.RemovePrunedFunds
	mock.lockRemovePrunedFunds.RUnlock()
	return calls
}

// SendFrom calls SendFromFunc.
func (mock *NodeClientMock) SendFrom(ctx context.Context, from string, to string, amount uint64, opts *models.OptsSendFrom) (string, error) {
	if mock.SendFromFunc == nil {
		panic("NodeClientMock.SendFromFunc: method is nil but NodeClient.SendFrom was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		From   string
		To     string
		Amount uint64
		Opts   *models.OptsSendFrom
	}{
		Ctx:    ctx,
		From:   from,
		To:     to,
		Amount: amount,
		Opts:   opts,
	}
	mock.lockSendFrom.Lock()
	mock.calls.SendFrom = append(mock.calls.SendFrom, callInfo)
	mock.lockSendFrom.Unlock()
	return mock.SendFromFunc(ctx, from, to, amount, opts)
}

// SendFromCalls gets all the calls that were made to SendFrom.
// Check the length with:
//     len(mockedNodeClient.SendFromCalls())
func (mock *NodeClientMock) SendFromCalls() []struct {
	Ctx    context.Context
	From   string
	To     string
	Amount uint64
	Opts   *models.OptsSendFrom
} {
	var calls []struct {
		Ctx    context.Context
		From   string
		To     string
		Amount uint64
		Opts   *models.OptsSendFrom
	}
	mock.lockSendFrom.RLock()
	calls = mock.calls.SendFrom
	mock.lockSendFrom.RUnlock()
	return calls
}

// SendMany calls SendManyFunc.
func (mock *NodeClientMock) SendMany(ctx context.Context, from string, amounts map[string]uint64, opts *models.OptsSendMany) (string, error) {
	if mock.SendManyFunc == nil {
		panic("NodeClientMock.SendManyFunc: method is nil but NodeClient.SendMany was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		From    string
		Amounts map[string]uint64
		Opts    *models.OptsSendMany
	}{
		Ctx:     ctx,
		From:    from,
		Amounts: amounts,
		Opts:    opts,
	}
	mock.lockSendMany.Lock()
	mock.calls.SendMany = append(mock.calls.SendMany, callInfo)
	mock.lockSendMany.Unlock()
	return mock.SendManyFunc(ctx, from, amounts, opts)
}

// SendManyCalls gets all the calls that were made to SendMany.
// Check the length with:
//     len(mockedNodeClient.SendManyCalls())
func (mock *NodeClientMock) SendManyCalls() []struct {
	Ctx     context.Context
	From    string
	Amounts map[string]uint64
	Opts    *models.OptsSendMany
} {
	var calls []struct {
		Ctx     context.Context
		From    string
		Amounts map[string]uint64
		Opts    *models.OptsSendMany
	}
	mock.lockSendMany.RLock()
	calls = mock.calls.SendMany
	mock.lockSendMany.RUnlock()
	return calls
}

// SendRawTransaction calls SendRawTransactionFunc.
func (mock *NodeClientMock) SendRawTransaction(ctx context.Context, tx *bt.Tx, opts *models.OptsSendRawTransaction) (string, error) {
	if mock.SendRawTransactionFunc == nil {
		panic("NodeClientMock.SendRawTransactionFunc: method is nil but NodeClient.SendRawTransaction was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Tx   *bt.Tx
		Opts *models.OptsSendRawTransaction
	}{
		Ctx:  ctx,
		Tx:   tx,
		Opts: opts,
	}
	mock.lockSendRawTransaction.Lock()
	mock.calls.SendRawTransaction = append(mock.calls.SendRawTransaction, callInfo)
	mock.lockSendRawTransaction.Unlock()
	return mock.SendRawTransactionFunc(ctx, tx, opts)
}

// SendRawTransactionCalls gets all the calls that were made to SendRawTransaction.
// Check the length with:
//     len(mockedNodeClient.SendRawTransactionCalls())
func (mock *NodeClientMock) SendRawTransactionCalls() []struct {
	Ctx  context.Context
	Tx   *bt.Tx
	Opts *models.OptsSendRawTransaction
} {
	var calls []struct {
		Ctx  context.Context
		Tx   *bt.Tx
		Opts *models.OptsSendRawTransaction
	}
	mock.lockSendRawTransaction.RLock()
	calls = mock.calls.SendRawTransaction
	mock.lockSendRawTransaction.RUnlock()
	return calls
}

// SendRawTransactions calls SendRawTransactionsFunc.
func (mock *NodeClientMock) SendRawTransactions(ctx context.Context, params ...models.ParamsSendRawTransactions) (*models.SendRawTransactionsResponse, error) {
	if mock.SendRawTransactionsFunc == nil {
		panic("NodeClientMock.SendRawTransactionsFunc: method is nil but NodeClient.SendRawTransactions was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params []models.ParamsSendRawTransactions
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockSendRawTransactions.Lock()
	mock.calls.SendRawTransactions = append(mock.calls.SendRawTransactions, callInfo)
	mock.lockSendRawTransactions.Unlock()
	return mock.SendRawTransactionsFunc(ctx, params...)
}

// SendRawTransactionsCalls gets all the calls that were made to SendRawTransactions.
// Check the length with:
//     len(mockedNodeClient.SendRawTransactionsCalls())
func (mock *NodeClientMock) SendRawTransactionsCalls() []struct {
	Ctx    context.Context
	Params []models.ParamsSendRawTransactions
} {
	var calls []struct {
		Ctx    context.Context
		Params []models.ParamsSendRawTransactions
	}
	mock.lockSendRawTransactions.RLock()
	calls = mock.calls.SendRawTransactions
	mock.lockSendRawTransactions.RUnlock()
	return calls
}

// SendToAddress calls SendToAddressFunc.
func (mock *NodeClientMock) SendToAddress(ctx context.Context, address string, amount uint64, opts *models.OptsSendToAddress) (string, error) {
	if mock.SendToAddressFunc == nil {
		panic("NodeClientMock.SendToAddressFunc: method is nil but NodeClient.SendToAddress was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
		Amount  uint64
		Opts    *models.OptsSendToAddress
	}{
		Ctx:     ctx,
		Address: address,
		Amount:  amount,
		Opts:    opts,
	}
	mock.lockSendToAddress.Lock()
	mock.calls.SendToAddress = append(mock.calls.SendToAddress, callInfo)
	mock.lockSendToAddress.Unlock()
	return mock.SendToAddressFunc(ctx, address, amount, opts)
}

// SendToAddressCalls gets all the calls that were made to SendToAddress.
// Check the length with:
//     len(mockedNodeClient.SendToAddressCalls())
func (mock *NodeClientMock) SendToAddressCalls() []struct {
	Ctx     context.Context
	Address string
	Amount  uint64
	Opts    *models.OptsSendToAddress
} {
	var calls []struct {
		Ctx     context.Context
		Address string
		Amount  uint64
		Opts    *models.OptsSendToAddress
	}
	mock.lockSendToAddress.RLock()
	calls = mock.calls.SendToAddress
	mock.lockSendToAddress.RUnlock()
	return calls
}

// SetAccount calls SetAccountFunc.
func (mock *NodeClientMock) SetAccount(ctx context.Context, address string, account string) error {
	if mock.SetAccountFunc == nil {
		panic("NodeClientMock.SetAccountFunc: method is nil but NodeClient.SetAccount was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
		Account string
	}{
		Ctx:     ctx,
		Address: address,
		Account: account,
	}
	mock.lockSetAccount.Lock()
	mock.calls.SetAccount = append(mock.calls.SetAccount, callInfo)
	mock.lockSetAccount.Unlock()
	return mock.SetAccountFunc(ctx, address, account)
}

// SetAccountCalls gets all the calls that were made to SetAccount.
// Check the length with:
//     len(mockedNodeClient.SetAccountCalls())
func (mock *NodeClientMock) SetAccountCalls() []struct {
	Ctx     context.Context
	Address string
	Account string
} {
	var calls []struct {
		Ctx     context.Context
		Address string
		Account string
	}
	mock.lockSetAccount.RLock()
	calls = mock.calls.SetAccount
	mock.lockSetAccount.RUnlock()
	return calls
}

// SetBan calls SetBanFunc.
func (mock *NodeClientMock) SetBan(ctx context.Context, subnet string, action internal.BanAction, opts *models.OptsSetBan) error {
	if mock.SetBanFunc == nil {
		panic("NodeClientMock.SetBanFunc: method is nil but NodeClient.SetBan was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Subnet string
		Action internal.BanAction
		Opts   *models.OptsSetBan
	}{
		Ctx:    ctx,
		Subnet: subnet,
		Action: action,
		Opts:   opts,
	}
	mock.lockSetBan.Lock()
	mock.calls.SetBan = append(mock.calls.SetBan, callInfo)
	mock.lockSetBan.Unlock()
	return mock.SetBanFunc(ctx, subnet, action, opts)
}

// SetBanCalls gets all the calls that were made to SetBan.
// Check the length with:
//     len(mockedNodeClient.SetBanCalls())
func (mock *NodeClientMock) SetBanCalls() []struct {
	Ctx    context.Context
	Subnet string
	Action internal.BanAction
	Opts   *models.OptsSetBan
} {
	var calls []struct {
		Ctx    context.Context
		Subnet string
		Action internal.BanAction
		Opts   *models.OptsSetBan
	}
	mock.lockSetBan.RLock()
	calls = mock.calls.SetBan
	mock.lockSetBan.RUnlock()
	return calls
}

// SetBlockMaxSize calls SetBlockMaxSizeFunc.
func (mock *NodeClientMock) SetBlockMaxSize(ctx context.Context, size uint64) (string, error) {
	if mock.SetBlockMaxSizeFunc == nil {
		panic("NodeClientMock.SetBlockMaxSizeFunc: method is nil but NodeClient.SetBlockMaxSize was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Size uint64
	}{
		Ctx:  ctx,
		Size: size,
	}
	mock.lockSetBlockMaxSize.Lock()
	mock.calls.SetBlockMaxSize = append(mock.calls.SetBlockMaxSize, callInfo)
	mock.lockSetBlockMaxSize.Unlock()
	return mock.SetBlockMaxSizeFunc(ctx, size)
}

// SetBlockMaxSizeCalls gets all the calls that were made to SetBlockMaxSize.
// Check the length with:
//     len(mockedNodeClient.SetBlockMaxSizeCalls())
func (mock *NodeClientMock) SetBlockMaxSizeCalls() []struct {
	Ctx  context.Context
	Size uint64
} {
	var calls []struct {
		Ctx  context.Context
		Size uint64
	}
	mock.lockSetBlockMaxSize.RLock()
	calls = mock.calls.SetBlockMaxSize
	mock.lockSetBlockMaxSize.RUnlock()
	return calls
}

// SetExcessiveBlock calls SetExcessiveBlockFunc.
func (mock *NodeClientMock) SetExcessiveBlock(ctx context.Context, size uint64) (string, error) {
	if mock.SetExcessiveBlockFunc == nil {
		panic("NodeClientMock.SetExcessiveBlockFunc: method is nil but NodeClient.SetExcessiveBlock was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Size uint64
	}{
		Ctx:  ctx,
		Size: size,
	}
	mock.lockSetExcessiveBlock.Lock()
	mock.calls.SetExcessiveBlock = append(mock.calls.SetExcessiveBlock, callInfo)
	mock.lockSetExcessiveBlock.Unlock()
	return mock.SetExcessiveBlockFunc(ctx, size)
}

// SetExcessiveBlockCalls gets all the calls that were made to SetExcessiveBlock.
// Check the length with:
//     len(mockedNodeClient.SetExcessiveBlockCalls())
func (mock *NodeClientMock) SetExcessiveBlockCalls() []struct {
	Ctx  context.Context
	Size uint64
} {
	var calls []struct {
		Ctx  context.Context
		Size uint64
	}
	mock.lockSetExcessiveBlock.RLock()
	calls = mock.calls.SetExcessiveBlock
	mock.lockSetExcessiveBlock.RUnlock()
	return calls
}

// SetNetworkActive calls SetNetworkActiveFunc.
func (mock *NodeClientMock) SetNetworkActive(ctx context.Context, enabled bool) error {
	if mock.SetNetworkActiveFunc == nil {
		panic("NodeClientMock.SetNetworkActiveFunc: method is nil but NodeClient.SetNetworkActive was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Enabled bool
	}{
		Ctx:     ctx,
		Enabled: enabled,
	}
	mock.lockSetNetworkActive.Lock()
	mock.calls.SetNetworkActive = append(mock.calls.SetNetworkActive, callInfo)
	mock.lockSetNetworkActive.Unlock()
	return mock.SetNetworkActiveFunc(ctx, enabled)
}

// SetNetworkActiveCalls gets all the calls that were made to SetNetworkActive.
// Check the length with:
//     len(mockedNodeClient.SetNetworkActiveCalls())
func (mock *NodeClientMock) SetNetworkActiveCalls() []struct {
	Ctx     context.Context
	Enabled bool
} {
	var calls []struct {
		Ctx     context.Context
		Enabled bool
	}
	mock.lockSetNetworkActive.RLock()
	calls = mock.calls.SetNetworkActive
	mock.lockSetNetworkActive.RUnlock()
	return calls
}

// SetTxFee calls SetTxFeeFunc.
func (mock *NodeClientMock) SetTxFee(ctx context.Context, amount uint64) (bool, error) {
	if mock.SetTxFeeFunc == nil {
		panic("NodeClientMock.SetTxFeeFunc: method is nil but NodeClient.SetTxFee was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Amount uint64
	}{
		Ctx:    ctx,
		Amount: amount,
	}
	mock.lockSetTxFee.Lock()
	mock.calls.SetTxFee = append(mock.calls.SetTxFee, callInfo)
	mock.lockSetTxFee.Unlock()
	return mock.SetTxFeeFunc(ctx, amount)
}

// SetTxFeeCalls gets all the calls that were made to SetTxFee.
// Check the length with:
//     len(mockedNodeClient.SetTxFeeCalls())
func (mock *NodeClientMock) SetTxFeeCalls() []struct {
	Ctx    context.Context
	Amount uint64
} {
	var calls []struct {
		Ctx    context.Context
		Amount uint64
	}
	mock.lockSetTxFee.RLock()
	calls = mock.calls.SetTxFee
	mock.lockSetTxFee.RUnlock()
	return calls
}

// SetTxPropagationFrequency calls SetTxPropagationFrequencyFunc.
func (mock *NodeClientMock) SetTxPropagationFrequency(ctx context.Context, frequency uint64) error {
	if mock.SetTxPropagationFrequencyFunc == nil {
		panic("NodeClientMock.SetTxPropagationFrequencyFunc: method is nil but NodeClient.SetTxPropagationFrequency was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Frequency uint64
	}{
		Ctx:       ctx,
		Frequency: frequency,
	}
	mock.lockSetTxPropagationFrequency.Lock()
	mock.calls.SetTxPropagationFrequency = append(mock.calls.SetTxPropagationFrequency, callInfo)
	mock.lockSetTxPropagationFrequency.Unlock()
	return mock.SetTxPropagationFrequencyFunc(ctx, frequency)
}

// SetTxPropagationFrequencyCalls gets all the calls that were made to SetTxPropagationFrequency.
// Check the length with:
//     len(mockedNodeClient.SetTxPropagationFrequencyCalls())
func (mock *NodeClientMock) SetTxPropagationFrequencyCalls() []struct {
	Ctx       context.Context
	Frequency uint64
} {
	var calls []struct {
		Ctx       context.Context
		Frequency uint64
	}
	mock.lockSetTxPropagationFrequency.RLock()
	calls = mock.calls.SetTxPropagationFrequency
	mock.lockSetTxPropagationFrequency.RUnlock()
	return calls
}

// Settings calls SettingsFunc.
func (mock *NodeClientMock) Settings(ctx context.Context) (*models.Settings, error) {
	if mock.SettingsFunc == nil {
		panic("NodeClientMock.SettingsFunc: method is nil but NodeClient.Settings was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSettings.Lock()
	mock.calls.Settings = append(mock.calls.Settings, callInfo)
	mock.lockSettings.Unlock()
	return mock.SettingsFunc(ctx)
}

// SettingsCalls gets all the calls that were made to Settings.
// Check the length with:
//     len(mockedNodeClient.SettingsCalls())
func (mock *NodeClientMock) SettingsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSettings.RLock()
	calls = mock.calls.Settings
	mock.lockSettings.RUnlock()
	return calls
}

// SignMessage calls SignMessageFunc.
func (mock *NodeClientMock) SignMessage(ctx context.Context, address string, message string) (string, error) {
	if mock.SignMessageFunc == nil {
		panic("NodeClientMock.SignMessageFunc: method is nil but NodeClient.SignMessage was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
		Message string
	}{
		Ctx:     ctx,
		Address: address,
		Message: message,
	}
	mock.lockSignMessage.Lock()
	mock.calls.SignMessage = append(mock.calls.SignMessage, callInfo)
	mock.lockSignMessage.Unlock()
	return mock.SignMessageFunc(ctx, address, message)
}

// SignMessageCalls gets all the calls that were made to SignMessage.
// Check the length with:
//     len(mockedNodeClient.SignMessageCalls())
func (mock *NodeClientMock) SignMessageCalls() []struct {
	Ctx     context.Context
	Address string
	Message string
} {
	var calls []struct {
		Ctx     context.Context
		Address string
		Message string
	}
	mock.lockSignMessage.RLock()
	calls = mock.calls.SignMessage
	mock.lockSignMessage.RUnlock()
	return calls
}

// SignMessageWithPrivKey calls SignMessageWithPrivKeyFunc.
func (mock *NodeClientMock) SignMessageWithPrivKey(ctx context.Context, w *wif.WIF, msg string) (string, error) {
	if mock.SignMessageWithPrivKeyFunc == nil {
		panic("NodeClientMock.SignMessageWithPrivKeyFunc: method is nil but NodeClient.SignMessageWithPrivKey was just called")
	}
	callInfo := struct {
		Ctx context.Context
		W   *wif.WIF
		Msg string
	}{
		Ctx: ctx,
		W:   w,
		Msg: msg,
	}
	mock.lockSignMessageWithPrivKey.Lock()
	mock.calls.SignMessageWithPrivKey = append(mock.calls.SignMessageWithPrivKey, callInfo)
	mock.lockSignMessageWithPrivKey.Unlock()
	return mock.SignMessageWithPrivKeyFunc(ctx, w, msg)
}

// SignMessageWithPrivKeyCalls gets all the calls that were made to SignMessageWithPrivKey.
// Check the length with:
//     len(mockedNodeClient.SignMessageWithPrivKeyCalls())
func (mock *NodeClientMock) SignMessageWithPrivKeyCalls() []struct {
	Ctx context.Context
	W   *wif.WIF
	Msg string
} {
	var calls []struct {
		Ctx context.Context
		W   *wif.WIF
		Msg string
	}
	mock.lockSignMessageWithPrivKey.RLock()
	calls = mock.calls.SignMessageWithPrivKey
	mock.lockSignMessageWithPrivKey.RUnlock()
	return calls
}

// SignRawTransaction calls SignRawTransactionFunc.
func (mock *NodeClientMock) SignRawTransaction(ctx context.Context, tx *bt.Tx, opts *models.OptsSignRawTransaction) (*models.SignedRawTransaction, error) {
	if mock.SignRawTransactionFunc == nil {
		panic("NodeClientMock.SignRawTransactionFunc: method is nil but NodeClient.SignRawTransaction was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Tx   *bt.Tx
		Opts *models.OptsSignRawTransaction
	}{
		Ctx:  ctx,
		Tx:   tx,
		Opts: opts,
	}
	mock.lockSignRawTransaction.Lock()
	mock.calls.SignRawTransaction = append(mock.calls.SignRawTransaction, callInfo)
	mock.lockSignRawTransaction.Unlock()
	return mock.SignRawTransactionFunc(ctx, tx, opts)
}

// SignRawTransactionCalls gets all the calls that were made to SignRawTransaction.
// Check the length with:
//     len(mockedNodeClient.SignRawTransactionCalls())
func (mock *NodeClientMock) SignRawTransactionCalls() []struct {
	Ctx  context.Context
	Tx   *bt.Tx
	Opts *models.OptsSignRawTransaction
} {
	var calls []struct {
		Ctx  context.Context
		Tx   *bt.Tx
		Opts *models.OptsSignRawTransaction
	}
	mock.lockSignRawTransaction.RLock()
	calls = mock.calls.SignRawTransaction
	mock.lockSignRawTransaction.RUnlock()
	return calls
}

// Stop calls StopFunc.
func (mock *NodeClientMock) Stop(ctx context.Context) error {
	if mock.StopFunc == nil {
		panic("NodeClientMock.StopFunc: method is nil but NodeClient.Stop was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockStop.Lock()
	mock.calls.Stop = append(mock.calls.Stop, callInfo)
	mock.lockStop.Unlock()
	return mock.StopFunc(ctx)
}

// StopCalls gets all the calls that were made to Stop.
// Check the length with:
//     len(mockedNodeClient.StopCalls())
func (mock *NodeClientMock) StopCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockStop.RLock()
	calls = mock.calls.Stop
	mock.lockStop.RUnlock()
	return calls
}

// SubmitBlock calls SubmitBlockFunc.
func (mock *NodeClientMock) SubmitBlock(ctx context.Context, block *bc.Block, params *models.OptsSubmitBlock) (string, error) {
	if mock.SubmitBlockFunc == nil {
		panic("NodeClientMock.SubmitBlockFunc: method is nil but NodeClient.SubmitBlock was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Block  *bc.Block
		Params *models.OptsSubmitBlock
	}{
		Ctx:    ctx,
		Block:  block,
		Params: params,
	}
	mock.lockSubmitBlock.Lock()
	mock.calls.SubmitBlock = append(mock.calls.SubmitBlock, callInfo)
	mock.lockSubmitBlock.Unlock()
	return mock.SubmitBlockFunc(ctx, block, params)
}

// SubmitBlockCalls gets all the calls that were made to SubmitBlock.
// Check the length with:
//     len(mockedNodeClient.SubmitBlockCalls())
func (mock *NodeClientMock) SubmitBlockCalls() []struct {
	Ctx    context.Context
	Block  *bc.Block
	Params *models.OptsSubmitBlock
} {
	var calls []struct {
		Ctx    context.Context
		Block  *bc.Block
		Params *models.OptsSubmitBlock
	}
	mock.lockSubmitBlock.RLock()
	calls = mock.calls.SubmitBlock
	mock.lockSubmitBlock.RUnlock()
	return calls
}

// SubmitMiningSolution calls SubmitMiningSolutionFunc.
func (mock *NodeClientMock) SubmitMiningSolution(ctx context.Context, solution *models.MiningSolution) (string, error) {
	if mock.SubmitMiningSolutionFunc == nil {
		panic("NodeClientMock.SubmitMiningSolutionFunc: method is nil but NodeClient.SubmitMiningSolution was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Solution *models.MiningSolution
	}{
		Ctx:      ctx,
		Solution: solution,
	}
	mock.lockSubmitMiningSolution.Lock()
	mock.calls.SubmitMiningSolution = append(mock.calls.SubmitMiningSolution, callInfo)
	mock.lockSubmitMiningSolution.Unlock()
	return mock.SubmitMiningSolutionFunc(ctx, solution)
}

// SubmitMiningSolutionCalls gets all the calls that were made to SubmitMiningSolution.
// Check the length with:
//     len(mockedNodeClient.SubmitMiningSolutionCalls())
func (mock *NodeClientMock) SubmitMiningSolutionCalls() []struct {
	Ctx      context.Context
	Solution *models.MiningSolution
} {
	var calls []struct {
		Ctx      context.Context
		Solution *models.MiningSolution
	}
	mock.lockSubmitMiningSolution.RLock()
	calls = mock.calls.SubmitMiningSolution
	mock.lockSubmitMiningSolution.RUnlock()
	return calls
}

// Transaction calls TransactionFunc.
func (mock *NodeClientMock) Transaction(ctx context.Context, txID string) (*models.Transaction, error) {
	if mock.TransactionFunc == nil {
		panic("NodeClientMock.TransactionFunc: method is nil but NodeClient.Transaction was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockTransaction.Lock()
	mock.calls.Transaction = append(mock.calls.Transaction, callInfo)
	mock.lockTransaction.Unlock()
	return mock.TransactionFunc(ctx, txID)
}

// TransactionCalls gets all the calls that were made to Transaction.
// Check the length with:
//     len(mockedNodeClient.TransactionCalls())
func (mock *NodeClientMock) TransactionCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockTransaction.RLock()
	calls = mock.calls.Transaction
	mock.lockTransaction.RUnlock()
	return calls
}

// UnconfirmedBalance calls UnconfirmedBalanceFunc.
func (mock *NodeClientMock) UnconfirmedBalance(ctx context.Context) (uint64, error) {
	if mock.UnconfirmedBalanceFunc == nil {
		panic("NodeClientMock.UnconfirmedBalanceFunc: method is nil but NodeClient.UnconfirmedBalance was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockUnconfirmedBalance.Lock()
	mock.calls.UnconfirmedBalance = append(mock.calls.UnconfirmedBalance, callInfo)
	mock.lockUnconfirmedBalance.Unlock()
	return mock.UnconfirmedBalanceFunc(ctx)
}

// UnconfirmedBalanceCalls gets all the calls that were made to UnconfirmedBalance.
// Check the length with:
//     len(mockedNodeClient.UnconfirmedBalanceCalls())
func (mock *NodeClientMock) UnconfirmedBalanceCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockUnconfirmedBalance.RLock()
	calls = mock.calls.UnconfirmedBalance
	mock.lockUnconfirmedBalance.RUnlock()
	return calls
}

// Uptime calls UptimeFunc.
func (mock *NodeClientMock) Uptime(ctx context.Context) (time.Duration, error) {
	if mock.UptimeFunc == nil {
		panic("NodeClientMock.UptimeFunc: method is nil but NodeClient.Uptime was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockUptime.Lock()
	mock.calls.Uptime = append(mock.calls.Uptime, callInfo)
	mock.lockUptime.Unlock()
	return mock.UptimeFunc(ctx)
}

// UptimeCalls gets all the calls that were made to Uptime.
// Check the length with:
//     len(mockedNodeClient.UptimeCalls())
func (mock *NodeClientMock) UptimeCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockUptime.RLock()
	calls = mock.calls.Uptime
	mock.lockUptime.RUnlock()
	return calls
}

// ValidateAddress calls ValidateAddressFunc.
func (mock *NodeClientMock) ValidateAddress(ctx context.Context, address string) (*models.ValidateAddress, error) {
	if mock.ValidateAddressFunc == nil {
		panic("NodeClientMock.ValidateAddressFunc: method is nil but NodeClient.ValidateAddress was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockValidateAddress.Lock()
	mock.calls.ValidateAddress = append(mock.calls.ValidateAddress, callInfo)
	mock.lockValidateAddress.Unlock()
	return mock.ValidateAddressFunc(ctx, address)
}

// ValidateAddressCalls gets all the calls that were made to ValidateAddress.
// Check the length with:
//     len(mockedNodeClient.ValidateAddressCalls())
func (mock *NodeClientMock) ValidateAddressCalls() []struct {
	Ctx     context.Context
	Address string
} {
	var calls []struct {
		Ctx     context.Context
		Address string
	}
	mock.lockValidateAddress.RLock()
	calls = mock.calls.ValidateAddress
	mock.lockValidateAddress.RUnlock()
	return calls
}

// VerifyBlockCandidate calls VerifyBlockCandidateFunc.
func (mock *NodeClientMock) VerifyBlockCandidate(ctx context.Context, block *bc.Block, params *models.OptsSubmitBlock) (string, error) {
	if mock.VerifyBlockCandidateFunc == nil {
		panic("NodeClientMock.VerifyBlockCandidateFunc: method is nil but NodeClient.VerifyBlockCandidate was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Block  *bc.Block
		Params *models.OptsSubmitBlock
	}{
		Ctx:    ctx,
		Block:  block,
		Params: params,
	}
	mock.lockVerifyBlockCandidate.Lock()
	mock.calls.VerifyBlockCandidate = append(mock.calls.VerifyBlockCandidate, callInfo)
	mock.lockVerifyBlockCandidate.Unlock()
	return mock.VerifyBlockCandidateFunc(ctx, block, params)
}

// VerifyBlockCandidateCalls gets all the calls that were made to VerifyBlockCandidate.
// Check the length with:
//     len(mockedNodeClient.VerifyBlockCandidateCalls())
func (mock *NodeClientMock) VerifyBlockCandidateCalls() []struct {
	Ctx    context.Context
	Block  *bc.Block
	Params *models.OptsSubmitBlock
} {
	var calls []struct {
		Ctx    context.Context
		Block  *bc.Block
		Params *models.OptsSubmitBlock
	}
	mock.lockVerifyBlockCandidate.RLock()
	calls = mock.calls.VerifyBlockCandidate
	mock.lockVerifyBlockCandidate.RUnlock()
	return calls
}

// VerifyChain calls VerifyChainFunc.
func (mock *NodeClientMock) VerifyChain(ctx context.Context) (bool, error) {
	if mock.VerifyChainFunc == nil {
		panic("NodeClientMock.VerifyChainFunc: method is nil but NodeClient.VerifyChain was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockVerifyChain.Lock()
	mock.calls.VerifyChain = append(mock.calls.VerifyChain, callInfo)
	mock.lockVerifyChain.Unlock()
	return mock.VerifyChainFunc(ctx)
}

// VerifyChainCalls gets all the calls that were made to VerifyChain.
// Check the length with:
//     len(mockedNodeClient.VerifyChainCalls())
func (mock *NodeClientMock) VerifyChainCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockVerifyChain.RLock()
	calls = mock.calls.VerifyChain
	mock.lockVerifyChain.RUnlock()
	return calls
}

// VerifySignedMessage calls VerifySignedMessageFunc.
func (mock *NodeClientMock) VerifySignedMessage(ctx context.Context, w *wif.WIF, signature string, message string) (bool, error) {
	if mock.VerifySignedMessageFunc == nil {
		panic("NodeClientMock.VerifySignedMessageFunc: method is nil but NodeClient.VerifySignedMessage was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		W         *wif.WIF
		Signature string
		Message   string
	}{
		Ctx:       ctx,
		W:         w,
		Signature: signature,
		Message:   message,
	}
	mock.lockVerifySignedMessage.Lock()
	mock.calls.VerifySignedMessage = append(mock.calls.VerifySignedMessage, callInfo)
	mock.lockVerifySignedMessage.Unlock()
	return mock.VerifySignedMessageFunc(ctx, w, signature, message)
}

// VerifySignedMessageCalls gets all the calls that were made to VerifySignedMessage.
// Check the length with:
//     len(mockedNodeClient.VerifySignedMessageCalls())
func (mock *NodeClientMock) VerifySignedMessageCalls() []struct {
	Ctx       context.Context
	W         *wif.WIF
	Signature string
	Message   string
} {
	var calls []struct {
		Ctx       context.Context
		W         *wif.WIF
		Signature string
		Message   string
	}
	mock.lockVerifySignedMessage.RLock()
	calls = mock.calls.VerifySignedMessage
	mock.lockVerifySignedMessage.RUnlock()
	return calls
}

// WalletInfo calls WalletInfoFunc.
func (mock *NodeClientMock) WalletInfo(ctx context.Context) (*models.WalletInfo, error) {
	if mock.WalletInfoFunc == nil {
		panic("NodeClientMock.WalletInfoFunc: method is nil but NodeClient.WalletInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockWalletInfo.Lock()
	mock.calls.WalletInfo = append(mock.calls.WalletInfo, callInfo)
	mock.lockWalletInfo.Unlock()
	return mock.WalletInfoFunc(ctx)
}

// WalletInfoCalls gets all the calls that were made to WalletInfo.
// Check the length with:
//     len(mockedNodeClient.WalletInfoCalls())
func (mock *NodeClientMock) WalletInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockWalletInfo.RLock()
	calls = mock.calls.WalletInfo
	mock.lockWalletInfo.RUnlock()
	return calls
}

// WalletLock calls WalletLockFunc.
func (mock *NodeClientMock) WalletLock(ctx context.Context) error {
	if mock.WalletLockFunc == nil {
		panic("NodeClientMock.WalletLockFunc: method is nil but NodeClient.WalletLock was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockWalletLock.Lock()
	mock.calls.WalletLock = append(mock.calls.WalletLock, callInfo)
	mock.lockWalletLock.Unlock()
	return mock.WalletLockFunc(ctx)
}

// WalletLockCalls gets all the calls that were made to WalletLock.
// Check the length with:
//     len(mockedNodeClient.WalletLockCalls())
func (mock *NodeClientMock) WalletLockCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockWalletLock.RLock()
	calls = mock.calls.WalletLock
	mock.lockWalletLock.RUnlock()
	return calls
}

// WalletPhassphrase calls WalletPhassphraseFunc.
func (mock *NodeClientMock) WalletPhassphrase(ctx context.Context, passphrase string, timeout int) error {
	if mock.WalletPhassphraseFunc == nil {
		panic("NodeClientMock.WalletPhassphraseFunc: method is nil but NodeClient.WalletPhassphrase was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Passphrase string
		Timeout    int
	}{
		Ctx:        ctx,
		Passphrase: passphrase,
		Timeout:    timeout,
	}
	mock.lockWalletPhassphrase.Lock()
	mock.calls.WalletPhassphrase = append(mock.calls.WalletPhassphrase, callInfo)
	mock.lockWalletPhassphrase.Unlock()
	return mock.WalletPhassphraseFunc(ctx, passphrase, timeout)
}

// WalletPhassphraseCalls gets all the calls that were made to WalletPhassphrase.
// Check the length with:
//     len(mockedNodeClient.WalletPhassphraseCalls())
func (mock *NodeClientMock) WalletPhassphraseCalls() []struct {
	Ctx        context.Context
	Passphrase string
	Timeout    int
} {
	var calls []struct {
		Ctx        context.Context
		Passphrase string
		Timeout    int
	}
	mock.lockWalletPhassphrase.RLock()
	calls = mock.calls.WalletPhassphrase
	mock.lockWalletPhassphrase.RUnlock()
	return calls
}

// WalletPhassphraseChange calls WalletPhassphraseChangeFunc.
func (mock *NodeClientMock) WalletPhassphraseChange(ctx context.Context, oldPassphrase string, newPassphrase string) error {
	if mock.WalletPhassphraseChangeFunc == nil {
		panic("NodeClientMock.WalletPhassphraseChangeFunc: method is nil but NodeClient.WalletPhassphraseChange was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		OldPassphrase string
		NewPassphrase string
	}{
		Ctx:           ctx,
		OldPassphrase: oldPassphrase,
		NewPassphrase: newPassphrase,
	}
	mock.lockWalletPhassphraseChange.Lock()
	mock.calls.WalletPhassphraseChange = append(mock.calls.WalletPhassphraseChange, callInfo)
	mock.lockWalletPhassphraseChange.Unlock()
	return mock.WalletPhassphraseChangeFunc(ctx, oldPassphrase, newPassphrase)
}

// WalletPhassphraseChangeCalls gets all the calls that were made to WalletPhassphraseChange.
// Check the length with:
//     len(mockedNodeClient.WalletPhassphraseChangeCalls())
func (mock *NodeClientMock) WalletPhassphraseChangeCalls() []struct {
	Ctx           context.Context
	OldPassphrase string
	NewPassphrase string
} {
	var calls []struct {
		Ctx           context.Context
		OldPassphrase string
		NewPassphrase string
	}
	mock.lockWalletPhassphraseChange.RLock()
	calls = mock.calls.WalletPhassphraseChange
	mock.lockWalletPhassphraseChange.RUnlock()
	return calls
}
